<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript:call和apply的ES6和ES5实现</title>
    <url>/2022/02/07/JavaScript:%20call%E5%92%8Capply%E7%9A%84ES5%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h3 id="JavaScript-call和apply的ES6和ES5实现"><a href="#JavaScript-call和apply的ES6和ES5实现" class="headerlink" title="JavaScript:call和apply的ES6和ES5实现"></a>JavaScript:call和apply的ES6和ES5实现</h3><h4 id="首先来看一下call和apply的定义和作用"><a href="#首先来看一下call和apply的定义和作用" class="headerlink" title="首先来看一下call和apply的定义和作用"></a>首先来看一下call和apply的定义和作用</h4><blockquote>
<p>**<code>call()</code> **方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p>
</blockquote>
<p>总的来说，call和apply的区别就是参数的不同。</p>
<span id="more"></span>

<h4 id="call的实现"><a href="#call的实现" class="headerlink" title="call的实现"></a>call的实现</h4><p>举个例子：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre>

<p>需要注意的两点是：</p>
<ul>
<li><p>call 改变了 this 的指向，指向到 foo</p>
</li>
<li><p>bar 函数执行了</p>
</li>
</ul>
<h5 id="call实现的第一步："><a href="#call实现的第一步：" class="headerlink" title="call实现的第一步："></a>call实现的第一步：</h5><p>当调用 call 的时候，可以把 foo 对象改造成如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre>

<p>但是这样会给foo对象多加了一个属性，不过可以使用之后可以删除。</p>
<p>所以这个可以拆分成三步：</p>
<ul>
<li><p>将函数设为对象的属性</p>
</li>
<li><p>执行该函数</p>
</li>
<li><p>删除该函数</p>
</li>
</ul>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 第一步</span>
foo<span class="token punctuation">.</span>fn <span class="token operator">=</span> bar
<span class="token comment">// 第二步</span>
foo<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 第三步</span>
<span class="token keyword">delete</span> foo<span class="token punctuation">.</span>fn</code></pre>

<p>所以call的v1可以这样写：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// callES6v1</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token function">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首先要获取调用call的函数，用this可以获取</span>
    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    delete context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>接下来就是要注意的几个问题：</p>
<p><strong>1.this 参数可以传 null，当为 null 的时候，视为指向 window</strong></p>
<p><strong>2.函数是可以有返回值的！</strong></p>
<p><strong>3.call可以传入多个参数</strong></p>
<p><strong>4.给对象添加的属性名不能冲突</strong></p>
<p><strong>5.调用call的必须是函数</strong></p>
<p>这些都是小问题：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// callES6v2</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token function">function</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">if</span><span class="token punctuation">(</span>typeof <span class="token keyword">this</span> <span class="token operator">!=</span><span class="token operator">=</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  	<span class="token comment">// this 参数可以传 null，当为 null 的时候，视为指向 window</span>
    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
  	<span class="token comment">// 给对象添加的属性名不能冲突</span>
    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  	<span class="token comment">// call可以传入多个参数</span>
    let result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
  	<span class="token comment">// 函数是可以有返回值的</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>以上就是call的es6实现，下面手写es5实现。es5实现逻辑和es6一样，前面都分析好了，就是语法的问题而已。</p>
<p>需要理解的语法：</p>
<ul>
<li><code>eval()</code> 函数会将传入的字符串当做 JavaScript 代码进行执行。可以理解为HTML5中的script标签。</li>
</ul>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// callES5</span>
<span class="token comment">// 模拟symbol的函数</span>
<span class="token keyword">function</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> unique_proper <span class="token operator">=</span> <span class="token string">'hcb'</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>unique_proper<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unique_proper <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unique_proper<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCallES5</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
    fn <span class="token operator">=</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  
  	<span class="token comment">// 如果只有一个参数的话，那么直接返回对象执行绑定函数的结果。</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> fnStr <span class="token operator">=</span> <span class="token string">'context[fn]('</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fnStr <span class="token operator">+=</span> i <span class="token operator">==</span> args<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">','</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    fnStr <span class="token operator">+=</span> <span class="token string">')'</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span>fnStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>同理，apply的es6实现和es5实现如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApplyES6v2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
    fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
    <span class="token comment">// 这里为什么要return呢，因为可能绑定的函数会返回一个对象</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// es5的写法</span>
<span class="token keyword">function</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> unique_proper <span class="token operator">=</span> <span class="token string">'hcb'</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>unique_proper<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unique_proper <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unique_proper<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> fnStr <span class="token operator">=</span> <span class="token string">'context[fn]('</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fnStr <span class="token operator">+=</span> i <span class="token operator">==</span> args<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">','</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    fnStr <span class="token operator">+=</span> <span class="token string">')'</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span>fnStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript: prototype、__proto__、[[prototype]]的区别</title>
    <url>/2022/02/03/JavaScript:%20prototype%E3%80%81__proto__%E3%80%81%5B%5Bprototype%5D%5D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="prototype、-proto-、-prototype-三者之间的区别"><a href="#prototype、-proto-、-prototype-三者之间的区别" class="headerlink" title="prototype、__proto__、[[prototype]] 三者之间的区别"></a>prototype、__proto__、[[prototype]] 三者之间的区别</h3><p>最近在网上看到 <code>instanceof</code> 的手写版，里面涉及到了 <code>prototype</code>、<code>__proto__</code>，仔细推敲 一下代码，发现自己对 <code>prototype</code>, <code>__proto__ </code> 的理解不够深刻导致自己对手写版的 instanceof 代码理解不是很透彻。</p>
<span id="more"></span>

<p>首先来看一下 <code>instanceof</code> 的手写代码</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 拿到obj的</span>
    <span class="token keyword">let</span> implicitPrototype <span class="token operator">=</span> obj<span class="token operator">?.</span>__proto__<span class="token punctuation">;</span>
    <span class="token keyword">const</span> displayPrototype <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>implicitPrototype<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>implicitPrototype <span class="token operator">===</span> displayPrototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        implicitPrototype <span class="token operator">=</span> implicitPrototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>如果不是很清楚 <code>prototype</code> , <code>__proto__</code> 的话，很难正确理解上述代码。所以我们先要搞清楚它们的区别。</p>
<p><strong>1. 概念区分</strong></p>
<p>其实说 <code>__proto__</code> 并不准确，确切的说是对象的 <code>[[prototype]]</code> 属性，只不过在主流的浏览器中，都用 <code>__proto__</code> 来代表 <code>[[prototype]]</code> 属性，因为 <code>[[prototype]] </code>只是一个标准，而针对这个标准，不同的浏览器有不同的实现方式。在ES5中用 <code>Object.getPrototypeOf</code> 函数获得一个对象的 <code>[[prototype]]</code>。ES6中，使用  <code>Object.setPrototypeOf</code> 可以直接修改一个对象的 <code>[[prototype]]</code>。</p>
<p>而 <code>prototype</code> 属性是只有函数才特有的属性，当你创建一个函数时，js会自动为这个函数加上 <code>prototype</code> 属性，值是一个空对象。所以，函数在js中是非常特殊的，是所谓的一等公民。</p>
<p><strong>2.必须明确</strong></p>
<p><code>__proto__ </code>是隐式原型</p>
<p><code>prototype</code> 是显式原型</p>
<p>显式原型 ：每一个函数在创建之后都会拥有一个名为 <code>prototype</code> 的属性，这个属性指向函数的原型对象。</p>
<p>隐式原型：JavaScript中任意对象都有一个内置属性 <code>[[prototype]]</code>，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过 <code>__proto__</code> 来访问。</p>
<p>注意:  <code>Object.prototype</code> 这个对象是个例外，它的 <code>__proto__</code> 值为 <code>null</code></p>
<p><strong>二者的关系：</strong></p>
<p><strong>隐式原型指向创建这个对象的函数(constructor)的 prototype</strong></p>
<p><strong>3.他们的作用</strong></p>
<p>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问 obj 这个对象中的x属性时，如果在 obj 中找不到，那么就会沿着 <code>__proto__</code> 依次查找。</p>
<p>显式原型的作用：用来实现基于原型的继承与属性的共享</p>
<p>所以现在我们可以分析一下 <code>instanceof </code>代码了。一般来说，<code>instanceof </code>内部实现机制和隐式原型、显式原型有直接的关系。<code>instanceof </code>的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。</p>
<p>所以在我们的手写代码中：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//设 obj instanceof constructor</span>
<span class="token comment">//通过判断</span>
 obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">===</span> constructor<span class="token punctuation">.</span>prototype
<span class="token comment">//最终返回true or false</span></code></pre>

<p>也就是一直沿着obj的 <code>__proto__ </code> 一直寻找下去，知道等于 <code>constructor.prototype</code> 或者 <code>null</code> 为止。</p>
<p>这就是instanceof的原理</p>
<p>4.进一步的探究</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>

<p>上面两行代码的结果都为 true，这就有点奇怪了</p>
<h6 id="接下来我们来探究一下："><a href="#接下来我们来探究一下：" class="headerlink" title="接下来我们来探究一下："></a>接下来我们来探究一下：</h6><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//null</span></code></pre>

<p>所以原型链的尽头（root）是 <code>Object.prototype</code>。<strong>所有对象均从 <code>Object.prototype</code> 继承属性。</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Function<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>

<p>所以 <code>Function.prototype</code>  和 <code>Function.__proto__</code> 为<strong>同一对象</strong>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Array<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> String<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Object<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Number<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Boolean<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>

<p>这意味着： <strong><code>Object</code>/<code>Array</code>/<code>String</code> 等等构造函数本质上和 <code>Function</code> 一样，均继承于 <code>Function.prototype</code>。</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>

<p>最后 <code>Function.prototype</code> 直接继承 <code>Object.prototype</code></p>
<p><strong>总结</strong>：<strong>先有 <code>Object.prototype</code>（原型链顶端）， <code>Function.prototype</code> 继承 <code>Object.prototype</code> 而产生，最后，<code>Function</code> 和 <code>Object</code> 和其它构造函数继承 <code>Function.prototype</code> 而产生。</strong></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript：探索bind和new之间的关系</title>
    <url>/2022/02/07/JavaScript:%20%E6%8E%A2%E7%B4%A2bind%E5%92%8Cnew%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="JavaScript-手写-bind-和探索-bind-与-new-之间的关系"><a href="#JavaScript-手写-bind-和探索-bind-与-new-之间的关系" class="headerlink" title="JavaScript: 手写 bind 和探索 bind 与 new 之间的关系"></a>JavaScript: 手写 bind 和探索 bind 与 new 之间的关系</h3><p>首先了解一下 <code>bind</code> 的定义</p>
<blockquote>
<p><strong><code>bind()</code></strong> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
</blockquote>
<p>也就是说 <code>bind</code> 和 <code>apply</code> 、<code>call</code> 不一样，<code>bind</code> 是返回一个待执行函数，并且可以传入参数。来看一看 <code>bind</code> 的例子</p>
<span id="more"></span>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 返回了一个函数</span>
<span class="token keyword">var</span> bindFoo <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token comment">// bindFoo() 相当于 bar.bind(foo)();</span></code></pre>

<p>所以 <code>bind</code> 返回的是一个函数（这也是为什么 <code>new</code> 可以改变 <code>bind</code>  后函数的 <code>this</code> 指向的原因）并且返回的函数可以继续传入参数。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bindFoo <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'daisy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1</span>
<span class="token comment">// daisy</span>
<span class="token comment">// 18</span></code></pre>

<p>所以要对参数进行处理。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 第二版</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取myBind第二个参数到最后一个参数</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这个时候的arguments是指bind返回的函数传入的参数，这个arguments和上面的不是同一个</span>
        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>



<p>到这里 <code>bind</code> 的基本功能差不多完成了，但是 <code>bind</code> 还有一个特点，那就是和 <code>new</code> 配合使用的时候，<code>bind </code> 时指定的  <code>this</code>  值会失效，但传入的参数依然生效。下面这个例子就可以说明。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>habit <span class="token operator">=</span> <span class="token string">'game'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bindFoo <span class="token operator">=</span> bar<span class="token punctuation">.</span><span class="token function">myBind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'hcb'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bindFoo</span><span class="token punctuation">(</span><span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里bind绑定的this值已经失效了</span>
<span class="token comment">// undefined</span>
<span class="token comment">// hcb</span>
<span class="token comment">// 18</span></code></pre>

<p>所以我们要通过修改返回的函数的原型来实现</p>
<p>特别要注意下面的代码执行完只是返回 <code>fBound</code> ，函数里面的语句还未执行，所以这就是为什么这里能判断 <code>fBound</code> 里面的 <code>this</code> 到底指向普通函数还是构造函数</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span>
        <span class="token comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span>
      	<span class="token comment">// 这里有同学就问了，这里怎么判定this是属于构造函数还是普通函数的呢？</span>
      	<span class="token comment">// 因为bind返回的是一个函数的定义，在new中这个函数被调用，所以这里的this是到调用的时候才确定的</span>
      	<span class="token comment">// </span>
        <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fBound</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，因为js中对象是引用传递</span>
    fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token keyword">return</span> fBound<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。为什么也会直接修改呢？因为这里是引用类型，这个时候，我们可以通过一个空函数来进行中转。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  	<span class="token comment">// 只有函数才能调用bind，所以要加这个判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Function.prototype.bind - what is trying to be bound is not callable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">fNOP</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fNOP</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    fNOP<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fNOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> fBound<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>来看一下 <code>new</code> 的手写实现：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myNew4</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token string">'fn must be a function'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token comment">// 如果fn返回值是一个对象的话，那么就返回这个对象里面的东西</span>
    <span class="token comment">// 如果不是的话，那么就返回构造出来的对象</span>
    <span class="token comment">// console.log(obj);</span>
  	
  	<span class="token comment">// 这里的fn可以看作bind里面return出来的fBound，所以到这里fBound的this就被改变了</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj变成fn这个函数的this</span>
    <span class="token comment">// console.log(obj);</span>
    <span class="token keyword">return</span> res <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> res <span class="token operator">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript：JavaScript数组探究</title>
    <url>/2022/01/08/JavaScript%E6%95%B0%E7%BB%84%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="JavaScript数组探究"><a href="#JavaScript数组探究" class="headerlink" title="JavaScript数组探究"></a>JavaScript数组探究</h1><p>数组作为最基础的数据结构，我们不仅要熟练掌握它，还要了解它的许多特性</p>
<p>js的数组很灵活，和其他语言的数组不一样，js的数组可以存储不同类型的值</p>
<span id="more"></span>

<h3 id="创建一维数组的两种方法"><a href="#创建一维数组的两种方法" class="headerlink" title="创建一维数组的两种方法"></a>创建一维数组的两种方法</h3><p>1.数组字面量法</p>
<p>需要注意的是：使用数组字面量法创建数组并不会调用Array构造函数</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>

<p>2.使用Array的构造函数，new一个数组</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 指定数组长度</span>
<span class="token keyword">let</span> arr3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 指定长度，且填充1</span>
<span class="token keyword">let</span> arr4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// new操作符可以省略，一个长度为二的数组</span>
<span class="token keyword">let</span> arr6 <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"arr6:"</span><span class="token punctuation">,</span> arr6<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 当参数只有一个数字的时候，就是创建一个长度为传入参数的数组</span>
<span class="token keyword">let</span> arr7 <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"arr7:"</span><span class="token punctuation">,</span> arr7<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 遍历数组</span>
arr4<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 还可以用map来遍历数组</span>
<span class="token comment">// map 方法在调用形式上与 forEach 无异，</span>
<span class="token comment">// 区别在于 map 方法会根据你传入的函数逻辑对数组中每个元素进行处理、进而返回一个全新的数组。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"map遍历"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr5 <span class="token operator">=</span> arr4<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> item <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>·</code></pre>



<h3 id="二维数组的创建"><a href="#二维数组的创建" class="headerlink" title="二维数组的创建"></a>二维数组的创建</h3><p>一维数组可以使用数组字面量和使用Array的构造函数创建</p>
<p>那么二维数组呢？</p>
<p>下面来看一下这样初始化对不对</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 现在我们来改变一下二维数组里面的值</span>
arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里发现里面的值全都变成了35，这是为什么呢</span></code></pre>

<p>这里是因为 fill 的工作机制导致的。 当给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用。所以fill里面的数组是同一个引用、指向的是同一块内存空间，它们本质上是同一个数组所以应该用for循环来初始化一个二维数组</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<h3 id="数组的一些方法"><a href="#数组的一些方法" class="headerlink" title="数组的一些方法"></a>数组的一些方法</h3><h4 id="pop-push-shift-unshift-方法"><a href="#pop-push-shift-unshift-方法" class="headerlink" title="pop/push, shift/unshift 方法"></a>pop/push, shift/unshift 方法</h4><ul>
<li><p><code>push</code> 在末端添加一个元素</p>
</li>
<li><p><code>pop</code> 从末端取出一个元素</p>
</li>
<li><p><code>unshift</code> 在队列首端添加一个元素，整个队列往后移一位</p>
</li>
<li><p><code>shift</code> 取出队列首端的一个元素，整个队列往前移一位</p>
</li>
</ul>
<p>这里会有一个性能问题，那就是<code>push</code>和 <code>pop</code>的性能会比<code>shift</code>和<code>unshift</code>高，因为<code>shift</code>和<code>unshift</code>会移动整个数组，这样很浪费时间。</p>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>数组的遍历方式有三种</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"beiyep"</span><span class="token punctuation">,</span> <span class="token string">"kobe"</span><span class="token punctuation">,</span> <span class="token string">"james"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 用数组的长度遍历</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用for of遍历</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用for in遍历</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>需要说明的是，for in返回的是数组的下标值，并且要注意：</p>
<ol>
<li><p><code>for..in</code> 循环会遍历 <strong>所有属性</strong>，不仅仅是这些数字属性。</p>
<p>在浏览器和其它环境中有一种称为“类数组”的对象，它们 <strong>看似是数组</strong>。也就是说，它们有 <code>length</code> 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。<code>for..in</code> 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。</p>
<p>来看下面的🌰：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myfun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'myfun'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>    
<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> arr2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span></code></pre>

<p>运行结果如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy8x3wx4ndj30z80903yk.jpg"></p>
<p>上面的例子很好的反映了for…in…循环的缺点，原本只想循环取出该数组的数据，但是由于之前给数组添加了原型函数，导致循环的结果多了一个函数</p>
</li>
<li><p><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。</p>
</li>
</ol>
<h4 id="数组中的搜索"><a href="#数组中的搜索" class="headerlink" title="数组中的搜索"></a>数组中的搜索</h4><ol>
<li>严格相等</li>
</ol>
<p>js提供了indexOf/lastIndexOf 和 includes三种严格相等的搜索方法。其中</p>
<ul>
<li><code>arr.indexOf(item, from)</code> 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</li>
<li><code>arr.lastIndexOf(item, from)</code> —— 和上面相同，只是从右向左搜索。</li>
<li><code>arr.includes(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>，如果没找到，则返回 <code>false</code></li>
</ul>
<p>请注意，这些方法使用的是严格相等 <code>===</code> 比较。所以如果我们搜索 <code>false</code>，会精确到的确是 <code>false</code> 而不是数字 <code>0</code>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 从索引2开始搜索1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span>

<span class="token comment">// 从索引3开始搜索13</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>

<span class="token comment">// 从零开始搜索true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span></code></pre>



<p>如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 <code>arr.includes</code> 是首选。</p>
<p>此外，<code>includes</code> 的一个非常小的差别是它能正确处理<code>NaN</code>，而不像 <code>indexOf/lastIndexOf</code></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">NaN</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>



<ol start="2">
<li>断言函数搜索</li>
</ol>
<p>arr.find和arr.findIndex是js提供的断言函数搜索，每个索引都会调用这个函数。</p>
<p>arr.find的语法如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果返回 true，则返回 item 并停止迭代</span>
  <span class="token comment">// 对于假值（false）的情况，则返回 undefined</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>arr.findIndex 方法（与 <code>arr.find</code> 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 <code>-1</code>。</p>
<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h4><p>由于数组是基于对象的，不构成单独的语言类型，所以 typeof 不能帮助从数组中区分出普通对象：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span></code></pre>

<p>为了解决这个问题，Array.isArray应运而生，如果 <code>value</code> 是一个数组，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>



<h4 id="数组中方法的补充说明"><a href="#数组中方法的补充说明" class="headerlink" title="数组中方法的补充说明"></a>数组中方法的补充说明</h4><p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p>
<p>比如：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> thisArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> thisArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> thisArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token comment">// thisArg 是可选的最后一个参数</span></code></pre>

<p>举个🌰：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> army <span class="token operator">=</span> <span class="token punctuation">{</span>
    minAge<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    maxAge<span class="token operator">:</span> <span class="token number">27</span><span class="token punctuation">,</span>
    <span class="token function">canJoin</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> user<span class="token punctuation">.</span>age <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>minAge <span class="token operator">&amp;&amp;</span> user<span class="token punctuation">.</span>age <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxAge<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">let</span> users <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 找到 army.canJoin 返回 true 的 user</span>
	<span class="token keyword">let</span> soldiers <span class="token operator">=</span> users<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>army<span class="token punctuation">.</span>canJoin<span class="token punctuation">,</span> army<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// let soldiers = users.filter(army.canJoin); // 错误</span>
  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>soldiers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>soldiers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>soldiers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 23</span></code></pre>

<p>如果在上面的示例中我们使用了 <code>users.filter(army.canJoin)</code>，那么 <code>army.canJoin</code> 将被作为独立函数调用，并且这时 <code>this=undefined</code>，从而会导致即时错误。所以我们这里一般都用剪头函数。</p>
<h3 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h3><p>数组是一种特殊的对象，比如数组访问元素的方式是arr[0]和对象obj[key]很相似，其中arr是对象，数字用作键。数组和类相似，也是引用类型。但是数组又拓展了对象，因为数组可以处理有序的数据集合。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS几种常见的布局</title>
    <url>/2022/01/31/CSS%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="几种常见且基础的CSS布局"><a href="#几种常见且基础的CSS布局" class="headerlink" title="几种常见且基础的CSS布局"></a>几种常见且基础的CSS布局</h3><h4 id="一-单列布局"><a href="#一-单列布局" class="headerlink" title="一. 单列布局"></a>一. 单列布局</h4><p>常见的单列布局有两种：</p>
<ul>
<li>header,content和footer等宽的单列布局</li>
<li>header与footer等宽,content略窄的单列布局</li>
</ul>
<span id="more"></span>

<ol>
<li><p>第一种通过设置header、content、footer统一设置width：1000px;或者max-width：1000px即可实现。区别在于显示屏幕小于1000px时，前者会有滚动条出现，而后者不会（也就是说后者显示的是实际宽度）</p>
<blockquote>
<p>max-width 属性用来给元素设置最大宽度值. 定义了max-width的元素会在达到max-width值之后避免进一步按照width属性设置变大.</p>
<p>max-width 会覆盖width设置, 但 min-width设置会覆盖 max-width.</p>
</blockquote>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.header</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 1960px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.content</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 1960px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.footer</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 1960px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> teal<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
<li><p>第二种可以给中间的content设置一个固定的width，然后header、content、footer都居中显示。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.header</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.content</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 100px auto 100px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 1000px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.footer</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
</ol>
<h4 id="二-两列布局"><a href="#二-两列布局" class="headerlink" title="二. 两列布局"></a>二. 两列布局</h4><p>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式</p>
<ol>
<li><p>普通两列布局（单列定宽单列自适应），用浮动+margin即可</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.left</span> <span class="token punctuation">{</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 450px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.right</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
<li><p>两列自适应布局：float和overflow配合可实现两列自适应效果。使用overflow属性来触发bfc，来阻止浮动造成的文字环绕效果。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.p</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token selector">.content</span> <span class="token punctuation">{</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> grey<span class="token punctuation">;</span>
            <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token selector">.left</span> <span class="token punctuation">{</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">margin-right</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token selector">.right</span> <span class="token punctuation">{</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
<li><p>Flex布局：也叫弹性盒子布局，简单几行代码就可以实现各种页面的的布局。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.content</span> <span class="token punctuation">{</span>
            <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.right</span> <span class="token punctuation">{</span>
            <span class="token property">margin-left</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.left</span> <span class="token punctuation">{</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>111111jlfdjlfjowejfoewjo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre>





<h4 id="3-三栏布局"><a href="#3-三栏布局" class="headerlink" title="3. 三栏布局"></a>3. 三栏布局</h4><blockquote>
<p>三栏布局就是两边宽度固定,中间自适应的布局.</p>
<p>改变浏览器的宽度,两边的宽度不会变,只会中间区域的宽度变长变短.</p>
</blockquote>
<p>流体布局：</p>
<p>圣杯布局：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.container</span> <span class="token punctuation">{</span>
            <span class="token property">padding-left</span><span class="token punctuation">:</span> 220px<span class="token punctuation">;</span>
            <span class="token property">padding-right</span><span class="token punctuation">:</span> 220px<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.main</span> <span class="token punctuation">{</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> lightgrey<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.left</span> <span class="token punctuation">{</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
            <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
            <span class="token comment">/* margin-left: -200px; */</span>
            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
            <span class="token property">left</span><span class="token punctuation">:</span> -220px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> lightblue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.right</span> <span class="token punctuation">{</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
            <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
            <span class="token comment">/* margin-left: -100%; */</span>
            <span class="token comment">/* margin-left中百分比是距离最近的块容器的宽度 width */</span>
            <span class="token comment">/* 而px的话就是绝对距离 */</span>
            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
            <span class="token property">right</span><span class="token punctuation">:</span> -220px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
</ol>
]]></content>
      <categories>
        <category>CSS笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote01：React的特点和优点</title>
    <url>/2022/01/12/ReactNote01:%20React%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E7%82%B9/</url>
    <content><![CDATA[<p>React作为国内最流行的前端框架之一，肯定有它的好用先进之处，作为技术geek，那肯定要学穿它🤔</p>
<span id="more"></span>

<h3 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h3><ol>
<li>声明式编程<ul>
<li>允许我们只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界面;</li>
</ul>
</li>
<li>组件化开发<ul>
<li>能把一个大问题分解成一个小问题一个个实现，便于开发和维护。</li>
</ul>
</li>
<li>多平台适配<ul>
<li>React不仅能开发网页应用，React Native也能开发Android和iOS应用。</li>
</ul>
</li>
</ol>
<blockquote>
<p>除此之外，学习React还能掌握先进的技术和思想。并且React的思想被许多框架借鉴，比如Google的Flutter框架就借鉴了React的思想，老美有意思的一点就是他借鉴React的思想，直接官网摆明了说出来。</p>
</blockquote>
<h3 id="React开发依赖"><a href="#React开发依赖" class="headerlink" title="React开发依赖"></a><strong>React开发依赖</strong></h3><p>开发React必须依赖三个库:</p>
<ul>
<li>react:包含react所必须的核心代码</li>
<li>react-dom:react渲染在不同平台所需要的核心代码</li>
<li>babel:将jsx转换成React代码的工具<ul>
<li>babel可以将es6语法转换为es5语法，并且可以将jsx语法转换为js语法。帮助我们更好的进行开发。</li>
</ul>
</li>
</ul>
<blockquote>
<p> react包中包含了react和react-native所共同拥有的核心代码。</p>
</blockquote>
<p>react-dom针对web和native所完成的事情不同:</p>
<ul>
<li>web端:react-dom会讲jsx最终渲染成真实的DOM，显示在浏览器中</li>
<li>native端:react-dom会讲jsx最终渲染成原生的控件(比如Android中的Button，iOS中的UIButton)</li>
</ul>
<h3 id="React的优点"><a href="#React的优点" class="headerlink" title="React的优点"></a>React的优点</h3><p>为什么需要React呢，我们来看一个案例，要求点击按钮，网页上的文字内容会发生改变。</p>
<p>以下是原生实现。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>change text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">

        <span class="token comment">// 这里是命令式编程，就是给计算机一步步指令去完成一件事</span>

        <span class="token comment">// 1.定义数据</span>
        <span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">;</span>

        <span class="token comment">// 2.将数据显示在h2元素中</span>
        <span class="token keyword">let</span> titleEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"title"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        titleEl<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> message<span class="token punctuation">;</span>

        <span class="token comment">// 3.点击按钮，页面数据发生改变</span>
        <span class="token keyword">let</span> btnEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        btnEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            message <span class="token operator">=</span> <span class="token string">"Hello, React!"</span><span class="token punctuation">;</span>
            titleEl<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> message<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>再来看看React实现，是不是感觉代码有点多，还比原生的复杂了。这里是因为我们调用了render函数，并且还没用到React的声明式编程和组件化开发的特点。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/babel<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">

        <span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token string">"Hello,World!"</span><span class="token punctuation">;</span>

        <span class="token keyword">function</span> <span class="token function">btnClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            message <span class="token operator">=</span> <span class="token string">"Hello,React!"</span><span class="token punctuation">;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
                <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>btnClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>change text<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>


    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react@16/umd/react.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react-dom@16/umd/react-dom.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- babel转换代码 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/babel-standalone@6/babel.min.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>下面再来看利用了React特点写的代码</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/babel<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
        <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
            <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
                    message<span class="token operator">:</span> <span class="token string">"Hello,World"</span><span class="token punctuation">,</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span>
                    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                        <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
                        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>btnClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>change text<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token function-variable function">btnClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token comment">// this.state.message = "Hello,React";</span>
                <span class="token comment">// console.log(this.state);</span>

                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                    message<span class="token operator">:</span> <span class="token string">"Hello,React"</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react@16/umd/react.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react-dom@16/umd/react-dom.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- babel转换代码 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/babel-standalone@6/babel.min.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>看起来确实优雅了不少。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote02：了解JSX语法</title>
    <url>/2022/01/12/ReactNote02:%E4%BA%86%E8%A7%A3JSX%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="欲要学好React，JSX语法须先行"><a href="#欲要学好React，JSX语法须先行" class="headerlink" title="欲要学好React，JSX语法须先行"></a>欲要学好React，JSX语法须先行</h3><h3 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h3><p>先来看这样的一段代码：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code></pre>

<p>是不是感觉有点怪怪的，因为它既不是字符串，也不是HTML，它就是 JSX，是一个 JavaScript 的语法扩展。React官方建议在 React 中配合使用 JSX，因为JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。</p>
<span id="more"></span>

<p><strong>在JSX中插入javascript的方式</strong></p>
<p>在 JSX 语法中，你可以在大括号内放置任何有效的 <strong>JavaScript 表达式</strong>。（什么是表达式？）</p>
<pre class="language-react" data-language="react"><code class="language-react">const name = 'james kobe';
const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;

ReactDOM.render(
  element,
  document.getElementById('root')
);</code></pre>

<p>为了便于阅读，我们可以将JSX语法拆分成多行，并将内容包裹在小括号中，这样可以避免陷入自动插入分号的陷阱。</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/div&gt;
);</code></pre>



<p><strong>JSX也是一个表达式</strong></p>
<p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p>
<p>也就是说，你可以在 <code>if</code> 语句和 <code>for</code> 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：</p>
<pre class="language-react" data-language="react"><code class="language-react">function getGreeting(user) {
  if (user) {
    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;
  }
  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;
}</code></pre>



<p><strong>JSX的特定属性</strong></p>
<p>你可以通过使用引号，来将属性值指定为字符串字面量：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;;</code></pre>

<p>也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code></pre>

<p>在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。</p>
<p><strong>需要注意的是：</strong></p>
<ul>
<li><p>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p>
</li>
<li><p>例如，JSX 里的 <code>class</code> 变成了 <code>className</code>，而 <code>tabindex</code> 则变为 <code>tabIndex</code>。</p>
</li>
<li><p>JSX的顶层<strong>只能有一个根元素</strong>，所以我们很多时候会在外层包裹一个div原生(或者使用后面我们学习的Fragment);</p>
</li>
<li><p>JSX中的标签可以是单标签，也可以是双标签。注意:如果是单标签，必须以<code>/&gt;</code>结尾;     </p>
</li>
</ul>
<p><strong>使用 JSX 指定子元素</strong></p>
<p>假如一个标签里面没有内容，也就是说这个标签是一个单标签的话，你可以使用 <code>/&gt;</code> 来闭合标签，就像 XML 语法一样：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = &lt;img src={user.avatarUrl} /&gt;;</code></pre>

<p>JSX 标签里能够包含很多子元素:</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/div&gt;
);</code></pre>



<p><strong>JSX 表示对象</strong></p>
<p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p>
<p>以下两种示例代码完全等效：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = (
  &lt;h1 className="greeting"&gt;
    Hello, world!
  &lt;/h1&gt;
);

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);</code></pre>



<h4 id="疑问：（什么是表达式？表达式和语句又有什么区别呢？）"><a href="#疑问：（什么是表达式？表达式和语句又有什么区别呢？）" class="headerlink" title="疑问：（什么是表达式？表达式和语句又有什么区别呢？）"></a>疑问：（什么是表达式？表达式和语句又有什么区别呢？）</h4><p>语句指的是执行单元，通常以行为单位，表达式指的是可用于计算的式子，即可能产生一个值的式子。语句可以包含有表达式，表达式也可以单独形成一个语句。</p>
<p><strong>表达式会产生一个值，如赋值表达式：a=1。在控制台输出1。</strong></p>
<p><strong>表达式可以参与运算</strong>，如：</p>
<p>var c = 1==2 ? 3 : 4;</p>
<p>1==2 是一个表达式，1==2 ? 3 : 4这也是一个表达式，表达式是由运算符构成并运算产生结果的语法结构。</p>
<p>我们通常用”;”来分隔语句，组成程序，而本身就是语句的语法结构如：</p>
<p>if(){}else{} for(){} 等。</p>
<p>表达式一般由操作符和操作数组成，而我们把表达式按照语法结构组成语句，然后组成程序，表达式跟语句有重合的部分。</p>
<p>因此可以理解为表达式通常是语句的一部分或者本身就能起到一个语句的作用，而语句代表一段可执行的程序的最小单元。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote04：组件通信方式</title>
    <url>/2022/01/31/ReactNote04:%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="组件间的通信方式"><a href="#组件间的通信方式" class="headerlink" title="组件间的通信方式"></a>组件间的通信方式</h3><h4 id="1-父组件传递信息给子组件"><a href="#1-父组件传递信息给子组件" class="headerlink" title="1. 父组件传递信息给子组件"></a>1. 父组件传递信息给子组件</h4><blockquote>
<p>先看React官网的一句话：当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
</blockquote>
<span id="more"></span>

<p>以下例子说明了父组件传递信息给子组件的方式是：在父组件的子组件中写形参的时候，React会将子组件接受到的属性转换为props对象传递给组件，所以渲染子组件的时候就可以使用props里面的数据了。函数组件同理。</p>
<pre class="language-react" data-language="react"><code class="language-react">import React, { Component } from 'react'
class Son extends Component {
    constructor(props) {
        super(props);
        this.state = {
        }
    }
    render() {
        // 为什么这里可以通过this.props取得父组件里面传来的值呢？
        const { name, age, height } = this.props;
        return (
            &lt;div&gt;
                &lt;h2&gt;{name + " " + age + " " + height}&lt;/h2&gt;
            &lt;/div&gt;
        )
    }
}

export default class App extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;Son name="beiyep" age="18" height="1.88"&gt;&lt;/Son&gt;
                &lt;Son name="hala" age="188" height="1.88"&gt;&lt;/Son&gt;
                &lt;Son name="indexjs" age="11118" height="1.8228"&gt;&lt;/Son&gt;
            &lt;/div&gt;
        )
    }
}</code></pre>



<h4 id="2-组件传递信息时的数据验证"><a href="#2-组件传递信息时的数据验证" class="headerlink" title="2. 组件传递信息时的数据验证"></a>2. 组件传递信息时的数据验证</h4><pre class="language-react" data-language="react"><code class="language-react">import React, { Component } from 'react';
import PropTypes from "prop-types";

function Son(props) {
    const { name, age, height, names } = props;
    return (
        &lt;div&gt;
            &lt;h2&gt;{name + " " + age + " " + height}&lt;/h2&gt;
            &lt;ul&gt;
                {
                    names.map((item, index) =&gt; {
                        return &lt;li&gt;{item}&lt;/li&gt;
                    })
                }
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}

Son.propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number,
    height: PropTypes.number,
    names: PropTypes.array
}

// 默认属性
Son.defaultProps = {
    name: "hcb",
    age: 11,
    height: 178,
    names: ["hcb", "bbxk"]
}



export default class App extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;Son name="beiyep333" age="18" height="1.88" names={["aaa", "bbb", "ccc"]}&gt;&lt;/Son&gt;
                &lt;Son name="hala333" age="188" height="1.88" names={["aaa", "bbb", "ccc"]}&gt;&lt;/Son&gt;
                &lt;Son name="indexjs函数" age="11118" height="1.8228"&gt;&lt;/Son&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>



]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote05：深入源码探究memo、PureComponent</title>
    <url>/2022/02/08/ReactNote05-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6memo%E3%80%81PureComponent/</url>
    <content><![CDATA[<h3 id="深入源码探究memo、PureComponent"><a href="#深入源码探究memo、PureComponent" class="headerlink" title="深入源码探究memo、PureComponent"></a>深入源码探究memo、PureComponent</h3><h4 id="窥探PureComponent"><a href="#窥探PureComponent" class="headerlink" title="窥探PureComponent"></a>窥探PureComponent</h4><p>今天学到了PureComponent，它可以起到在Component里面添加SCU的效果，虽然类组件以后会很少用，但是它的底层原理还是要了解一下，也能了解一下React不断进步背后的思想，PureComponent在React里面是怎么实现的呢，肘，跟我进源码（版本是16.3.1）。</p>
<p>这里安利一下vscode的Bookmarks插件，看源码是非常方便。</p>
<span id="more"></span>

<blockquote>
<p>以下源码均为节选</p>
</blockquote>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 路径</span>
<span class="token comment">// packages/react-reconciler/src/ReactFiberClassComponent.js</span>

<span class="token keyword">function</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>
  <span class="token parameter">workInProgress<span class="token punctuation">,</span>
  ctor<span class="token punctuation">,</span>
  oldProps<span class="token punctuation">,</span>
  newProps<span class="token punctuation">,</span>
  oldState<span class="token punctuation">,</span>
  newState<span class="token punctuation">,</span>
  nextContext<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
    
  <span class="token comment">// 判断是否使用了shouldComponentUpdate</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用了shouldComponentUpdate的话，那么就比较State和props的数据</span>
    <span class="token comment">// 如果变化就返回true，不变化的话就返回false</span>
    <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>
      newProps<span class="token punctuation">,</span>
      newState<span class="token punctuation">,</span>
      nextContext<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> shouldUpdate<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 判断是否使用了PureReactComponent</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token comment">// 浅层比较，注意有取反操作</span>
      <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    
  <span class="token comment">// 默认返回的是true，也就是更新</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>这里就弄清楚了判断组件的更新的逻辑，下面我们再看一下shallowEqual这个函数，按住commond进去，</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> shallowEqual <span class="token keyword">from</span> <span class="token string">'shared/shallowEqual'</span><span class="token punctuation">;</span></code></pre>

<p>去<code>share</code>文件夹里面找<code>shallowEqual</code>这个文件</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">shallowEqual</span><span class="token punctuation">(</span><span class="token parameter">objA<span class="token operator">:</span> mixed<span class="token punctuation">,</span> objB<span class="token operator">:</span> mixed</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
  <span class="token comment">// 同一个对象返回ture，到了checkShouldComponentUpdate那里就是false，因为进行取反操作了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 不是对象或者为空就强制刷新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> objA <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span>
    objA <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span>
    <span class="token keyword">typeof</span> objB <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span>
    objB <span class="token operator">===</span> <span class="token keyword">null</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	
  
  <span class="token keyword">const</span> keysA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objA<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> keysB <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objB<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token comment">// 如果两个对象的key的长度不一样的话，那么数据肯定发生了变化</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>keysA<span class="token punctuation">.</span>length <span class="token operator">!==</span> keysB<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	
  <span class="token comment">// 如果A中和B中的key值不一样，那就更新</span>
  <span class="token comment">// Test for A's keys different from B.</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keysA<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      <span class="token operator">!</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>objB<span class="token punctuation">,</span> keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> objB<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<h4 id="窥探memo"><a href="#窥探memo" class="headerlink" title="窥探memo"></a>窥探memo</h4><p>既然memo和PureComponent作用类似，那么其原理应该也是和PureComponent思想类似</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// packages/react/src/memo.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span><span class="token constant">REACT_MEMO_TYPE</span><span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'shared/ReactSymbols'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> isValidElementType <span class="token keyword">from</span> <span class="token string">'shared/isValidElementType'</span><span class="token punctuation">;</span>

<span class="token comment">// 这里是可以传入两个参数的，如果没有传入第二个参数呢？</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> memo<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span><span class="token punctuation">(</span>
  type<span class="token operator">:</span> React$ElementType<span class="token punctuation">,</span>
  compare<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">oldProps<span class="token operator">:</span> Props<span class="token punctuation">,</span> newProps<span class="token operator">:</span> Props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> boolean<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_MEMO_TYPE</span><span class="token punctuation">,</span>
    type<span class="token punctuation">,</span>
    compare<span class="token operator">:</span> compare <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> compare<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>那么源码已经用<code>compare = compare !== null ? compare : shallowEqual;</code>帮助我们做了判断，意思就是如果我们传入了自己编写的compare函数，那么就用这个函数，否则它帮我们调用shallowEqual函数。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">updateMemoComponent</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  Component<span class="token operator">:</span> any<span class="token punctuation">,</span>
  nextProps<span class="token operator">:</span> any<span class="token punctuation">,</span>
  updateExpirationTime<span class="token punctuation">,</span>
  renderExpirationTime<span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Fiber <span class="token punctuation">{</span>
  
  <span class="token keyword">let</span> currentChild <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>child<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> Fiber<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This is always exactly one child</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>updateExpirationTime <span class="token operator">&lt;</span> renderExpirationTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevProps <span class="token operator">=</span> currentChild<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
    <span class="token keyword">let</span> compare <span class="token operator">=</span> Component<span class="token punctuation">.</span>compare<span class="token punctuation">;</span>
    compare <span class="token operator">=</span> compare <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> compare <span class="token operator">:</span> shallowEqual<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>ref <span class="token operator">===</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>
        current<span class="token punctuation">,</span>
        workInProgress<span class="token punctuation">,</span>
        renderExpirationTime<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>工程中 QuoteUtil文件夹阅读笔记</title>
    <url>/2022/12/03/Week11_1%EF%BC%9AQuoteUtil%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="工程中QuoteUtil文件夹阅读笔记"><a href="#工程中QuoteUtil文件夹阅读笔记" class="headerlink" title="工程中QuoteUtil文件夹阅读笔记"></a>工程中QuoteUtil文件夹阅读笔记</h1><p>[toc]</p>
<h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p>目录结构：</p>
<pre class="language-apl" data-language="apl"><code class="language-apl"><span class="token dyadic-operator operator">.</span>
├── ColorManager
├── FTEmptyTableViewCell<span class="token dyadic-operator operator">.</span>h
├── FTEmptyTableViewCell<span class="token dyadic-operator operator">.</span>m
├── FTEmptyTableViewCell<span class="token dyadic-operator operator">.</span>xib
├── FTQuoteAlertUtil<span class="token dyadic-operator operator">.</span>swift
├── FTQuoteCustomEmptyFailedView<span class="token dyadic-operator operator">.</span>h
├── FTQuoteCustomEmptyFailedView<span class="token dyadic-operator operator">.</span>m
├── FTQuoteCustomEmptyNoDataView<span class="token dyadic-operator operator">.</span>h
├── FTQuoteCustomEmptyNoDataView<span class="token dyadic-operator operator">.</span>m
├── FTQuoteCustomLoadingEmptyDataSetView<span class="token dyadic-operator operator">.</span>h
├── FTQuoteCustomLoadingEmptyDataSetView<span class="token dyadic-operator operator">.</span>m
├── FTQuoteCustomLoadingView<span class="token dyadic-operator operator">.</span>h
├── FTQuoteCustomLoadingView<span class="token dyadic-operator operator">.</span>m
├── FTQuoteStockNewsMiniView<span class="token dyadic-operator operator">.</span>h
├── FTQuoteStockNewsMiniView<span class="token dyadic-operator operator">.</span>m
├── FTQuoteUtil<span class="token dyadic-operator operator">.</span>h
├── FTQuoteUtil<span class="token dyadic-operator operator">.</span>m
├── FTSensorsTimeTrackManager<span class="token dyadic-operator operator">.</span>h
├── FTSensorsTimeTrackManager<span class="token dyadic-operator operator">.</span>m
└── UIImage<span class="token function">+</span>Share<span class="token dyadic-operator operator">.</span>swift</code></pre>



<h3 id="模块对应组件"><a href="#模块对应组件" class="headerlink" title="模块对应组件"></a>模块对应组件</h3><p>上面这些代码对应的都是牛牛中的什么组件？其实看名字也能猜出个大概，文件名中很多都有Empty字眼，猜测是没网时数据加载不出来需要展示的组件。</p>
<p>怎么去找呢？</p>
<ol>
<li>在你想要找到这个模块中打一个断点，根据名字猜测出大概的位置，然后在模拟器上多点几下试试，如果当前页面触发了断点，那么该页面就调用了此代码模块对应的组件，打开牛牛bate版，找到对应的页面，摇一摇打开3D视图，就能很清楚的看到这个组件的信息了。</li>
<li>同时牛牛也是一个庞大的工程，如果像无头苍蝇一样乱点的话，可能点半天也找不到对应的组件，那就要从代码里面的注释去抓敏感信息。</li>
</ol>
<p>对应第一个方法：以下图片为 <code>FTQuoteCustomLoadingEmptyDataSetView</code> 对应的组件</p>
<span id="more"></span>

<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5wxdimm2tj20u01sx7ab.jpg" style="zoom: 25%;">



<p>对应第二个方法：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5yaqloi3zj21880seaex.jpg" style="zoom:50%;">

<p>看到代码中有“资讯”两字，就应该去资讯页去找对应的组件</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5yaplykznj218q0u0tbw.jpg" style="zoom:50%;">





<h3 id="代码片段解读"><a href="#代码片段解读" class="headerlink" title="代码片段解读"></a>代码片段解读</h3><blockquote>
<p>futunn/ftphonequote/Business/Quote/QuoteUtil/FTQuoteCustomLoadingEmptyDataSetView.m</p>
</blockquote>
<pre class="language-objc" data-language="objc"><code class="language-objc">- (FTQuoteCustomEmptyFailedView *)failedView {
    if (!_failedView) {
        _failedView = [[FTQuoteCustomEmptyFailedView alloc] init];
        _failedView.contentEdgeTopInset = self.contentEdgeTopInset;
        ft_weakify_self;
        _failedView.didClickButtonBlock = ^(UIButton * _Nonnull button) {
            ft_strongify_self;
            if ([self.delegate respondsToSelector:@selector(emptyDataSetView:didTapButton:)]) {
                [self.delegate emptyDataSetView:self didTapButton:button];
            }
        };
    }
    return _failedView;
}</code></pre>



<p>这里的 <code>ft_weakify_self</code> 和 <code>ft_strongify_self</code> 是什么意思呢？为什么要在block前一行和block里面调用这个东西呢？</p>
<p>点进去一看，发现 <code>ft_weakify_self</code> 就是 <code>@weakify(self)</code> 。</p>
<pre class="language-objc" data-language="objc"><code class="language-objc">//
//  FTWeakHelper.h
//  FTCocoaDevelopKit
//
//  Created by jenson on 2018/10/26.
//  Copyright © 2018年 FUTU. All rights reserved.
//

#ifndef FTWeakHelper_h
#define FTWeakHelper_h

#import "EXTScope.h"

#define ft_weakify_self  @weakify(self)

#define ft_strongify_self \
@strongify(self); \
if (self == nil) { \
return ; \
}

#define ft_strongify_self_nil_return(returnValue) \
@strongify(self); \
if (self == nil) { \
return returnValue; \
}


#endif /* FTWeakHelper_h */
</code></pre>



<p>为什么会有这么多换行符呢？</p>
<p>首先来了解下宏的一些基本东西</p>
<pre class="language-none"><code class="language-none">- 程序第一步是在预编译之前会有一些操作, 例如删除反斜线和换行符的组合, 将每个注释用一个空格替代...,
- 然后在进入预编译的时候, 会寻找可能存在的预处理指定(由#开头), 例如C中常用的#include, 或者oc中的#import, #define...很多(条件编译语句...)
- 处理#define的时候,然后预处理器会从#开始, 一直到执行到第一个换行符(写代码的时候换行的作用), 自然, #define只会允许定义一行的宏, 不过正因为上面提到的预处理之前会删除反斜线和换行符的组合, 所以可以利用反斜线定义多行宏, 在删除反斜线和换行符的组合后, 逻辑上就成了一行的宏了
- 宏作用在预编译时期, 其真正的效果就是代码替换, 而且是直接替换(内联函数!!!), 这个和函数有着很大的区别, 并且正因为是直接替换, 在使用的时候就需要注意了
- 宏可以被称为 类对象宏, 类函数宏
- 宏在预处理阶段只进行文本的替换(相当于把代码拷贝粘贴), 不会进行具体的计算(发生在编译时期)</code></pre>



<p>了解了这个我们再来回答：为什么要在block前一行和block里面调用这个东西呢？</p>
<p>来看一下一个循环引用的例子：假设一个对象有一个强引用的 block 属性，同时此 block 通过 self 指针访问了该对象的其它属性，这将导致 block 也对该对象进行了强引用。这样的话会引起内存泄露，block和当前对象都无法释放。</p>
<p>所以 <code>ft_weakify_self</code> 的作用是：block 对 self 是弱引用引用，打破了循环引用的闭环</p>
<p><code>ft_strongify_self</code> 的作用是：避免 block 代码执行一半，self 指向的对象被释放</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://xie.infoq.cn/article/903068956d7c2a5952059b16c">一篇文章搞懂 @weakify 和 @strongify</a></p>
<p><a href="https://www.jianshu.com/p/bc794fa07167">介绍iOS中@strongify和@weakify</a></p>
<p><a href="https://www.jianshu.com/p/60e219324356">IOS-OC-@synthesize 的作用</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试学习笔记</title>
    <url>/2022/11/11/Week12_1%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="单元测试学习笔记"><a href="#单元测试学习笔记" class="headerlink" title="单元测试学习笔记"></a>单元测试学习笔记</h1><p>[toc]</p>
<h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>为什么需要单元测试？</p>
<ul>
<li>迫使从调用者的角度去思考，从而优化代码结构使其可测试性高</li>
<li>更细致地去测试代码，提高代码的健壮性</li>
</ul>
<h3 id="单元测试（Unit-Test）"><a href="#单元测试（Unit-Test）" class="headerlink" title="单元测试（Unit Test）"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/basis_info?id=%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88unit-test%EF%BC%89">单元测试（Unit Test）</a></h3><p>一个单元测试是一段测试代码，这段测试代码调用生产代码的一个工作单元(如一个方法)，并检验该工作单元的一个具体的最终结果。</p>
<p>如果关于这个最终结果的假设不成立，那这个单元测试就失败了。</p>
<span id="more"></span>

<h3 id="最终结果（Final-Result）"><a href="#最终结果（Final-Result）" class="headerlink" title="最终结果（Final Result）"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/basis_info?id=%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C%EF%BC%88final-result%EF%BC%89">最终结果（Final Result）</a></h3><p>上面提到工作单元的概念，一个工作单元一般会产生以下三种最终结果的一种：</p>
<ol>
<li>返回一个值</li>
<li>改变了被测系统的某个状态（例如，某个全局变量，或类的某个成员数据）</li>
<li>调用了一个其他工作单元（例如，某个第三方接口，或类的某个其他方法）</li>
</ol>
<h2 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/basis_info?id=%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">框架简介</a></h2><h3 id="XCTest"><a href="#XCTest" class="headerlink" title="XCTest"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/basis_info?id=xctest">XCTest</a></h3><p>XCTest 是官方提供的测试框架，使用它可以为 Xcode 项目编写单元测试，同时也可以进行性能测试和 UI 测试。其基本内容有：</p>
<ul>
<li><code>XCTestCase</code> 用于定义测试用例、测试方法和性能测试的基类。</li>
<li><code>XCTAssert</code>、<code>XCTAssertEqual</code> 和 <code>XCTAssertNotEqual</code> 等宏为官方提供的测试断言，通过判断代码执行期间是否满足某些条件，来检查测试方法中的预期值和结果。</li>
</ul>
<p><a href="https://developer.apple.com/documentation/xctest"> XCTest官方文档</a></p>
<p><code>XCTest</code>工具类提供了一系列的断言方法，主要分 5 类：</p>
<ul>
<li>无条件失败 <code>XCTFail</code></li>
<li>布尔断言 <code>XCTAssertTrue</code>、<code>XCTAssertFalse</code></li>
<li>相等断言 <code>XCTAssertEqual</code>、<code>XCTAssertEqualObjects</code>、<code>XCTAssertGreaterThan</code></li>
<li>空值断言 <code>XCTAssertNil</code>、<code>XCTAssertNotNil</code></li>
<li>异常断言 <code>XCTAssertThrows</code></li>
</ul>
<p>在编写断言语句时，<strong>应避免滥用 bool 判断断言方法，尽可能避免自行判断</strong></p>
<p>例如：<code>XCTAssertTrue(1 == 2)</code>应该写成<code>XCTAssertEqual(1, 2)</code>，这样当报错的时候，后者可以更好告诉我们错误信息是什么</p>
<blockquote>
<p>注意：用例的执行顺序并不是按照用例名字典顺序或我们编写用例顺序执行的，而类似于<strong>乱序执行</strong>，因此我们应<strong>保证每个测试用例相互独立且稳定，用例每次的执行都不受其他用例或执行顺序的影响</strong></p>
</blockquote>
<pre class="language-none"><code class="language-none">setUp 实例函数，通常用来做一些所有测试用例都需要执行的准备动作，例如准备 Mock 数据、初始化环境等
tearDown 实例函数，通常用来做一些所有测试用例都需要执行的回收动作，例如资源回收、变量重置等</code></pre>

<p>有时候我们会遇到<strong>单独执行每个用例都是通过的，但执行整个测试类就会出现失败</strong>的情况，通常都是因为静态变量、单例、环境等未做好重置回收或初始化工作，导致用例间相互影响造成的</p>
<p><code>setUp</code> 和 <code>tearDown</code> 前面一直提到实例方法，为什么一直强调实例方法呢，因为它俩还有同名类方法！</p>
<pre class="language-objectivec" data-language="objectivec"><code class="language-objectivec"><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setUp<span class="token punctuation">;</span>
<span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>tearDown<span class="token punctuation">;</span></code></pre>

<p>实例方法是用于标识<strong>测试类每个用例执行前和执行后</strong>所执行的函数，而类方法是用于标识<strong>测试类所有用例执行前和执行后</strong>所执行的函数</p>
<p>执行顺序：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h68g10gu9qj20vt0u03zd.jpg" style="zoom:33%;">



<h3 id="OCMock"><a href="#OCMock" class="headerlink" title="OCMock"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/basis_info?id=ocmock">OCMock</a></h3><p>OCMock 是一个用于为 iOS 或 MacOS 项目配置 Mock 的测试框架。其基本内容有：</p>
<ul>
<li><code>OCMClassMock()</code> 进行 Mock 对象，进行代替真实对象。</li>
<li><code>OCMStub()</code> 指定调用方法要返回的内容。</li>
</ul>
<p><a href="https://ocmock.org/"> OCMock官方文档</a></p>
<h4 id="类Mock"><a href="#类Mock" class="headerlink" title="类Mock"></a>类Mock</h4><pre class="language-none"><code class="language-none">id classMock = OCMClassMock([SomeClass class]);</code></pre>

<h4 id="协议Mock"><a href="#协议Mock" class="headerlink" title="协议Mock"></a>协议Mock</h4><pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">id protocolMock = OCMProtocolMock(@protocol(SomeProtocol));</code></pre>

<h4 id="严格的类和协议Mock"><a href="#严格的类和协议Mock" class="headerlink" title="严格的类和协议Mock"></a>严格的类和协议Mock</h4><p>默认的 mock 方式是nil (方法调用的时候返回nil或者是返回正确的方法)</p>
<p>严格的模式下，mock 的对象在调用没有被 stub (置换)的方法的时候,会抛出异常</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">id classMock = OCMStrictClassMock([SomeClass class]);
id protocolMock = OCMStrictProtocolMock(@protocol(SomeProtocol));</code></pre>

<h4 id="部分Mock"><a href="#部分Mock" class="headerlink" title="部分Mock"></a>部分Mock</h4><pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">id partialMock = OCMPartialMock(anObject)</code></pre>

<p>这样创建的对象在调用方法时:</p>
<ul>
<li>如果方法被stub，调用stub后的方法</li>
<li>如果方法没有被stub，调用原来的对象的方法</li>
</ul>
<p>partialMock 对象在调用方法后,可以用于稍后的验证此方法的调用情况(被调用,调用结果)</p>
<h4 id="观察者Mock"><a href="#观察者Mock" class="headerlink" title="观察者Mock"></a>观察者Mock</h4><pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">id observerMock = OCMObserverMock();</code></pre>

<p>这样创建的对象可以用于观察/通知.</p>
<h4 id="Mock创建对象方法"><a href="#Mock创建对象方法" class="headerlink" title="Mock创建对象方法"></a>Mock创建对象方法</h4><p>在实际开发过程中，经常会出现 A 对象依赖 B 对象，但 B 对象不是通过依赖注入的方式进行创建，而是在 A 对象内部进行创建 B 对象场景。</p>
<blockquote>
<p>什么是依赖？</p>
<p>对象A持有了对象B，我们就可以说对象A依赖对象B，或者对象B是对象A的一个依赖。一个对象需要的依赖越多，该对象耦合度越高，也就越难解耦</p>
<p>什么是依赖注入？</p>
<p>依赖注入(Dependency Injection) 是面向对象编程的一种设计模式，用来减少代码之间的耦合度。通常基于接口来实现，也就是说：不需要亲自new一个对象，而是通过相关的控制器来获取对象</p>
<p>注入的方式</p>
<p>依赖注入的方式常见有两种：构造方法注入和属性注入 </p>
</blockquote>
<p>对于这种情况，我们也可以使用 <code>OCMock</code> 框架使得 A 对 B 进行隔离依赖，但这里需要注意两种情况：</p>
<ol>
<li><p>B 对象是采用 init 方法进行创建，需要通过 mock alloc 方法，保证 init 创建对象的结果是 mock 对象，示例代码如下</p>
<pre class="language-objc" data-language="objc"><code class="language-objc">id balanceMock <span class="token operator">=</span> <span class="token function">OCMClassMock</span><span class="token punctuation">(</span>FTBalance<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">OCMStub</span><span class="token punctuation">(</span><span class="token punctuation">[</span>balanceMock alloc<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andReturn</span><span class="token punctuation">(</span>balanceMock<span class="token punctuation">)</span><span class="token punctuation">;</span>
FTBalance <span class="token operator">*</span>balance1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>FTBalance alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/// 我们可以发现两个变量为同一个对象</span>
<span class="token function">XCTAssertEqualObjects</span><span class="token punctuation">(</span>balanceMock<span class="token punctuation">,</span> balance1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p>B 对象是采用 initWithXxx 方法创建，需要同时 mock alloc 方法和其他 initWithXxx 方法，才能保证 init 创建对象的结果是 mock 对象，示例代码如下</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token comment">// 由于 FTBalance 具有 initWithMoney: 初始化方法</span>
id balanceMock <span class="token operator">=</span> <span class="token function">OCMClassMock</span><span class="token punctuation">(</span>FTBalance<span class="token punctuation">.</span>class<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">OCMStub</span><span class="token punctuation">(</span><span class="token punctuation">[</span>balanceMock initWithMoney<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andReturn</span><span class="token punctuation">(</span>balanceMock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">OCMStub</span><span class="token punctuation">(</span><span class="token punctuation">[</span>balanceMock alloc<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andReturn</span><span class="token punctuation">(</span>balanceMock<span class="token punctuation">)</span><span class="token punctuation">;</span>
FTBalance <span class="token operator">*</span>balance2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>FTBalance alloc<span class="token punctuation">]</span> initWithMoney<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">/// 我们可以发现两个变量为同一个对象</span>
<span class="token function">XCTAssertEqualObjects</span><span class="token punctuation">(</span>balanceMock<span class="token punctuation">,</span> balance2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ol>
<p>这里提到了 <code>alloc</code> 例子，OCMock 也可以对 <code>alloc</code>, <code>new</code>, <code>copy</code> 等方法进行 mock。</p>
<h4 id="Mock方法忽略非对象参数"><a href="#Mock方法忽略非对象参数" class="headerlink" title="Mock方法忽略非对象参数"></a>Mock方法忽略非对象参数</h4><p>我们可以使用 <code>ignoringNonObjectArgs()</code> 方法，忽略其方法具体非对象参数，保证所有的传参具有统一的结果，具体代码如下：</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">OCMStub([balanceMock payAmount:0]).ignoringNonObjectArgs().andReturn(NO);</code></pre>

<p>上面的解决方案是针对非对象参数情况，但实际上我们还会遇到其他传参，如对象传参，接下来我们来看下这些情况需要怎么处理。</p>
<h4 id="mock-方法其他参数约束"><a href="#mock-方法其他参数约束" class="headerlink" title="mock 方法其他参数约束"></a>mock 方法其他参数约束</h4><h4 id="行为验证"><a href="#行为验证" class="headerlink" title="行为验证"></a>行为验证</h4><p>OCMVerify 可以验证某个方法的调用情况</p>
<ul>
<li><code>OCMVerify([mock someMethod])</code>: 验证 someMethod 方法是否被调用过</li>
<li><code>OCMVerify(times(n), [mock doStuff])</code>: 验证 doStuff 方法是否被调用过 n 次</li>
<li><code>OCMVerify(never(), [mock doStuff])</code>: 验证 doStuff 方法是否从没有调用过，其实这里 <code>never()</code> 相当于 <code>times(0)</code></li>
<li><code>OCMVerify(atLeast(n), [mock doStuff])</code>: 验证 doStuff 方法是否最少被调用过 n 次</li>
<li><code>OCMVerify(atMost(n), [mock doStuff])</code>: 验证 doStuff 方法是否最多被调用过 n 次</li>
<li><code>OCMVerifyAllWithDelay(balanceMock, 1)</code>: 延迟行为验证，数值 <code>1</code> （表示为 NSTimeInterval）是模拟将等待的最大值。它通常会在满足预期后立即返回</li>
</ul>
<h4 id="mock-方法的-block-参数"><a href="#mock-方法的-block-参数" class="headerlink" title="mock 方法的 block 参数"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCMock?id=mock-%E6%96%B9%E6%B3%95%E7%9A%84-block-%E5%8F%82%E6%95%B0">mock 方法的 block 参数</a></h4><p>通过 <code>andReturn()</code> 函数可以 mock 一个方法的返回值，但存在一个场景，方法执行的结果最终会调用某个 block，这个场景在异步/网络中经常出现。</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token comment">/// invokeBlockWithArgs: 方法第一个参数为 @"First arg"。第二个参数为 [NSNull null]，表示对象值为 nil。第三个参数 nil 代表后面没有更多参数</span>
<span class="token comment">/// 特别注意：这里有 [OCMArg invokeBlockWithArgs:...] 会被一个括号括起来！！！</span>
<span class="token function">OCMStub</span><span class="token punctuation">(</span><span class="token punctuation">[</span>mock someMethodWithBlock<span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token punctuation">[</span>OCMArg invokeBlockWithArgs<span class="token punctuation">:</span><span class="token string">@"First arg"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>NSNull null<span class="token punctuation">]</span><span class="token punctuation">,</span> nil<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/// 生产代码</span>
<span class="token comment">/// 当生产代码执行到此方法，且该方法已 mock，block 可立刻同步执行，并响应 @"First arg" 和 nil 这两个传参</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> someMethodWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span>string<span class="token punctuation">,</span> NSObject <span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/// 此时 string 值为 @"First arg"，obj 值为 nil</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>



<h3 id="OCHamcrest"><a href="#OCHamcrest" class="headerlink" title="OCHamcrest"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/basis_info?id=ochamcrest">OCHamcrest</a></h3><p>OCHamcrest 简单理解是一个测试断言库，提供了大量匹配断言语句，大大丰富了断言的类型，方便我们编写富有表现力且灵活的单元测试。其基本内容有：</p>
<ul>
<li>提供方便对象断言的相关断言语句，如<code>conformsTo</code>、<code>equalTo</code>、<code>instanceOf</code>，对于容器、数值、文本、逻辑等还有更多丰富的断言语句</li>
</ul>
<p><a href="http://hamcrest.org/OCHamcrest/"> OCHamcrest官方文档</a></p>
<p>OCHamcrest 主要提供了以下内容：</p>
<ul>
<li>匹配器仓库，拥有丰富的预定义匹配器（如 <code>equalTo</code>、<code>closeTo</code> 等），可用于声明规则以检查给定对象是否匹配</li>
<li>支持自定义匹配器（如可自定一个父类匹配器，<code>isSuperClassOf:</code>）</li>
</ul>
<p>OCHamcrest 的函数实际上是用“HC”包前缀（例如<code>HC_assertThat</code>和<code>HC_equalTo</code>）声明的，以避免名称冲突。但为了使编写速度更快、代码更清晰，默认情况下提供了可选的简短语法。例如，不用写<code>HC_assertThat</code>，只需写<code>assertThat</code>。</p>
<blockquote>
<p>若需要关闭简写模式，只需要声明<code>HC_DISABLE_SHORT_SYNTAX</code>宏即可</p>
</blockquote>
<h4 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object - 对象"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCHamcrest?id=object-%E5%AF%B9%E8%B1%A1">Object - 对象</a></h4><p>OCHamcrest 框架针对对象类型提供了以下匹配器：</p>
<ul>
<li>conformsTo - 该对象是否遵循了给出的协议</li>
<li>equalTo - 该对象是否与参数对象相同</li>
<li>hasDescription - 允许使用文本规则对给出的一段文本与该对象的描述进行匹配</li>
<li>hasProperty - 该对象是否含有给出的属性</li>
<li>instanceOf - 是给出的类的实例，或是给出的类子类的实例</li>
<li>isA - 是给出的类的实例，不同于 IsInstanceOf，无法匹配子类实例</li>
<li>nilValue，notNilValue - 分别匹对空和非空</li>
<li>sameInstance - 与给出的对象是同一个实例</li>
<li>throwsException - 该对象是否捕获到异常</li>
<li>HCArgumentCaptor - 匹配任何，捕获所有值</li>
</ul>
<h4 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String - 字符串"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCHamcrest?id=string-%E5%AD%97%E7%AC%A6%E4%B8%B2">String - 字符串</a></h4><p>OCHamcrest 框架针对字符串类型提供了以下匹配器：</p>
<ul>
<li>containsSubstring - 匹配某个字符串是否包含某子串的规则</li>
<li>endsWith - 匹配某个字符串结尾是否包含某子串</li>
<li>equalToIgnoringCase - 匹配某个字符串，但忽略大小写</li>
<li>equalToIgnoringWhitespace - 匹配某个字符串，但忽略空格</li>
<li>startsWith - 匹配字符串是否已某子为开头</li>
<li>stringContainsInOrder, stringContainsInOrderIn - 匹配文本是否包含一定顺序的若干文本片段</li>
</ul>
<h4 id="Collection-集合"><a href="#Collection-集合" class="headerlink" title="Collection - 集合"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCHamcrest?id=collection-%E9%9B%86%E5%90%88">Collection - 集合</a></h4><p>OCHamcrest 框架针对集合类型提供了以下匹配器：</p>
<ul>
<li>contains, containsIn - 断言包含</li>
<li>containsInAnyOrder, containsInAnyOrderIn - 断言乱序包含（数量必须相同）</li>
<li>containsInRelativeOrder, containsInRelativeOrderIn - 断言包含相对顺序项目的集合</li>
<li>everyItem - 断言每个 item 都满足某个条件</li>
<li>hasCountOf - 断言集合与给定数量的元素</li>
<li>hasEntries - 断言包含多个键值对</li>
<li>hasEntriesIn - 断言字典与字典中的键值对</li>
<li>hasEntry - 断言包含键值对的</li>
<li>hasItem - 断言给定的项目出现在和集合中</li>
<li>hasItems, hasItemsIn - 断言给定的项目以任何顺序出现</li>
<li>hasKey - 断言字典存在某个 key</li>
<li>hasValue - 断言字典存在某个 value</li>
<li>isEmpty - 断言空集合</li>
<li>isIn - 断言对象在给定集合中</li>
<li>onlyContains, onlyContainsIn - 断言集合的项目出现在给定列表中</li>
</ul>
<h4 id="Number-数字"><a href="#Number-数字" class="headerlink" title="Number - 数字"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCHamcrest?id=number-%E6%95%B0%E5%AD%97">Number - 数字</a></h4><p>OCHamcrest 框架针对数字类型提供了以下匹配器：</p>
<ul>
<li>closeTo - 匹配靠近给予的数值</li>
<li>greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - 匹配比较数字大小</li>
<li>isFalse - 匹配错误（0）</li>
<li>isTrue - 匹配正确（非 0）</li>
</ul>
<h4 id="Logical-逻辑"><a href="#Logical-逻辑" class="headerlink" title="Logical - 逻辑"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCHamcrest?id=logical-%E9%80%BB%E8%BE%91">Logical - 逻辑</a></h4><p>OCHamcrest 框架针对逻辑提供了以下匹配器：</p>
<ul>
<li>allOf, allOfIn - 匹配满足所有条件</li>
<li>anyOf, anyOfIn - 匹配满足任意一个</li>
<li>anything - 匹配任何东西（当您不关心特定值时，在复合匹配器中很有用）</li>
<li>isNot - 否定匹配器</li>
</ul>
<h4 id="Decorator-修饰"><a href="#Decorator-修饰" class="headerlink" title="Decorator - 修饰"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCHamcrest?id=decorator-%E4%BF%AE%E9%A5%B0">Decorator - 修饰</a></h4><p>OCHamcrest 框架提供了以下修饰型匹配器：</p>
<ul>
<li>describedAs - 提供匹配器一个自定义的失败描述</li>
<li>is - 促进增强阅读性</li>
</ul>
<h4 id="异步断言"><a href="#异步断言" class="headerlink" title="异步断言"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCHamcrest?id=%E5%BC%82%E6%AD%A5%E6%96%AD%E8%A8%80">异步断言</a></h4><p>开发过程中肯定存在一些异步执行的场景，最常见的就是网络请求，对于此，OCHamcrest 提供了异步断言机制<code>assertWithTimeout</code>，其将会保持验证表达式，直到匹配上或达到超时。</p>
<p>例如，</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token function">assertWithTimeout</span> <span class="token punctuation">(</span> <span class="token number">30</span> <span class="token punctuation">,</span> <span class="token function">thatEventually</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>code<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">is</span><span class="token punctuation">(</span> <span class="token operator">@</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>上述代码表示，在 30s 内将会一直进行匹配判断 self.code 值是否为 200，规定时间内匹配成功，则执行用例成功，否则执行失败。</p>
<h4 id="自定义匹配器"><a href="#自定义匹配器" class="headerlink" title="自定义匹配器"></a><a href="http://cocoa.gitpages.futuoa.com/cocoaunittestdoc/#/learn_framework/OCHamcrest?id=%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%B9%E9%85%8D%E5%99%A8">自定义匹配器</a></h4><p>OCHamcrest 支持自定义匹配器，简单来说只需要继承自 HCBaseMatcher 基类，实现<code>-matches:</code>和<code>-describe_to:</code>方法即可，其中<code>-matches:</code>方法需要实现具体匹配逻辑，<code>-describe_to:</code>方法需要实现描述。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年iOS实习期实践作业</title>
    <url>/2022/09/11/Week1_2%EF%BC%9A%E5%9F%B9%E5%85%BB%E8%AE%A1%E5%88%92%E5%AE%9E%E8%B7%B5%E4%BD%9C%E4%B8%9A1/</url>
    <content><![CDATA[<h2 id="2022年iOS实习期实践作业"><a href="#2022年iOS实习期实践作业" class="headerlink" title="2022年iOS实习期实践作业"></a>2022年iOS实习期实践作业</h2><p>[toc]</p>
<h2 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h2><h3 id="练习实践1-子类重写父类的方法"><a href="#练习实践1-子类重写父类的方法" class="headerlink" title="练习实践1:子类重写父类的方法"></a>练习实践1:子类重写父类的方法</h3><span id="more"></span>

<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>Foundation<span class="token operator">/</span>Foundation<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token comment">//声明类Student</span>
<span class="token keyword">@interface</span> Student <span class="token punctuation">:</span> NSObject  <span class="token comment">//通过@interface关键字来声明类</span>

<span class="token comment">//类所包含的变量</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> copy<span class="token punctuation">)</span> NSString <span class="token operator">*</span>name<span class="token punctuation">;</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> assign<span class="token punctuation">)</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> assign<span class="token punctuation">)</span> <span class="token keyword">double</span> score<span class="token punctuation">;</span>

<span class="token comment">//类所包含的函数</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>display<span class="token punctuation">;</span>

<span class="token keyword">@end</span>  <span class="token comment">//使用@end关键字结束类的声明</span>

<span class="token comment">//实现在类中声明的函数</span>
<span class="token keyword">@implementation</span> Student  <span class="token comment">//通过@implementation关键字来实现类中的函数</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>display <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"%@的年龄是 %d，成绩是 %f"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>age<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span>  <span class="token comment">//使用@end关键字结束类中函数的实现</span>


<span class="token comment">//声明动物类</span>
<span class="token keyword">@interface</span> Animal <span class="token punctuation">:</span> NSObject

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>run<span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>eat<span class="token punctuation">;</span>

<span class="token keyword">@end</span>

<span class="token comment">//为动物类添加方法</span>
<span class="token keyword">@implementation</span> Animal

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>run <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"动物都会移动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>eat<span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"动物都要吃东西"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span>

<span class="token comment">//声明猫和狗</span>
<span class="token keyword">@interface</span> Cat <span class="token punctuation">:</span> Animal

<span class="token keyword">@end</span>

<span class="token keyword">@interface</span> Dog <span class="token punctuation">:</span> Animal

<span class="token keyword">@end</span>

<span class="token comment">//重写父类方法</span>
<span class="token keyword">@implementation</span> Cat

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>run <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"猫跑可以的很快"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>eat <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"猫喜欢吃鱼"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span>

<span class="token keyword">@implementation</span> Dog

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>run <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"狗也跑可以的很快"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>eat <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"狗喜欢吃骨头"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Cat <span class="token operator">*</span>cat <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Cat alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    Dog <span class="token operator">*</span>dog <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Dog alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>cat run<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>cat eat<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>dog run<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">[</span>dog eat<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<h3 id="练习实践2-两数之和"><a href="#练习实践2-两数之和" class="headerlink" title="练习实践2:两数之和"></a>练习实践2:两数之和</h3><pre class="language-none"><code class="language-none">1. 两数之和
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]</code></pre>





<p>C++ 解法：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        int len = nums.size();
        unordered_map&lt;int, int&gt; map;

        for(int i = 0; i &lt; len; i++) {
            auto iterator = map.find(target - nums[i]);
            if(iterator != map.end()) return {iterator-&gt;second, i};
            map[nums[i]] = i;
        }
        return {};
    }
};</code></pre>



<p>Objective-C解法：</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSMutableArray *inputArray = [NSMutableArray arrayWithCapacity:0];
        int target;
        int len;
        
        NSLog(@"请输入数组长度");
        scanf("%d", &amp;len);
        NSLog(@"请输入数组");
        
        for(int i = 0; i &lt; len; i++) {
            int tmp;
            scanf("%d", &amp;tmp);
            [inputArray addObject:@(tmp)];
        }
        
        NSLog(@"请输入两数之和");
        scanf("%d", &amp;target);
        
        NSMutableDictionary *valueToIndexDict = [NSMutableDictionary dictionary];

        NSInteger tmpValue;
        NSNumber *findIndex;
        
        for(int i = 0; i &lt; len; i++) {
            tmpValue = [inputArray[i] integerValue];
            findIndex = @(target - tmpValue);
            
            if(valueToIndexDict[findIndex] != nil) {
                NSLog(@"%@ %d", valueToIndexDict[findIndex], i);
            }
            [valueToIndexDict setValue:@(i) forKey:(inputArray[i])];
        }
    }
    return 0;
}</code></pre>



<h3 id="练习实践3-重写类的-init-函数"><a href="#练习实践3-重写类的-init-函数" class="headerlink" title="练习实践3:重写类的 init 函数"></a>练习实践3:重写类的 init 函数</h3><p>注意命名规范，重写的 init 函数要以 init 开头</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">#import &lt;Foundation/Foundation.h&gt;

//声明动物类
@interface Animal : NSObject

@property (nonatomic, assign) int height;
@property (nonatomic, assign) int weight;
@property (nonatomic, assign) int age;
@property (nonatomic, copy) NSString *name;

- (void)run;

- (void)eat;

- (id)initWithHeight:(int)height weight:(int)weight age:(int)age name:(NSString *)name;

@end

//为动物类添加方法
@implementation Animal

- (void)run {
    NSLog(@"动物都会移动");
}

- (void)eat{
    NSLog(@"动物都要吃东西");
}

- (void)printAnimalData {
    NSLog(@"它的各项数据是：身高：%d 体重：%d 年龄：%d 名称：%@",self.height, self.weight, self.age, self.name);
}

- (id)initWithHeight:(int)height weight:(int)weight age:(int)age name:(NSString *)name{
    if(self = [super init]) {
        self.height = height;
        self.weight = weight;
        self.age = age;
        self.name = name;
    }
    return self;
}

@end

//声明猫和狗
@interface Cat : Animal

@end

@interface Dog : Animal

@end

//重写父类方法
@implementation Cat

- (void)run {
    NSLog(@"猫跑可以的很快");
}

- (void)eat {
    NSLog(@"猫喜欢吃鱼");
}

@end

@implementation Dog

- (void)run {
    NSLog(@"狗也跑可以的很快");
}

- (void)eat {
    NSLog(@"狗喜欢吃骨头");
}

@end

int main() {
    Cat *cat = [[Cat alloc] initWithHeight:11 weight:33 age:44 name:@"bey"];
    Dog *dog = [[Dog alloc] initWithHeight:2 weight:49 age:488 name:@"huang"];
    [cat printAnimalData];
    [cat run];
    [cat eat];
    [dog printAnimalData];
    [dog run];
    [dog eat];
    return 0;
}</code></pre>

]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>从C++到OC，快速掌握 OC语法</title>
    <url>/2022/07/03/Week1_1%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%86%9F%E6%82%89%20Object-C%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="从C-到OC，快速掌握-OC语法"><a href="#从C-到OC，快速掌握-OC语法" class="headerlink" title="从C++到OC，快速掌握 OC语法"></a>从C++到OC，快速掌握 OC语法</h2><p>[toc]</p>
<h3 id="学习Objective-C-的笔记，有-C-C-基础的同学阅读文章此可以快速掌握-OC。"><a href="#学习Objective-C-的笔记，有-C-C-基础的同学阅读文章此可以快速掌握-OC。" class="headerlink" title="学习Objective-C 的笔记，有 C/C++ 基础的同学阅读文章此可以快速掌握 OC。"></a>学习Objective-C 的笔记，有 C/C++ 基础的同学阅读文章此可以快速掌握 OC。</h3><h3 id="Xcode-快捷键"><a href="#Xcode-快捷键" class="headerlink" title="Xcode 快捷键"></a>Xcode 快捷键</h3><p>格式化代码：Command + A 全选（选中需要格式的代码段） 再 Ctrl + i 格式化代码</p>
<h3 id="C-和-OC-的区别"><a href="#C-和-OC-的区别" class="headerlink" title="C 和 OC 的区别"></a>C 和 OC 的区别</h3><p>由于 OC 的底层是 C 语言，所以 OC 和 C 完全兼容，在编程过程中，OC 和 C 可以混合使用。</p>
<p>分析一下一段最基本的 OC 代码：</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">#import &lt;Foundation/Foundation.h&gt;

int main() {
    NSLog(@"Hello, World!");
    return 0;
}</code></pre>

<span id="more"></span>

<ul>
<li><p>在 OC 中， <code>#import</code> 命令用来引入头文件。与 C 语言中的 <code>#include</code> 相比，<code>#import</code>  能够保证头文件只被引入一次，也就是说，只有第一次引入有效，后续对同一文件的引入都会被忽略。而在 C 语言中，每次使用 #include 命令都会将头文件的内容引入一次，所以在头文件中必须使用 <code>#ifndef</code> 和 <code>#endif</code> 宏来保证头文件只被编译一次</p>
</li>
<li><p><code>Foundation/Foundation.h</code> 是 Foundation 框架的头文件，只要引入了它，就可以使用 Foundation 框架的功能。</p>
<p>Foundation 是 OC 语言的基础框架，它提供了 OC 专有的基本数据类型（如字符串、数组、时间日期等），提供了多线程、网络连接、文件操作、本地数据存储等常用功能。Foundation.h 就像 C 语言中的 stdio.h，一般都需要引入</p>
</li>
<li><p> NSLog() 是 OC 中的格式化输出函数，相当于 C 语言中的 printf() 的升级版，不仅可以用来输出 C 语言中的数据，还可以输出 OC 中的数据。</p>
</li>
</ul>
  <pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>Foundation<span class="token operator">/</span>Foundation<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello, c"</span><span class="token punctuation">;</span>
    NSString <span class="token operator">*</span>NSstr <span class="token operator">=</span> <span class="token string">@"hello,object-c"</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"\n a: %d\n b: %f\n str: %s\n OC str: %@"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> str<span class="token punctuation">,</span> NSstr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<ul>
<li><code>@ </code>符号没有实际含义，只是用来作为 OC 字符串的特有标志。在 OC 中，字符串前面都要加 <code>@</code>，如果不加，就变成了 C 语言中的字符串，就要使用字符指针或字符数组来定义</li>
</ul>
<h3 id="OC-中的数据类型和数据结构"><a href="#OC-中的数据类型和数据结构" class="headerlink" title="OC 中的数据类型和数据结构"></a>OC 中的数据类型和数据结构</h3><p>因为 OC 是完全兼容 C 的，所以 C 中的数据类型都可以在 OC 中使用。</p>
<p><strong>先来看看 C 中有什么数据类型</strong></p>
<ul>
<li>C 语言数据类型<ul>
<li>基本类型<ul>
<li>数值（int、long、float、double）</li>
<li>字符串（char）</li>
</ul>
</li>
<li>构造类型<ul>
<li>数组</li>
<li>结构体（struct）</li>
<li>共用体（union）</li>
<li>枚举（enum）</li>
</ul>
</li>
<li>指针类型</li>
<li>空类型void</li>
</ul>
</li>
</ul>
<p>很明显 C 中的数据类型有些少，当我们需要用到哈希表这样的数据结构的时候，就需要我们自己手写一个，OC 明显考虑到这个麻烦，所以添加了很多便于使用的数据结构。</p>
<p>比如有 <code>NSObject、NSString(NSMutableString)、NSArray(NSMutableArray)、NSDictionary(NSMutableDictionary)、NSSet(NSMutableSet)、NSAttributedString(NSMutableAttributedString)</code> 这些数据结构，使开发效率能够提高。</p>
<p>这些数据结构是由 Cocoa Foundation 框架提供的集合类，这些集合类中只可以放入对象，不能放入基本类型的数据。所以 Cocoa 提供了包裹类</p>
<ul>
<li>NSNumber 类来包装 int、long、char 等基本数据类型，使其可以放入集合类中。</li>
<li>NSValue 可以将结构体、枚举、指针这些复杂的数据类型转换为对象放入集合类中。</li>
<li>NSNull 可以将 nil 包裹之后放入集合类中。</li>
</ul>
<p><strong>提取包裹类中的值</strong></p>
<p>使用下列的方法可以提取出 NSNumber 实例中的 NSInteger 的值</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">-（NSInteger） integerValue</code></pre>

<p>需要注意的是：NSInteger 不是一个对象，而是基本数据类型的 typedef</p>
<h3 id="OC-中的属性声明"><a href="#OC-中的属性声明" class="headerlink" title="OC 中的属性声明"></a>OC 中的属性声明</h3><p>一般来说，属性是指一个对象的属性或者特性（也就是变量和方法）</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3jde77qqfj22730u043r.jpg" style="zoom: 25%;">

<p>属性的声明有一些规律：</p>
<ul>
<li><p>自动生成访问方法：</p>
<p>能够为声明的实例变量自动生成访问方法。既可以同时生成 getter 方法和 setter方法，也可以只生成 getter，也可以手动定义访问方法。</p>
</li>
<li><p>自动生成实例变量：</p>
<p>如果不存在同名的实例变量的话，在生成访问方法的同时，也会自动生成同名的实例变量。</p>
</li>
<li><p>更简单的调用访问方法</p>
<p>可以通过 <code>.</code> 操作符来访问调用方法。</p>
</li>
</ul>
<h4 id="property-的几种常用修饰词"><a href="#property-的几种常用修饰词" class="headerlink" title="@property 的几种常用修饰词"></a>@property 的几种常用修饰词</h4><p><strong>nonatomic 和 atomic</strong></p>
<p>nonatomic：非原子性，涉及到多线程的相关知识。访问方法被 nonatomic 修饰的情况下，意味着它执行过程中可以被打断，如果多个线程同时调用 getter 或者 setter 方法，那么就会出现值丢失或内存泄漏等错误</p>
<p>atomic (默认)：原子性。和 nonatomic 正好相反，它对属性的访问进行了限制，保护了声明属性的安全，缺点就是：访问效率低，速度慢。</p>
<p><strong>assign、copy、retain、unsafe_unretained、strong、weak</strong></p>
<p>assign：单纯赋值，可用于基础数据类型和对象类型</p>
<p>copy：复制对象，使用对象的副本进行赋值</p>
<p>retain：进行保持操作</p>
<p>release：进行释放操作</p>
<p>unsafe_unretained：同 assign 一样</p>
<p>strong：强引用，同 retain 一样，用于 ARC</p>
<p>weak：弱引用，用于 ARC</p>
<p><strong>readonly和readwrite</strong></p>
<p>readwrite（默认）：它代表这个属性即可以读，也可以写(可以调用它的 get 和 set 方法)</p>
<p>readonly：和 readwrite 不同，它代表这个属性只能读，不能进行写操作(只能调用 get 方法，不能调用 set 方法)</p>
<h4 id="赋值时的选项"><a href="#赋值时的选项" class="headerlink" title="赋值时的选项"></a>赋值时的选项</h4><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3jgnrb3u0j229q0u012u.jpg"></p>
<h3 id="OC-中类和对象"><a href="#OC-中类和对象" class="headerlink" title="OC 中类和对象"></a>OC 中类和对象</h3><p>OC 中的类和 C 中的结构体功能类似，但是 C 只能在结构体里面定义不同类型的变量，而 OC 可以在类里面定义变量和方法，和 C++ 里面的类相似。</p>
<p>首先来看一下 C 中的结构体</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">float</span> score<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Student</span> stu<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s的年龄是:%d，成绩是:%f\n"</span><span class="token punctuation">,</span> stu<span class="token punctuation">.</span>name<span class="token punctuation">,</span> stu<span class="token punctuation">.</span>age<span class="token punctuation">,</span> stu<span class="token punctuation">.</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">Student</span> stu<span class="token punctuation">;</span>
    stu<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"beyhuang"</span><span class="token punctuation">;</span>
    stu<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
    stu<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">88</span><span class="token punctuation">;</span>
    <span class="token function">display</span><span class="token punctuation">(</span>stu<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>再来看看 OC 中的类</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">#import &lt;Foundation/Foundation.h&gt;

//声明类Student
@interface Student : NSObject  //通过@interface关键字来声明类
//类所包含的变量
@property NSString *name;
@property int age;
@property double score;
//类所包含的函数
-(void)display;
@end  //使用@end关键字结束类的声明

//实现在类中声明的函数
@implementation Student  //通过@implementation关键字来实现类中的函数
-(void)display{
    NSLog(@"%@的年龄是 %d，成绩是 %f", self.name, self.age, self.score);
}
@end  //使用@end关键字结束类中函数的实现

int main(int argc, const char * argv[]) {
    //通过类来定义变量stu1，即创建对象stu1
    Student *stu1 = [[Student alloc] init];  //alloc函数为对象分配内存空间，init函数会初始化对象
    //操作类的成员
    stu1.name = @"beyhuang";
    stu1.age = 18;
    stu1.score = 66.66666;
    //调用类的函数
    [stu1 display];

    return 0;
}
</code></pre>

<ul>
<li><p>OC 使用 <code>@interface</code> 来声明一个类；<code>Student  </code> 是类的名称；<code>student</code>  后面的 <code>NSObject </code> 表示当前类派生自 <code>NSObject</code> 类</p>
</li>
<li><p>在 OC 中，类所包含的变量和函数都有特定的称呼，变量被称为属性（Property），函数被称为方法（Method），属性和方法统称为类的成员（Member）。从上面的代码可以看出，声明类的属性要使用 <code>@property</code> 关键字，而声明类的方法不需要使用任何关键字。</p>
</li>
<li><p><code>-</code>  号和<code>+</code> 号代表的意思：</p>
<ul>
<li><p>减号表示</p>
<p>为实例方法，必须使用类的实例才可以调用的。</p>
<p>比如C语言中，一个方法的写法可能是：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span>bool ishello<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></li>
<li><p>用Objective-C写出来就是</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> hello<span class="token punctuation">:</span><span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>ishello
<span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre></li>
<li><p>加号表示类方法，这类方法是可以直接用类名来调用的，就是其他函数可以直接调用这个类中的这个函数，而不用创建这个类的实例。</p>
</li>
</ul>
</li>
<li><p>消息表达式</p>
<ul>
<li><pre><code>// [obj msg];
[stu1 display];
</code></pre>
</li>
<li><p>上面就是消息表达式的语法，其中消息接受者 obj 是一个对象，消息 msg 告诉它要去做什么</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote03：JSX本质及源码解析</title>
    <url>/2022/01/17/ReactNote03:%20JSX%E6%9C%AC%E8%B4%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="JSX-的本质"><a href="#JSX-的本质" class="headerlink" title="JSX 的本质"></a>JSX 的本质</h3><p>实际上，jsx 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。所有的 jsx 语法都会被转换为 React.createElement 语法的调用。</p>
<span id="more"></span>

<p>先来看一下几行 jsx 代码：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>nihao<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>you are the best<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>那么它们转换成 js 代码会是什么样的呢？</p>
<pre class="language-js" data-language="js"><code class="language-js">React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"nihao"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"h2"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"you are the best"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"ul"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>好家伙，直接一个嵌套地狱，要是代码再多一点的话能把人看哭。还是 jsx 香</p>
<blockquote>
<p> 查看 React.createElement 的源码</p>
<p>源码位置：packages/react/src/ReactElement.js</p>
</blockquote>
<pre class="language-react" data-language="react"><code class="language-react">/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
export function createElement(type, config, children) {
  let propName;

  // Reserved names are extracted
  const props = {};

  let key = null;
  let ref = null;
  let self = null;
  let source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      if (__DEV__) {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (
        hasOwnProperty.call(config, propName) &amp;&amp;
        !RESERVED_PROPS.hasOwnProperty(propName)
      ) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  const childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength &gt; 1) {
    const childArray = Array(childrenLength);
    for (let i = 0; i &lt; childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (__DEV__) {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type &amp;&amp; type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (__DEV__) {
    if (key || ref) {
      const displayName =
        typeof type === 'function'
          ? type.displayName || type.name || 'Unknown'
          : type;
      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }
      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}
</code></pre>

<p>createElement的三个参数：</p>
<ul>
<li><ol>
<li>type</li>
</ol>
<ul>
<li>是当前 React 的类型，如果是标签元素，则用字符串表示，例如 “div”。如果是组件元素，则直接用组件名称</li>
</ul>
</li>
<li><ol start="2">
<li>config</li>
</ol>
<ul>
<li>所有 jsx 中的属性都在 config 中以对象的键值对存储</li>
</ul>
</li>
<li><ol start="3">
<li>存放标签中的内容，以数组的方式存储</li>
</ol>
<ul>
<li> 为什么是以数组的形式存储呢？</li>
<li>因为 jsx 里面可以会传入很多的同级标签，createElement 并不是只能传入三个参数。为什么可以传入多个参数呢？这就要回到源码里面一探究竟了，毕竟源码之下，了无秘密。</li>
</ul>
</li>
</ul>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> childrenLength <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childrenLength <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    props<span class="token punctuation">.</span>children <span class="token operator">=</span> children<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childrenLength <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> childArray <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>childrenLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> childrenLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      childArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>freeze<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>childArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    props<span class="token punctuation">.</span>children <span class="token operator">=</span> childArray<span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>

<p>这里就是上面 createElement 源码的一部分，也就是说 children 是一个数组，里面存储着第三个参数及以后的所有参数。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>OC 中的 block</title>
    <url>/2022/07/28/Week2_3%EF%BC%9A%E6%8E%A2%E7%A9%B6OC%E4%B8%AD%E7%9A%84block/</url>
    <content><![CDATA[<h1 id="OC-中的-block"><a href="#OC-中的-block" class="headerlink" title="OC 中的 block"></a>OC 中的 block</h1><p>[toc]</p>
<p>块对象（block）不是 OC 的特性而是 C 语言的实现，用一句话来概括 block：带有自动变量（局部变量）的匿名函数，在其他编程语言中，它与闭包（closure）的功能相同。</p>
<h3 id="代码块的定义："><a href="#代码块的定义：" class="headerlink" title="代码块的定义："></a>代码块的定义：</h3><pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>使用 typedef 关键字简化 block 的定义</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token comment">//定义</span>
<span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">^</span>myBlock<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//使用</span>
myBlock fun1 <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>

<p>代码块的几种使用形式</p>
<span id="more"></span>

<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token comment">// 无参数无返回值</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>BlockOne<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"无参数，无返回值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
<span class="token function">BlockOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//block的调用</span>

<span class="token comment">// 有参数无返回值</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>BlockTwo<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"有参数，无返回值, 参数 = %d，"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
<span class="token function">BlockTwo</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 有参数有返回值</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">^</span>BlockThree<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"有参数，有返回值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>  
<span class="token function">BlockThree</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 无参数有返回值</span>
<span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">^</span>BlockFour<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"无参数，有返回值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">BlockFour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>



<p>代码块的几种使用方式</p>
<ol>
<li>可以像函数一样使用</li>
</ol>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">^</span>square_block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">(</span><span class="token keyword">int</span> number<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>number <span class="token operator">*</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">square_block</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<ol start="2">
<li>作为参数传递给函数</li>
</ol>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">void</span> <span class="token function">q_sort</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span> size_t nel<span class="token punctuation">,</span> size_t width<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">^</span><span class="token punctuation">(</span>compare<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>



<h3 id="探究-block-的本质"><a href="#探究-block-的本质" class="headerlink" title="探究 block 的本质"></a>探究 block 的本质</h3><p>看看下面的例子分别打印出什么：</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>Foundation<span class="token operator">/</span>Foundation<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token keyword">void</span> <span class="token function">blockFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"num equal %d"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">blockFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    __block <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"num equal %d"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">blockFunc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"num equal %d"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">blockFunc4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">^</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">^</span><span class="token punctuation">{</span>
        <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"num equal %d"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token function">block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">blockFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">blockFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">blockFunc3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">blockFunc4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>将自己的答案和打印出来的值对比一下，然后带着疑问继续下去</p>
<p>将 main.m 文件在命令行打开，然后执行以下语句</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</code></pre>

<p>就会看到  main.m 文件所在目录有一个 C++ 的文件出现，打开，然后拖到最底下</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3rg35qtirj215l0u00yk.jpg"></p>
<p>可以看到 blockFunc1 的 C 语言实现</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">void</span> <span class="token function">blockFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token function">__blockFunc1_block_impl_0</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>__blockFunc1_block_func_0<span class="token punctuation">,</span> <span class="token operator">&amp;</span>__blockFunc1_block_desc_0_DATA<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span>block<span class="token punctuation">)</span><span class="token operator">-&gt;</span>FuncPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>去掉类型转换可以看到</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">void</span> <span class="token function">blockFunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token function">__blockFunc1_block_impl_0</span><span class="token punctuation">(</span>__blockFunc1_block_func_0<span class="token punctuation">,</span> <span class="token operator">&amp;</span>__blockFunc1_block_desc_0_DATA<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span>block<span class="token punctuation">)</span><span class="token operator">-&gt;</span>FuncPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>这里可以看到 block 其实就是一个指向结构体的指针</p>
<p>该结构体为：</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">struct</span> __blockFunc1_block_impl_0 <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> __block_impl impl<span class="token punctuation">;</span>
  <span class="token keyword">struct</span> __blockFunc1_block_desc_0<span class="token operator">*</span> Desc<span class="token punctuation">;</span>
  <span class="token keyword">int</span> num<span class="token punctuation">;</span>
  <span class="token function">__blockFunc1_block_impl_0</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>fp<span class="token punctuation">,</span> <span class="token keyword">struct</span> __blockFunc1_block_desc_0 <span class="token operator">*</span>desc<span class="token punctuation">,</span> <span class="token keyword">int</span> _num<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">num</span><span class="token punctuation">(</span>_num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    impl<span class="token punctuation">.</span>isa <span class="token operator">=</span> <span class="token operator">&amp;</span>_NSConcreteStackBlock<span class="token punctuation">;</span>
    impl<span class="token punctuation">.</span>Flags <span class="token operator">=</span> flags<span class="token punctuation">;</span>
    impl<span class="token punctuation">.</span>FuncPtr <span class="token operator">=</span> fp<span class="token punctuation">;</span>
    Desc <span class="token operator">=</span> desc<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>



<p>再看一下 blockFunc2 的 C 语言实现</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">void</span> <span class="token function">blockFunc2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">__blocks__</span><span class="token punctuation">(</span>byref<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> __Block_byref_num_0 num <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">(</span>__Block_byref_num_0 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>num<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>__Block_byref_num_0<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>block<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token function">__blockFunc2_block_impl_0</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>__blockFunc2_block_func_0<span class="token punctuation">,</span> <span class="token operator">&amp;</span>__blockFunc2_block_desc_0_DATA<span class="token punctuation">,</span> <span class="token punctuation">(</span>__Block_byref_num_0 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>num<span class="token punctuation">,</span> <span class="token number">570425344</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span>num<span class="token punctuation">.</span>__forwarding<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span>block<span class="token punctuation">)</span><span class="token operator">-&gt;</span>FuncPtr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>__block_impl <span class="token operator">*</span><span class="token punctuation">)</span>block<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>发现 block 指向的结构体传入的是存储 num 的地址，所以 num 的值改变，传入函数的值也随之改变</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>OC中的类别、扩展和协议</title>
    <url>/2022/07/26/Week2_2%EF%BC%9AOC%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%88%AB%E3%80%81%E6%89%A9%E5%B1%95%E5%92%8C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="类别、扩展和协议"><a href="#类别、扩展和协议" class="headerlink" title="类别、扩展和协议"></a>类别、扩展和协议</h1><p>[toc]</p>
<h2 id="OC-中的类别（Category）"><a href="#OC-中的类别（Category）" class="headerlink" title="OC 中的类别（Category）"></a>OC 中的类别（Category）</h2><h3 id="类别的定义"><a href="#类别的定义" class="headerlink" title="类别的定义"></a>类别的定义</h3><p>实现某个类的一部分方法的模块叫做类别。类别可以将有很多方法的超大型的类，分散到不同的模块之中。类别本是 smalltalk 中的概念，用于将多个方法按照相互关系、用途等特征分类，以便最快速的找到自己想要的方法。</p>
<p>调用类别中的方法和调用普通类中的方法是一样的，类别和类一样，都是在接口文件中声明，在类文件中实现，但类别中不能声明实例变量，只能声明方法，声明的方法可以是类方法也可以是实例方法。</p>
<p>类别的声明</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">@interface</span> 类名（类别名）
方法的声明；
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">@end</span></code></pre>

<p>类别的定义</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token operator">@</span>implemention 类名（类别名）
方法的定义；
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">@end</span></code></pre>

<span id="more"></span>

<p>Xcode 中为一个类添加类别的过程：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3p75z04xuj213s0siq5c.jpg" style="zoom:33%;">



<p>File 填上类别名</p>
<p>File Type 选择 Category</p>
<p>Class 选择要添加类别的父类</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3p76n8u26j21400smjt2.jpg" style="zoom:33%;">



<p>类别的注意事项：</p>
<p>1、只要保证类别名称唯一，我们可以向一个类中添加任意数量的类别；</p>
<p>2、类别中可以添加方法，但不能直接添加变量；</p>
<p>3、类别可以利用运行时功能为已经存在的实例对象增加实例变量；</p>
<h3 id="类别中添加属性的方法："><a href="#类别中添加属性的方法：" class="headerlink" title="类别中添加属性的方法："></a>类别中添加属性的方法：</h3><p>在类别中添加属性时，只会生成 set 和 get 方法的声明，没有生成 set 和 get 方法的实现。所以如果在类别中添加了属性，直接调用属性的 set 或者 get 是会发生崩溃的。如果有需要在类别中添加属性，可以利用 OC 的 runtime 的特性实现。</p>
<p><code>Dog + LikeDoing.h</code> 文件</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>Foundation<span class="token operator">/</span>Foundation<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">"Dog.h"</span></span>

<span class="token keyword">@interface</span> <span class="token function">Dog</span> <span class="token punctuation">(</span>LikeDoing<span class="token punctuation">)</span>

<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> copy<span class="token punctuation">)</span> NSString <span class="token operator">*</span>hobby<span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> printHobby<span class="token punctuation">;</span>

<span class="token keyword">@end</span></code></pre>

<p><code>Dog + LikeDoing.m</code> 文件</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">"Dog+LikeDoing.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>objc<span class="token operator">/</span>message<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>

<span class="token keyword">@implementation</span> <span class="token function">Dog</span> <span class="token punctuation">(</span>LikeDoing<span class="token punctuation">)</span>

<span class="token keyword">static</span> <span class="token keyword">char</span> <span class="token operator">*</span>hobbyKey <span class="token operator">=</span> <span class="token string">"hobbyKey"</span><span class="token punctuation">;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>setHobby<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>hobby <span class="token punctuation">{</span>
    <span class="token function">objc_setAssociatedObject</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> hobbyKey<span class="token punctuation">,</span> hobby<span class="token punctuation">,</span> OBJC_ASSOCIATION_COPY_NONATOMIC<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span>hobby <span class="token punctuation">{</span>
    <span class="token keyword">return</span>  <span class="token function">objc_getAssociatedObject</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">,</span> hobbyKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> printHobby <span class="token punctuation">{</span>
 
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"%@"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>hobby<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span></code></pre>



<h2 id="OC-中的扩展（Extension）"><a href="#OC-中的扩展（Extension）" class="headerlink" title="OC 中的扩展（Extension）"></a>OC 中的扩展（Extension）</h2><h3 id="类扩展的声明"><a href="#类扩展的声明" class="headerlink" title="类扩展的声明"></a>类扩展的声明</h3><p>类别只能增加方法，不能直接添加实例变量，但使用类扩展（Class Extension）可以做到。</p>
<p>类扩展也叫匿名类别，不需要指定类别名字。</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token comment">//add extension</span>
<span class="token keyword">@interface</span> <span class="token function">Cat</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> assign<span class="token punctuation">)</span> <span class="token keyword">int</span> prices<span class="token punctuation">;</span>

<span class="token comment">//对外不可见</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> extensionPrintPrices<span class="token punctuation">;</span>

<span class="token keyword">@end</span></code></pre>



<h3 id="类扩展的实现"><a href="#类扩展的实现" class="headerlink" title="类扩展的实现"></a>类扩展的实现</h3><p>一般类扩展都是写在.m文件中，不单独建立一个扩展文件，如下：</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>Foundation<span class="token operator">/</span>Foundation<span class="token punctuation">.</span>h<span class="token operator">&gt;</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">"Cat.h"</span></span>

<span class="token comment">//add extension</span>
<span class="token keyword">@interface</span> <span class="token function">Cat</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">@property</span> <span class="token punctuation">(</span>nonatomic<span class="token punctuation">,</span> assign<span class="token punctuation">)</span> <span class="token keyword">int</span> prices<span class="token punctuation">;</span>

<span class="token comment">//对外不可见</span>
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> extensionPrintPrices<span class="token punctuation">;</span>

<span class="token keyword">@end</span>


<span class="token keyword">@implementation</span> Cat

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>printPrice <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token keyword">self</span> extensionPrintPrices<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>extensionPrintPrices <span class="token punctuation">{</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>prices <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"%d"</span><span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>prices<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span>
</code></pre>

<p>单独生成一个类扩展文件也可以，但必须将类扩展的.h文件包含进本类的.m文件中。</p>
<p>类扩展的缺陷</p>
<p>1、类扩展中添加的属性、成员变量和方法都属于私有属性和方法（只能被在本类的 .m 文件调用，并且这些属性和方法不能被子类继承）；</p>
<p>2、一般类扩展都是写在 .m 文件中，不单独建立一个扩展文件，且必须把类扩展的 @interface 写在本类的 @implementation 的上方，否则编译器会报错； </p>
<p>3、类扩展只能针对自定义的类，不能给系统类增加类扩展；</p>
<p>4、类扩展定义的方法必须在类的实现中进行实现（因为单独定义类扩展的话编译器只会生成一个.h文件，类扩展只能在需要扩展的类.m文件里面去进行扩展）；</p>
<p>5、类扩展中声明的方法可以不实现，但编译器会警告（因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中）；</p>
<p>6、单独定义类扩展的文件并且只定义属性，也需要在类实现文件中包含进类扩展文件，否则会找不到属性的setter / getter方法。</p>
<h2 id="OC-中的协议（Protocol）"><a href="#OC-中的协议（Protocol）" class="headerlink" title="OC 中的协议（Protocol）"></a>OC 中的协议（Protocol）</h2><h3 id="正式协议"><a href="#正式协议" class="headerlink" title="正式协议"></a>正式协议</h3><p>OC 中的协议是声明方法的集合体，实现由各个类自行完成，所以实现协议的各个类之间是否有继承关系无关紧要，重要的是这些类如何实现这些协议。</p>
<p>在使用协议的情况下，如果类实现了协议的方法，那么就说类遵循该协议，而该类的子类也因为继承关系拥有这些协议的方法。当类适用于某个协议时，它的实例也适用于这个协议。</p>
<p>下面来看看 protocol 怎么用：</p>
<p><code>Animal.h</code></p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">@protocol</span> AnimalDelegate <span class="token operator">&lt;</span>NSObject<span class="token operator">&gt;</span><span class="token comment">//协议声明</span>

<span class="token operator">@</span>required
<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>safeForPeople<span class="token punctuation">;</span>

<span class="token operator">@</span>optional
……

<span class="token keyword">@end</span>


<span class="token keyword">@interface</span> Animal <span class="token punctuation">:</span> NSObject

<span class="token keyword">@end</span></code></pre>



<p><code>Cat.h</code></p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token string">"Animal.h"</span></span>

<span class="token keyword">@interface</span> Cat <span class="token punctuation">:</span> Animal<span class="token operator">&lt;</span>AnimalDelegate<span class="token operator">&gt;</span>

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> printPrice<span class="token punctuation">;</span>

<span class="token keyword">@end</span></code></pre>



<p><code>Cat.m</code></p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">@implementation</span> Cat

<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>safeForPeople<span class="token punctuation">{</span>
    <span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"Cat can't harm people"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">@end</span></code></pre>



<p><code>main.m</code></p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Cat <span class="token operator">*</span>cat <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>Cat alloc<span class="token punctuation">]</span> initWeight<span class="token punctuation">:</span><span class="token number">11</span> andHeight<span class="token punctuation">:</span><span class="token number">33</span> andAge<span class="token punctuation">:</span><span class="token number">44</span> andName<span class="token punctuation">:</span><span class="token string">@"bey"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">//protocol</span>
  	<span class="token punctuation">[</span>cat safeForPeople<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>一个类可以遵循一个或多个协议，任何类只要遵循了协议就相当于拥有了这个协议中所有的方法声明。Protocol 可以定义在一个类的头文件上部，并直接应用在该类中。</p>
<p>@protocol 是定义一个协议的注解，其中，@required 表示这个方法必须被实现，@optional 表示这个方法不一定要被实现。<br>AnimalProtocol 是协议的名字，规范命名为：类名 + Delegate。</p>
<p><strong>协议与继承的区别</strong>：</p>
<ul>
<li>子类继承父类之后默认就有父类方法的实现，而遵循一个协议只有方法的声明而没有方法的实现；</li>
<li>相同类型的类可以使用继承，但是不同类型的类遵循同一个协议更方便；</li>
<li>协议可以将多个类中共有的方法抽取出来，让这些类遵守协议</li>
</ul>
<p><strong>协议与类别的区别</strong>：</p>
<ul>
<li>类别是针对类进行扩展，协议可以选择性实现；</li>
<li>类别的方法由此类实现，其他类不能重写次此类的方法。协议只定义方法，遵循此协议的类再实现协议中的方法；</li>
<li>类别中的方法只能被该类的子类继承，协议可以被不同的类遵循。</li>
</ul>
<h3 id="非正式协议"><a href="#非正式协议" class="headerlink" title="非正式协议"></a>非正式协议</h3><p>苹果官方文档 <a href="http://developer.apple.com/library/ios/#documentation/general/conceptual/devpedia-cocoacore/Protocol.html#//apple_ref/doc/uid/TP40008195-CH45-SW2">Cocoa Core Competencies</a> 一文中是这样介绍非正式协议的：</p>
<p>An informal protocol is a category on <code>NSObject</code>, which implicitly makes almost all objects adopters of the protocol. (A category is a language feature that enables you to add methods to a class without subclassing it.) Implementation of the methods in an informal protocol is optional. Before invoking a method, the calling object checks to see whether the target object implements it. Until optional protocol methods were introduced in Objective-C 2.0, informal protocols were essential to the way Foundation and AppKit classes implemented delegation.</p>
<p>大概意思：非正式协议是 NSObject 类（显而易见，还包括它的子类）的类别，其所有的子类都含蓄地接受了这个协议。（类别是 Objective-C 的一个语言特点，可以让你在无需子类化的前提下为一个类增加方法。）非正式协议中的方法是否实现都是可选的，因此在调用非正式协议中的方法之前，需要去检查对象类是否实现了它。在 Objective-C2.0 中引入可选的正式协议方法之前，非正式协议是 Foundation 和 AppKit 类实现委托的唯一方式。</p>
<p>所以非正式协议就只是基类的类别。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>记录删除storyboard用纯代码布局</title>
    <url>/2022/08/15/Week3_2%EF%BC%9AOC%E5%88%A0%E9%99%A4%E6%95%85%E4%BA%8B%E6%9D%BF%E8%BF%9B%E8%A1%8C%E7%BA%AF%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h1 id="记录删除storyboard用纯代码布局"><a href="#记录删除storyboard用纯代码布局" class="headerlink" title="记录删除storyboard用纯代码布局"></a>记录删除storyboard用纯代码布局</h1><p>[toc]</p>
<h2 id="目录变化"><a href="#目录变化" class="headerlink" title="目录变化"></a>目录变化</h2><p>首先来看一下 Xcode13 创建项目的目录，比之前的旧版本多了 <code>SceneDelegate.h 和 SceneDelegate.m </code> 两个文件</p>
<img src="/Users/admin/Library/Application Support/typora-user-images/image-20220708113229940.png" alt="image-20220708113229940" style="zoom: 50%;">



<h2 id="SceneDelegate"><a href="#SceneDelegate" class="headerlink" title="SceneDelegate"></a>SceneDelegate</h2><p>从 Xcode11开始，创建新的iOS项目的模版中会带有 <code>SceneDelegate</code> 类，并且在 plist 文件中会有一个 <code>Application Scene Manifest</code> 配置，<code>AppDelegate.m </code>中新增了两个管理 SceneDelegate 的函数 ，分别是 <code>application(_:configurationForConnecting:options:)</code> 和  <code>application(_:didDiscardSceneSessions:)</code>。</p>
<p> <code>SceneDelegate.h 和 SceneDelegate.m </code> 两个文件这两个文件一般用于 ipadOS 的分屏功能的。</p>
<span id="more"></span>

<h2 id="删除-storyboard"><a href="#删除-storyboard" class="headerlink" title="删除 storyboard"></a>删除 storyboard</h2><p>将项目中的故事板删除到垃圾桶</p>
<p>然后将 General 下的 Main Interface 中的 Main 删除掉</p>
<p>![image-20220708114349145](/Users/admin/Library/Application Support/typora-user-images/image-20220708114349145.png)</p>
<p>接着删除 Info 下的 Application Scene Manifest </p>
<p>![image-20220708115206174](/Users/admin/Library/Application Support/typora-user-images/image-20220708115206174.png)</p>
<h2 id="删除-SceneDelegate-h-和-SceneDelegate-m-两个文件"><a href="#删除-SceneDelegate-h-和-SceneDelegate-m-两个文件" class="headerlink" title="删除 SceneDelegate.h 和 SceneDelegate.m  两个文件"></a>删除 <code>SceneDelegate.h 和 SceneDelegate.m </code> 两个文件</h2><p>将 <code>SceneDelegate.h </code> 和  <code>SceneDelegate.m </code> 这两个文件扔到垃圾桶</p>
<p>然后删除 <code>Appdelegate.m </code> 中的一下代码</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">mark <span class="token operator">-</span> UISceneSession lifecycle</span></span>


<span class="token operator">-</span> <span class="token punctuation">(</span>UISceneConfiguration <span class="token operator">*</span><span class="token punctuation">)</span>application<span class="token punctuation">:</span><span class="token punctuation">(</span>UIApplication <span class="token operator">*</span><span class="token punctuation">)</span>application configurationForConnectingSceneSession<span class="token punctuation">:</span><span class="token punctuation">(</span>UISceneSession <span class="token operator">*</span><span class="token punctuation">)</span>connectingSceneSession options<span class="token punctuation">:</span><span class="token punctuation">(</span>UISceneConnectionOptions <span class="token operator">*</span><span class="token punctuation">)</span>options <span class="token punctuation">{</span>
    <span class="token comment">// Called when a new scene session is being created.</span>
    <span class="token comment">// Use this method to select a configuration to create the new scene with.</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>UISceneConfiguration alloc<span class="token punctuation">]</span> initWithName<span class="token punctuation">:</span><span class="token string">@"Default Configuration"</span> sessionRole<span class="token punctuation">:</span>connectingSceneSession<span class="token punctuation">.</span>role<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>application<span class="token punctuation">:</span><span class="token punctuation">(</span>UIApplication <span class="token operator">*</span><span class="token punctuation">)</span>application didDiscardSceneSessions<span class="token punctuation">:</span><span class="token punctuation">(</span>NSSet<span class="token operator">&lt;</span>UISceneSession <span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span>sceneSessions <span class="token punctuation">{</span>
    <span class="token comment">// Called when the user discards a scene session.</span>
    <span class="token comment">// If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.</span>
    <span class="token comment">// Use this method to release any resources that were specific to the discarded scenes, as they will not return.</span>
<span class="token punctuation">}</span></code></pre>

<p> <code>Appdelegate.h </code> 中要添加 window 属性</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">@interface</span> AppDelegate <span class="token punctuation">:</span> UIResponder <span class="token operator">&lt;</span>UIApplicationDelegate<span class="token operator">&gt;</span>

<span class="token keyword">@property</span> <span class="token punctuation">(</span>strong<span class="token punctuation">,</span> nonatomic<span class="token punctuation">)</span> UIWindow <span class="token operator">*</span> window<span class="token punctuation">;</span>

<span class="token keyword">@end</span></code></pre>

<p>然后在 <code>Appdelegate.m </code> 中的 <code>didFinishLaunchingWithOptions</code> 函数中添加</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token operator">-</span> <span class="token punctuation">(</span>BOOL<span class="token punctuation">)</span>application<span class="token punctuation">:</span><span class="token punctuation">(</span>UIApplication <span class="token operator">*</span><span class="token punctuation">)</span>application didFinishLaunchingWithOptions<span class="token punctuation">:</span><span class="token punctuation">(</span>NSDictionary <span class="token operator">*</span><span class="token punctuation">)</span>launchOptions <span class="token punctuation">{</span>
    <span class="token comment">// Override point for customization after application launch.</span>
    
    <span class="token comment">// 创建UIWindow</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>window <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>UIWindow alloc<span class="token punctuation">]</span> initWithFrame<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">[</span>UIScreen mainScreen<span class="token punctuation">]</span> bounds<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 设置UIWindow的背景颜色</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>window<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token punctuation">[</span>UIColor grayColor<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    ViewController <span class="token operator">*</span>homeVC <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>ViewController alloc<span class="token punctuation">]</span> init<span class="token punctuation">]</span><span class="token punctuation">;</span>
    UINavigationController <span class="token operator">*</span>homeNav <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>UINavigationController alloc<span class="token punctuation">]</span> initWithRootViewController<span class="token punctuation">:</span>homeVC<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>window<span class="token punctuation">.</span>rootViewController <span class="token operator">=</span> homeNav<span class="token punctuation">;</span>

    
    <span class="token punctuation">[</span><span class="token keyword">self</span><span class="token punctuation">.</span>window makeKeyAndVisible<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> YES<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>接下来就可以用纯代码进行编写了！</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中的生命周期</title>
    <url>/2022/08/10/Week3_1%EF%BC%9A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="iOS中的生命周期"><a href="#iOS中的生命周期" class="headerlink" title="iOS中的生命周期"></a>iOS中的生命周期</h1><p>[toc]</p>
<h2 id="APP-生命周期"><a href="#APP-生命周期" class="headerlink" title="APP 生命周期"></a>APP 生命周期</h2><h3 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h3><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3ux0bcpa5j21e70u0teb.jpg" style="zoom:40%;">

<span id="more"></span>

<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>App 在5种状态间的转换流程图</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3yfrzo91wj20u00ugabn.jpg" style="zoom:53%;">



<p>发生状态转换时大多数都会调用 <code>delegate</code> 对象对应的方法来响应 app 的状态改变，下面是 <code>delegate</code> 对象的方法：</p>
<ul>
<li><p><code>application:willFinishLaunchingWithOptions:</code> 这个方法是你在启动时的第一次机会来执行代码</p>
</li>
<li><p><code>application:didFinishLaunchingWithOptions:</code> 这个方法允许你在显示 app 给用户之前执行最后的初始化操作</p>
</li>
</ul>
<blockquote>
<p>application:willFinishLaunchingWithOptions、application:didFinishLaunchingWithOptions 这两个方法越简单越好，因为 app 从启动到可以响应的时间越短越好，非必要的事情可以延迟或者起子线程执行，超过五秒没有完成这两个函数，系统将 kill app</p>
</blockquote>
<ul>
<li><p><code>applicationDidBecomeActive:</code> app 已经切换到 active 状态后需要执行的操作</p>
</li>
<li><p><code>applicationWillResignActive:</code> app 将要从前台切换到后台时需要执行的操作</p>
</li>
<li><p><code>applicationDidEnterBackground:</code> app 已经进入后台后需要执行的操作（该方法需要五秒内返回，否则应用程序被终止并从内存中清除）</p>
</li>
<li><p><code>applicationWillEnterForeground:</code> app 将要从后台切换到前台需要执行的操作，但 app 还不是 active 状态</p>
</li>
<li><p><code>applicationWillTerminate:</code> app 将要结束时需要执行的操作</p>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>与 app 生命周期有关的几个时间规则</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3uwzg9kerj21ed0u0jz2.jpg"></p>
<p>其中，对启动时间的限制是为了追求更好的用户体验，而其它几项基本是为了更好地管理、使用系统有限的资源。</p>
<p><code>application:willFinishLaunchingWithOptions</code> 及 <code>application:didFinishLaunchingWithOptions</code> 的第二个参数 <code>launchOptions</code> 准确记录了 app 启动原因以及相应的参数信息。如，若 <code>launchOptions</code> 中存在以<code>UIApplicationLaunchOptionsURLKey</code> 为 key 的键值对，表明 app 是由 openurl 启动的。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h3ux2q5t5hj21aw0u0wl2.jpg"></p>
<h2 id="UIViewController-及其生命周期"><a href="#UIViewController-及其生命周期" class="headerlink" title="UIViewController 及其生命周期"></a>UIViewController 及其生命周期</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在 iOS 开发中 <code>UIViewController</code> 扮演者非常重要的角色，它是视图 <code>view</code> 和数据 <code>model</code> 的桥梁，通过 <code>UIViewController</code> 的管理有条不紊的将数据展示在视图上。作为 UIKit 中最基本的一个类，一般复杂的项目都离不开 <code>UIViewController</code> 作为基类。所以了解 <code>UIViewController</code> 的整个生命周期是有必要的。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ol>
<li>loadView()</li>
</ol>
<ul>
<li>view 就加载出来了 可以在这里直接替换 View 比如你把这个 View 转换成了 tableView</li>
</ul>
<ol start="2">
<li>viewDidLoad()</li>
</ol>
<ul>
<li>view 完成加载</li>
</ul>
<ol start="3">
<li>viewWillAppear(_ animated: Bool)</li>
</ol>
<ul>
<li>view 即将显示</li>
</ul>
<ol start="4">
<li>viewWillLayoutSubviews()</li>
</ol>
<ul>
<li>将要开始布局子 view</li>
<li>当页面发生布局改变的时候会调用这个方法 会多次调用</li>
<li>同 LayoutSubviews Cell 的</li>
</ul>
<ol start="5">
<li>viewDidLayoutSubviews()</li>
</ol>
<ul>
<li>已经布局子 view</li>
<li>上面方法完成就会调这个</li>
</ul>
<ol start="6">
<li>viewDidAppear(_ animated:Bool)</li>
</ol>
<ul>
<li>view 完成显示</li>
</ul>
<p>7.viewWillDisappear</p>
<ul>
<li>view 将要消失</li>
</ul>
<p>8.viewDidDisappear</p>
<ul>
<li>view 完成消失</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>OC 中的数据存储</title>
    <url>/2022/07/24/Week2_1%EF%BC%9AOC%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="OC-中的数据存储"><a href="#OC-中的数据存储" class="headerlink" title="OC 中的数据存储"></a>OC 中的数据存储</h1><p>[toc]</p>
<h2 id="plist-文件"><a href="#plist-文件" class="headerlink" title="plist 文件"></a>plist 文件</h2><h3 id="属性列表"><a href="#属性列表" class="headerlink" title="属性列表"></a>属性列表</h3><p>C 提供了 <code>open()、read()、write()、fopen()、fread() </code>这些函数创建、读取和写入文件</p>
<p>而 Cocoa 提供了两个处理文件的通用类：属性列表和对象编码</p>
<p>在 Cocoa 中有一类名为属性列表（property list）的对象，简写为 plist。这些对象用来存放一些 Cocoa 能够处理的对象，比如<code>NSArray、NSNumber、NSDictionary、NSString、NSData、NSDate</code> 主要是将这些对象存储到文件中或从文件中加载。</p>
<p>下面来熟悉一下 NSDate 和 NSData 的使用。</p>
<p>NSDate 类是 Cocoa 中用来处理日期和时间的基础类，[NSDate date] 能够获取当前的日期和时间，它能够返回一个自动释放的对象。</p>
<pre class="language-objc" data-language="objc"><code class="language-objc">NSDate <span class="token operator">*</span>date <span class="token operator">=</span> <span class="token punctuation">[</span>NSDate date<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"today is %@"</span><span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//today is Mon Jun 27 11:31:52 2022</span>

NSDate <span class="token operator">*</span>yesterday <span class="token operator">=</span> <span class="token punctuation">[</span>NSDate dateWithTimeIntervalSinceNow<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"yesterday now is %@"</span><span class="token punctuation">,</span> yesterday<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//yesterday now is Sun Jun 26 11:37:39 2022</span>

NSDate <span class="token operator">*</span>tomorrow <span class="token operator">=</span> <span class="token punctuation">[</span>NSDate dateWithTimeIntervalSinceNow<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"tomorrow now is %@"</span><span class="token punctuation">,</span> tomorrow<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//tomorrow now is Tue Jun 28 11:37:39 2022</span></code></pre>

<span id="more"></span>

<p>NSData 类可以包含大量字节，你可以获得数据的长度和指向字节起始位置的指针。</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>string <span class="token operator">=</span> <span class="token string">"Hi there, this is a C string!"</span><span class="token punctuation">;</span>
NSData <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>NSData dataWithBytes<span class="token punctuation">:</span> string length<span class="token punctuation">:</span> <span class="token function">strlen</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"data is %@"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//data is {length = 30, bytes = 0x48692074 68657265 2c207468 69732069 ... 73747269 6e672100 }</span>
<span class="token function">NSLog</span><span class="token punctuation">(</span><span class="token string">@"%d byte string is '%s'"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>data length<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>data bytes<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//30 byte string is 'Hi there, this is a C string!'</span></code></pre>



<h3 id="写入的读取属性列表"><a href="#写入的读取属性列表" class="headerlink" title="写入的读取属性列表"></a>写入的读取属性列表</h3><p>集合型属性列表类（NSArray 和 NSDictionary）具有一个 <code>- writeToFile: atomically:</code> 的方法用于将属性列表的内容写入文件。</p>
<p>NSString 和 NSData 也有  <code>writeToFile: atomically:</code>  的方法，不过只能写出字符串和数据块</p>
<pre class="language-objc" data-language="objc"><code class="language-objc">NSArray <span class="token operator">*</span>phrase<span class="token punctuation">;</span>
phrase <span class="token operator">=</span> <span class="token punctuation">[</span>NSArray arrayWithObjects<span class="token punctuation">:</span> <span class="token string">@"I"</span><span class="token punctuation">,</span> <span class="token string">@"seem"</span><span class="token punctuation">,</span> <span class="token string">@"to"</span><span class="token punctuation">,</span> <span class="token string">@"be"</span><span class="token punctuation">,</span> <span class="token string">@"a"</span><span class="token punctuation">,</span> <span class="token string">@"verb"</span><span class="token punctuation">,</span> nil<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span>phrase writeToFile<span class="token punctuation">:</span><span class="token string">@"/tmp/verbiage.txt"</span> atomically<span class="token punctuation">:</span>YES<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>

<p>然后打开 Finder，按下 commond + shift + G 输入 <code>/tmp</code> 回车，会看到 verbiage 文件，打开能看到以下内容</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">?</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE plist PUBLIC "<span class="token operator">-</span><span class="token comment">//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span>
<span class="token operator">&lt;</span>plist version<span class="token operator">=</span><span class="token string">"1.0"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>array<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>I<span class="token operator">&lt;</span><span class="token operator">/</span>string<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>seem<span class="token operator">&lt;</span><span class="token operator">/</span>string<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>to<span class="token operator">&lt;</span><span class="token operator">/</span>string<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>be<span class="token operator">&lt;</span><span class="token operator">/</span>string<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>a<span class="token operator">&lt;</span><span class="token operator">/</span>string<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>verb<span class="token operator">&lt;</span><span class="token operator">/</span>string<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>array<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>plist<span class="token operator">&gt;</span></code></pre>

<p>可以使用 <code> +arrayWithContentsOffFile:</code>  方法读取该文件。会出现一些结果：</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token punctuation">(</span>
    I<span class="token punctuation">,</span>
    seem<span class="token punctuation">,</span>
    to<span class="token punctuation">,</span>
    be<span class="token punctuation">,</span>
    a<span class="token punctuation">,</span>
    verb
<span class="token punctuation">)</span></code></pre>

<p>要注意 <code>writeToFile</code>  中的 <code>atomically</code> ，它的参数类型为 BOOL 型，它会告诉 Cocoa 是否先将文件内容保存在临时文件中，然后再将原始文件与临时文件交换，这是一种安全机制，如果在保持的过程出现意外的话，不会破坏原始文件。但是这种方法的缺点是会消耗两倍的内存空间，除非要保存的文件非常大的话，应该始终用 <code>atomically </code>方式保存文件。</p>
<h2 id="NSUserDefaults（偏好设置，本质是plist）"><a href="#NSUserDefaults（偏好设置，本质是plist）" class="headerlink" title="NSUserDefaults（偏好设置，本质是plist）"></a>NSUserDefaults（偏好设置，本质是plist）</h2><p>用来保存应用程序设置和属性、用户保存的数据。用户再次打开程序或开机后这些数据仍然存在。<br>NSUserDefaults 可以存储的数据类型包括：NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary。如果要存储其他类型，则需要转换为前面的类型，才能用 NSUserDefaults 存储</p>
<h2 id="NSKeyedArchiver（归档）"><a href="#NSKeyedArchiver（归档）" class="headerlink" title="NSKeyedArchiver（归档）"></a>NSKeyedArchiver（归档）</h2><p>采用归档的形式来保存数据，该数据对象需要遵守 NSCoding 协议，并且该对象对应的类必须提供 encodeWithCoder: 和 initWithCoder:方法。<br>前一个方法告诉系统怎么对对象进行编码，而后一个方法则是告诉系统怎么对对象进行解码。</p>
<p>缺点：</p>
<p>归档的形式来保存数据，只能一次性归档保存以及一次性解压。所以只能针对小量数据，而且对数据操作比较笨拙，即如果想改动数据的某一小部分，还是需要解压整个数据或者归档整个数据。</p>
<blockquote>
<p>注: initWithCoder什么时候需要调用[super initWithCoder:]<br>• initWithCoder原理:只要解析文件就会调用，xib,storyboard都是文件，因此只要解析这两个文件，就会调用initWithCoder。<br>• 因此如果在storyboard使用自定义view,重写initWithCoder方法，一定要调用[super initWithCoder:]，因为只有系统才知道怎么解析storyboard，如果没有调用，就解析不了这个文件。</p>
</blockquote>
<h2 id="NSFileManage文件管理（沙盒）"><a href="#NSFileManage文件管理（沙盒）" class="headerlink" title="NSFileManage文件管理（沙盒）"></a>NSFileManage文件管理（沙盒）</h2><p>App所产生的数据都存在于自己的沙盒中，一般沙盒都有3个文件：<code>Documents</code>、<code>Library</code>和<code>tmp</code>。<br> <code>Documents</code>：这个目录存放用户数据。存放用户可以管理的文件；iTunes备份和恢复的时候会包括此目录。<br> <code>Library</code>:主要使用它的子文件夹,我们熟悉的NSUserDefaults就存在于它的子目录中。<br> <code>Library/Caches</code>:存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除,“删除缓存”一般指的就是清除此目录下的文件。<br> <code>Library/Preferences</code>:NSUserDefaults的数据存放于此目录下。<br> <code>tmp</code>:App应当负责在不需要使用的时候清理这些文件，系统在App不运行的时候也可能清理这个目录。</p>
<h2 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h2><p>对于bundle可以理解为一个捆绑包，我们的可执行（executable）工程，打包完之后，也是一个捆绑包，我们称之为主bundle，这个主bundle包含了可执行代码，如各个viewcontroller的可执行代码，和相关资源例如图片资源等。</p>
<p>NSBundle这个类其实就是用来定位可执行资源的。获取到具体的可执行文件的位置，然后再加载。因此，NSBundle的使用，只限制于拥有独立的bundle空间的（</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>iTerm2终端神器快速安装教程</title>
    <url>/2022/09/04/Week4_2%EF%BC%9AiTerm2%E5%8A%A0zsh%E6%90%AD%E5%BB%BA%E9%AB%98%E9%A2%9C%E5%80%BC%E5%BC%BA%E5%A4%A7%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<h1 id="iTerm2终端神器快速安装教程（自定义主题-高亮-智能补全……）"><a href="#iTerm2终端神器快速安装教程（自定义主题-高亮-智能补全……）" class="headerlink" title="iTerm2终端神器快速安装教程（自定义主题+高亮+智能补全……）"></a>iTerm2终端神器快速安装教程（自定义主题+高亮+智能补全……）</h1><p>[toc]</p>
<h2 id="一、iTerm2的获取"><a href="#一、iTerm2的获取" class="headerlink" title="一、iTerm2的获取"></a>一、iTerm2的获取</h2><ul>
<li>Iterm可以用来替换掉默认终端。</li>
<li>官网下载 <a href="https://iterm2.com/">iterm2.com</a></li>
<li>下载之后安装</li>
</ul>
<p>然后设为默认终端</p>
<img src="/Users/admin/Library/Application Support/typora-user-images/image-20220715150242429.png" alt="image-20220715150242429" style="zoom:25%;">



<h2 id="二、-Oh-My-Zsh"><a href="#二、-Oh-My-Zsh" class="headerlink" title="二、 Oh My Zsh"></a>二、 Oh My Zsh</h2><p>Oh My Zsh 是对主题的进一步扩展,</p>
<p>使用 curl 安装 Oh My Zsh </p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sh</span> -c <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh<span class="token variable">)</span></span>"</span></code></pre>

<span id="more"></span>

<h2 id="三、修改主题"><a href="#三、修改主题" class="headerlink" title="三、修改主题"></a>三、修改主题</h2><p>先修改颜色，当然，看个人喜欢，我是很喜欢这个颜色的</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h47nbdyouqj212j0u0djb.jpg" style="zoom:50%;">

<p>进入命令行</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">vim</span> ~/.zshrc</code></pre>



<p>将主题改为 ys，个人比较喜欢 ys 这个主题，简洁又能显示很多信息，可以是显示 git 仓库的状态，如果喜欢其他主题也可以自行尝试更改</p>
<p>点这里可以查看 zsh 所有主题 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes">主题列表</a></p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h47mlvq3z3j217c0u0wk6.jpg" style="zoom:50%;">



<p>如果使用上面的主题会出现文字乱码的情况, 需要 Meslo 字体支持</p>
<p><a href="https://github.com/powerline/fonts/blob/master/Meslo%20Slashed/Meslo%20LG%20M%20Regular%20for%20Powerline.ttf">字体下载链接</a></p>
<p>下载安装，然后进行更改</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h47mu0myalj21fq0qeq74.jpg" style="zoom:50%;">





<h2 id="四-字体高亮"><a href="#四-字体高亮" class="headerlink" title="四. 字体高亮"></a>四. 字体高亮</h2><p>使用 Homebrew 安装, 输入命令</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">brew <span class="token function">install</span> zsh-syntax-highlighting</code></pre>

<p>安装成功之后，进入编辑文件</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">vim ~/.zshrc </code></pre>

<p>按 i 进入编辑模式</p>
<p>在最后一行添加 <code>source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh </code> </p>
<p>按下 esc，然后再输入 wq 保存退出</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h47mx6bis9j21jw0i8q6s.jpg"></p>
<p>最后输入<code>source ~/.zshrc</code>激活配置文件</p>
<h2 id="五-自动填充"><a href="#五-自动填充" class="headerlink" title="五. 自动填充"></a>五. 自动填充</h2><p>自动填充，可以记录你之前输入过的命令，再次输入会有提示。</p>
<p>克隆zsh-autosuggestions项目</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</code></pre>

<p>使用vim编辑或者直接打开.zshrc文件</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">vim</span> ~/.zshrc</code></pre>

<p>输入 source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 保存文件</p>
<p>最后输入<code>source ~/.zshrc</code>激活配置文件</p>
<h2 id="六、调整字体和窗口大小"><a href="#六、调整字体和窗口大小" class="headerlink" title="六、调整字体和窗口大小"></a>六、调整字体和窗口大小</h2><p>这个看个人习惯调整到自己觉得最舒服的状态</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h47n3l4otmj21bs0u0gpx.jpg" style="zoom:50%;">]]></content>
      <categories>
        <category>DOS</category>
      </categories>
      <tags>
        <tag>DOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift学习笔记</title>
    <url>/2022/10/11/Week5_1%EF%BC%9ASwift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Swift学习笔记"><a href="#Swift学习笔记" class="headerlink" title="Swift学习笔记"></a>Swift学习笔记</h1><p>[toc]</p>
<h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><p>常量的值一旦设定就不能改变，而变量的值可以随意更改。</p>
<p>声明常量和变量</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> height <span class="token operator">=</span> <span class="token number">188</span>
<span class="token keyword">var</span> weight <span class="token operator">=</span> <span class="token number">120</span></code></pre>

<p>这两行代码可以理解为，声明一个名字为 height 的常量，并给它赋值为 188，然后声明一个名字为 weight 的变量，并给它赋值为 120。</p>
<p>如果你的代码中有不需要改变的值，使用  <code>let</code>  关键字将它声明为常量，只将需要改变的值声明为变量，这样会使你的代码更加合理。</p>
<p>与变量不同，常量的值一旦被确定就不能更改了。尝试这样做会导致编译时报错：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> height <span class="token operator">=</span> <span class="token number">188</span>
height <span class="token operator">=</span> <span class="token number">199</span>
<span class="token comment">// 这会报编译时错误 - height 不可改变</span></code></pre>

<p>你可以在一行中声明多个常量或者多个变量，用逗号隔开：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> z <span class="token operator">=</span> <span class="token number">2</span></code></pre>

<span id="more"></span>

<h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>当你声明常量或者变量的时候可以加上 <strong>类型注解（type annotation）</strong>，说明常量或者变量中要存储的值的类型。如果要添加类型注解，需要在常量或者变量名后面加上一个冒号和空格，然后加上类型名称。</p>
<p>这个例子给 <code>height</code> 变量添加了类型注解，表示这个变量可以存储 <code>Int</code> 类型的值：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> height<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token number">188</span></code></pre>

<p>可以在一行中定义多个同样类型的变量，用逗号分割，并在最后一个变量名之后添加类型注解：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">:</span> <span class="token class-name">Double</span></code></pre>

<p>一般来说很少需要写类型注解。如果在声明常量或者变量的时候赋了一个初始值，Swift 可以推断出这个常量或者变量的类型</p>
<h2 id="输出常量和变量"><a href="#输出常量和变量" class="headerlink" title="输出常量和变量"></a>输出常量和变量</h2><p>你可以用  <code>print(_:separator:terminator:)</code>  函数来输出当前常量或变量的值。</p>
<p><code>separator</code> 和 <code>terminator</code> 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 <code>terminator</code> 参数。例如，<code>print(someValue, terminator:"")</code></p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"第一行"</span></span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"第二行"</span></span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"第三行"</span></span><span class="token punctuation">,</span>terminator<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">""</span></span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"也是第三行"</span></span><span class="token punctuation">,</span>terminator<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">""</span></span><span class="token punctuation">)</span>
<span class="token comment">// 第一行</span>
<span class="token comment">// 第二行</span>
<span class="token comment">// 第三行也是第三行</span></code></pre>



<p>Swift 用 <strong>字符串插值（string interpolation）</strong> 的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> nickName <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"beyhuang"</span></span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The boy nickName is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">nickName</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// The boy nickName is beyhuang</span></code></pre>



<h2 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h2><p>整数范围</p>
<p>你可以访问不同整数类型的 <code>min</code> 和 <code>max</code> 属性来获取对应类型的最小值和最大值：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> minValue <span class="token operator">=</span> <span class="token class-name">UInt8</span><span class="token punctuation">.</span>min  <span class="token comment">// minValue 为 0，是 UInt8 类型</span>
<span class="token keyword">let</span> maxValue <span class="token operator">=</span> <span class="token class-name">UInt8</span><span class="token punctuation">.</span>max  <span class="token comment">// maxValue 为 255，是 UInt8 类型</span></code></pre>

<h3 id="Int"><a href="#Int" class="headerlink" title="Int"></a>Int</h3><p>一般来说，你不需要专门指定整数的长度。Swift 提供了一个特殊的整数类型 <code>Int</code>，长度与当前平台的原生字长相同：</p>
<p>在32位平台上，<code>Int</code> 和 <code>Int32</code> 长度相同。</p>
<p>在64位平台上，<code>Int</code> 和 <code>Int64</code> 长度相同。</p>
<p>除非你需要特定长度的整数，一般来说使用 <code>Int</code> 就够了。这可以提高代码一致性和可复用性。即使是在32位平台上，<code>Int</code> 可以存储的整数范围也可以达到 <code>-2,147,483,648</code> ~ <code>2,147,483,647</code>，大多数时候这已经足够大了。</p>
<h3 id="UInt"><a href="#UInt" class="headerlink" title="UInt"></a>UInt</h3><p>Swift 也提供了一个特殊的无符号类型 <code>UInt</code>，长度与当前平台的原生字长相同：</p>
<p>在32位平台上，<code>UInt</code> 和 <code>UInt32</code> 长度相同。</p>
<p>在64位平台上，<code>UInt</code> 和 <code>UInt64</code> 长度相同。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>尽量不要使用 <code>UInt</code>，除非你真的需要存储一个和当前平台原生字长相同的无符号整数。除了这种情况，最好使用 <code>Int</code>，即使你要存储的值已知是非负的。统一使用 <code>Int</code> 可以提高代码的可复用性，避免不同类型数字之间的转换，并且匹配数字的类型推断</p>
</blockquote>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>浮点数是有小数部分的数字，比如 <code>3.14159</code>、<code>0.1</code> 和 <code>-273.15</code>。</p>
<p>浮点类型比整数类型表示的范围更大，可以存储比 <code>Int</code> 类型更大或者更小的数字。Swift 提供了两种有符号浮点数类型：</p>
<p><code>Double</code> 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。</p>
<p><code>Float</code> 表示32位浮点数。精度要求不高的话可以使用此类型。</p>
<blockquote>
<p>注意</p>
<p><code>Double</code> 精确度很高，至少有 15 位小数，而 <code>Float</code> 只有 6 位小数。选择哪个类型取决于你的代码需要处理的值的范围，在两种类型都匹配的情况下，将优先选择 <code>Double</code>。</p>
</blockquote>
<h2 id="类型安全和类型推断"><a href="#类型安全和类型推断" class="headerlink" title="类型安全和类型推断"></a>类型安全和类型推断</h2><p>Swift 是一个 <strong>类型安全（type safe）</strong> 的语言。类型安全的语言可以让你清楚地知道代码要处理的值的类型。如果你的代码需要一个 <code>String</code>，你绝对不可能不小心传进去一个 <code>Int</code>。</p>
<p>由于 Swift 是类型安全的，所以它会在 <strong>编译</strong> 你的代码时进行 <strong>类型检查（type checks）</strong>，并把不匹配的类型标记为错误。这可以让你在开发的时候尽早发现并修复错误。</p>
<p>当你要处理不同类型的值时，类型检查可以帮你避免错误。然而，这并不是说你每次声明常量和变量的时候都需要显式指定类型。如果你没有显式指定类型，Swift 会使用 <strong>类型推断（type inference）</strong>来选择合适的类型。有了类型推断，编译器可以在编译代码的时候自动推断出表达式的类型。原理很简单，只要检查你赋的值即可。</p>
<p>因为有类型推断，和 C 或者 Objective-C 比起来 Swift 很少需要声明类型。常量和变量虽然需要明确类型，但是大部分工作并不需要你自己来完成。</p>
<p>当你声明常量或者变量并赋初值的时候类型推断非常有用。当你在声明常量或者变量的时候赋给它们一个字面量（literal value 或 literal）即可触发类型推断。（字面量就是会直接出现在你代码中的值，比如 <code>42</code> 和 <code>3.14159</code> 。）</p>
<p>例如，如果你给一个新常量赋值 <code>42</code> 并且没有标明类型，Swift 可以推断出常量类型是 <code>Int</code> ，因为你给它赋的初始值看起来像一个整数：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> meaningOfLife <span class="token operator">=</span> <span class="token number">42</span>
<span class="token comment">// meaningOfLife 会被推测为 Int 类型</span></code></pre>

<p>同理，如果你没有给浮点字面量标明类型，Swift 会推断你想要的是 <code>Double</code>：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> pi <span class="token operator">=</span> <span class="token number">3.14159</span>
<span class="token comment">// pi 会被推测为 Double 类型</span></code></pre>

<p>当推断浮点数的类型时，Swift 总是会选择 <code>Double</code> 而不是 <code>Float</code>。</p>
<p>如果表达式中同时出现了整数和浮点数，会被推断为 <code>Double</code> 类型：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> anotherPi <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">0.14159</span>
<span class="token comment">// anotherPi 会被推测为 Double 类型</span></code></pre>

<p>原始值 <code>3</code> 没有显式声明类型，而表达式中出现了一个浮点字面量，所以表达式会被推断为 <code>Double</code> 类型。</p>
<h2 id="数值型类型转换"><a href="#数值型类型转换" class="headerlink" title="数值型类型转换"></a>数值型类型转换</h2><p>不同整数类型的变量和常量可以存储不同范围的数字</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> cannotBeNegative<span class="token punctuation">:</span> <span class="token class-name">UInt8</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>
<span class="token comment">// UInt8 类型不能存储负数，所以会报错</span>
<span class="token keyword">let</span> tooBig<span class="token punctuation">:</span> <span class="token class-name">Int8</span> <span class="token operator">=</span> <span class="token class-name">Int8</span><span class="token punctuation">.</span>max <span class="token operator">+</span> <span class="token number">1</span>
<span class="token comment">// Int8 类型不能存储超过最大值的数，所以会报错</span></code></pre>

<p>不同的数值类型之间运算是需要进行类型转换的</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> twoThousand<span class="token punctuation">:</span> <span class="token class-name">UInt16</span> <span class="token operator">=</span> <span class="token number">2_000</span>
<span class="token keyword">let</span> one<span class="token punctuation">:</span> <span class="token class-name">UInt8</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">let</span> twoThousandAndOne <span class="token operator">=</span> twoThousand <span class="token operator">+</span> <span class="token class-name">UInt16</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span></code></pre>

<p>整数和浮点数的转换必须显式指定类型</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> three <span class="token operator">=</span> <span class="token number">3</span>
<span class="token keyword">let</span> pointOneFourOneFiveNine <span class="token operator">=</span> <span class="token number">0.14159</span>
<span class="token keyword">let</span> pi <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>three<span class="token punctuation">)</span> <span class="token operator">+</span> pointOneFourOneFiveNine
<span class="token comment">// pi 等于 3.14159，所以被推测为 Double 类型</span></code></pre>



<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>swift 中的布尔值需要注意的是和其他能够进行隐式转换类型的语言不同，当一个 Int 的值为 1 的时候，在进行 if 判断时，swift 并不会将这个值转换为布尔值。</p>
<p>如果你在需要使用 <code>Bool</code> 类型的地方使用了非布尔值，Swift 的类型安全机制会报错。下面的例子会报告一个编译时错误：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">if</span> i <span class="token punctuation">{</span>
<span class="token comment">// 这个例子不会通过编译，会报错</span>
<span class="token punctuation">}</span></code></pre>

<p>然而，下面的例子是合法的：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">if</span> i <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
<span class="token comment">// 这个例子会编译成功</span>
<span class="token punctuation">}</span></code></pre>

<p><code>i == 1</code> 的比较结果是 <code>Bool</code> 类型，所以第二个例子可以通过类型检查。类似 <code>i == 1</code> 这样的比较</p>
<p>和 Swift 中的其他类型安全的例子一样，这个方法可以避免错误并保证这块代码的意图总是清晰的</p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p><strong>元组（tuples）</strong>把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> http404Error <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Not Found"</span></span><span class="token punctuation">)</span>
<span class="token comment">// http404Error 的类型是 (Int, String)，值是 (404, "Not Found")</span></code></pre>

<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为 <code>(Int, Int, Int)</code> 或者 <code>(String, Bool)</code> 或者其他任何你想要的组合的元组。</p>
<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>statusCode<span class="token punctuation">,</span> statusMessage<span class="token punctuation">)</span> <span class="token operator">=</span> http404Error
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The status code is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">statusCode</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// The status code is 404</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The status message is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">statusMessage</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// The status message is Not Found</span></code></pre>

<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（<code>_</code>）标记：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>justTheStatusCode<span class="token punctuation">,</span> <span class="token omit keyword">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> http404Error
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The status code is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">justTheStatusCode</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// The status code is 404</span></code></pre>

<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The status code is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">http404Error<span class="token punctuation">.</span><span class="token number">0</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// The status code is 404</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The status message is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">http404Error<span class="token punctuation">.</span><span class="token number">1</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// The status message is Not Found</span></code></pre>

<p>你可以在定义元组的时候给单个元素命名：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> http200Status <span class="token operator">=</span> <span class="token punctuation">(</span>statusCode<span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span> description<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"OK"</span></span><span class="token punctuation">)</span></code></pre>

<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The status code is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">http200Status<span class="token punctuation">.</span>statusCode</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// The status code is 200</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The status message is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">http200Status<span class="token punctuation">.</span>description</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// The status message is OK</span></code></pre>

<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个 <code>(Int, String)</code> 元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。</p>
<h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><p>使用 <strong>可选类型（optionals）</strong>来处理值可能缺失的情况。可选类型表示两种可能：值缺失或者有值， 你可以解析可选类型访问这个值， 或者根本没有值。</p>
<blockquote>
<p>注意</p>
<p>C 和 Objective-C 中并没有可选类型这个概念。最接近的是 Objective-C 中的一个特性，一个方法要不返回一个对象要不返回  <code>nil</code>， <code>nil</code>  表示“缺少一个合法的对象”。然而，这只对对象起作用——对于结构体，基本的 C 类型或者枚举类型不起作用。对于这些类型，Objective-C 方法一般会返回一个特殊值（ 比如 <code>NSNotFound</code> ）来暗示值缺失。这种方法假设方法的调用者知道并记得对特殊值进行判断。然而，Swift 的可选类型可以让你暗示 <strong>任意类型</strong> 的值缺失，并不需要一个特殊值。</p>
</blockquote>
<p>来看一个例子。Swift 的 <code>Int</code> 类型有一种构造器，作用是将一个 <code>String</code> 值转换成一个 <code>Int</code> 值。然而，并不是所有的字符串都可以转换成一个整数。字符串 <code>"123"</code> 可以被转换成数字 <code>123</code> ，但是字符串 <code>"hello, world"</code> 不行。</p>
<p>下面的例子使用这种构造器来尝试将一个 <code>String</code> 转换成 <code>Int</code>：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> possibleNumber <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"123"</span></span>
<span class="token keyword">let</span> convertedNumber <span class="token operator">=</span> <span class="token class-name">Int</span><span class="token punctuation">(</span>possibleNumber<span class="token punctuation">)</span>
<span class="token comment">// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"</span></code></pre>

<p>因为该构造器可能会失败，所以它返回一个<em>可选类型</em>（optional）<code>Int</code>，而不是一个 <code>Int</code>。一个可选的 <code>Int</code> 被写作 <code>Int?</code> 而不是 <code>Int</code>。问号暗示包含的值是可选类型，也就是说可能包含 <code>Int</code> 值也可能<em>不包含值</em>。（不能包含其他任何值比如 <code>Bool</code> 值或者 <code>String</code> 值。只能是 <code>Int</code> 或者什么都没有。）</p>
<h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>你可以给可选变量赋值为 <code>nil</code> 来表示它没有值：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> serverResponseCode<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token number">404</span>
<span class="token comment">// serverResponseCode 包含一个可选的 Int 值 404</span>
serverResponseCode <span class="token operator">=</span> <span class="token nil constant">nil</span>
<span class="token comment">// serverResponseCode 现在不包含值</span></code></pre>

<blockquote>
<p>注意</p>
<p><code>nil</code> 不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。</p>
</blockquote>
<p>如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 <code>nil</code>：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> surveyAnswer<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span>
<span class="token comment">// surveyAnswer 被自动设置为 nil</span></code></pre>

<blockquote>
<p>注意</p>
<p>Swift 的 <code>nil</code> 和 Objective-C 中的 <code>nil</code> 并不一样。在 Objective-C 中，<code>nil</code> 是一个指向不存在对象的指针。在 Swift 中，<code>nil</code> 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 <code>nil</code>，不只是对象类型。</p>
</blockquote>
<h2 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h2><p>使用<em>可选绑定（optional binding）</em>来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 <code>if</code> 和 <code>while</code> 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。</p>
<p>像下面这样在 <code>if</code> 语句中写一个可选绑定：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> constantName <span class="token operator">=</span> someOptional <span class="token punctuation">{</span>
			statements
<span class="token punctuation">}</span></code></pre>

<p>你可以像上面这样使用可选绑定来</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> actualNumber <span class="token operator">=</span> <span class="token class-name">Int</span><span class="token punctuation">(</span>possibleNumber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"\'</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">possibleNumber</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">\' has an integer value of </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">actualNumber</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"\'</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">possibleNumber</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">\' could not be converted to an integer"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// '123' has an integer value of 123</span></code></pre>

<p>重写这个例子</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> possibleNumber <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"123"</span></span>
<span class="token keyword">let</span> convertedNumber <span class="token operator">=</span> <span class="token class-name">Int</span><span class="token punctuation">(</span>possibleNumber<span class="token punctuation">)</span>
<span class="token comment">// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"</span></code></pre>



<h2 id="空和运算符"><a href="#空和运算符" class="headerlink" title="空和运算符"></a>空和运算符</h2><p>空和运算符（Nil Coalescing Operator）</p>
<p><em>空合运算符</em>（ <code>a ?? b</code> ）将对可选类型 <code>a</code> 进行空判断，如果 <code>a</code> 包含一个值就进行解包，否则就返回一个默认值 <code>b</code>。表达式 <code>a</code> 必须是 Optional 类型。默认值 <code>b</code> 的类型必须要和 <code>a</code> 存储值的类型保持一致。</p>
<p>空合运算符是对以下代码的简短表达方法：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift">a <span class="token operator">!=</span> <span class="token nil constant">nil</span> <span class="token operator">?</span> a<span class="token operator">!</span> <span class="token punctuation">:</span> b</code></pre>



<h2 id="字符和字符串"><a href="#字符和字符串" class="headerlink" title="字符和字符串"></a>字符和字符串</h2><h3 id="多行字符串字面量"><a href="#多行字符串字面量" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h3><p>如果你需要一个字符串是跨越多行的，那就使用多行字符串字面量 — 由一对三个双引号包裹着的具有固定顺序的文本字符集：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> quotation <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"""
The White Rabbit put on his spectacles.  "Where shall I begin,
please your Majesty?" he asked.

"Begin at the beginning," the King said gravely, "and go on
till you come to the end; then stop."
"""</span></span></code></pre>

<p>你可以用在行尾写一个反斜杠（<code>\</code>）作为续行符。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> softWrappedQuotation <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"""
The White Rabbit put on his spectacles.  "Where shall I begin, </span><span class="token punctuation">\</span><span class="token string">
please your Majesty?" he asked.

"Begin at the beginning," the King said gravely, "and go on </span><span class="token punctuation">\</span><span class="token string">
till you come to the end; then stop."
"""</span></span>

<span class="token comment">// The White Rabbit put on his spectacles.  "Where shall I begin, please your Majesty?" he asked.</span>

<span class="token comment">// "Begin at the beginning," the King said gravely, "and go on till you come to the end; then stop."</span></code></pre>



<h3 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h3><p>要创建一个空字符串作为初始值，可以将空的字符串字面量赋值给变量，也可以初始化一个新的 <code>String</code> 实例：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> emptyString <span class="token operator">=</span> <span class="token string-literal"><span class="token string">""</span></span>               <span class="token comment">// 空字符串字面量</span>
<span class="token keyword">var</span> anotherEmptyString <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 初始化方法</span>
<span class="token comment">// 两个字符串均为空并等价。</span></code></pre>

<p>你可以通过检查 <code>Bool</code> 类型的 <code>isEmpty</code> 属性来判断该字符串是否为空：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">if</span> emptyString<span class="token punctuation">.</span>isEmpty <span class="token punctuation">{</span>
		<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Nothing to see here"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// Nothing to see here</span></code></pre>



<h3 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h3><p>如果想要获得一个字符串中 <code>Character</code> 值的数量，可以使用 <code>count</code> 属性：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> unusualMenagerie <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪"</span></span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"unusualMenagerie has </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">unusualMenagerie<span class="token punctuation">.</span>count</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> characters"</span></span><span class="token punctuation">)</span>
<span class="token comment">// unusualMenagerie has 40 characters</span></code></pre>

<p>注意在 Swift 中，使用可拓展的字符群集作为 <code>Character</code> 值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>
<p>例如，如果你用四个字符的单词 <code>cafe</code> 初始化一个新的字符串，然后添加一个 <code>COMBINING ACTUE ACCENT</code>(<code>U+0301</code>)作为字符串的结尾。最终这个字符串的字符数量仍然是 <code>4</code>，因为第四个字符是 <code>é</code>，而不是 <code>e</code>：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> word <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"cafe"</span></span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"the number of characters in </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">word</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">word<span class="token punctuation">.</span>count</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// the number of characters in cafe is 4</span>
word <span class="token operator">+=</span> <span class="token string-literal"><span class="token string">"\u{301}"</span></span>    <span class="token comment">// 拼接一个重音，U+0301</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"the number of characters in </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">word</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">word<span class="token punctuation">.</span>count</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token comment">// the number of characters in café is 4</span></code></pre>



<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><p>调用 <code>insert(_:at:)</code> 方法可以在一个字符串的指定索引插入一个字符，调用 <code>insert(contentsOf:at:)</code> 方法可以在一个字符串的指定索引插入一段字符串。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> welcome <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"hello"</span></span>
welcome<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"!"</span></span><span class="token punctuation">,</span> at<span class="token punctuation">:</span> welcome<span class="token punctuation">.</span>endIndex<span class="token punctuation">)</span>
<span class="token comment">// hello!</span>
welcome<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>contentsOf<span class="token punctuation">:</span><span class="token string-literal"><span class="token string">" there"</span></span><span class="token punctuation">,</span> at<span class="token punctuation">:</span> welcome<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>before<span class="token punctuation">:</span> welcome<span class="token punctuation">.</span>endIndex<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// hello there!</span></code></pre>

<p>调用 <code>remove(at:)</code> 方法可以在一个字符串的指定索引删除一个字符，调用 <code>removeSubrange(_:)</code> 方法可以在一个字符串的指定索引删除一个子字符串。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift">welcome<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> welcome<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>before<span class="token punctuation">:</span> welcome<span class="token punctuation">.</span>endIndex<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// hello there</span>
<span class="token keyword">let</span> range <span class="token operator">=</span> welcome<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>welcome<span class="token punctuation">.</span>endIndex<span class="token punctuation">,</span> offsetBy<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token operator">..&lt;</span>welcome<span class="token punctuation">.</span>endIndex
welcome<span class="token punctuation">.</span><span class="token function">removeSubrange</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span>
<span class="token comment">// hello</span></code></pre>

<blockquote>
<p>注意</p>
<p>你可以使用 <code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code>、<code>remove(at:)</code> 和 <code>removeSubrange(_:)</code> 方法在任意一个确认的并遵循 <code>RangeReplaceableCollection</code> 协议的类型里面，如上文所示是使用在 <code>String</code> 中，你也可以使用在 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中。</p>
</blockquote>
<h3 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h3><p>当你从字符串中获取一个子字符串 —— 例如，使用下标或者 <code>prefix(_:)</code> 之类的方法 —— 就可以得到一个 <code>Substring</code> 的实例，而非另外一个 <code>String</code>。Swift 里的 <code>Substring</code> 绝大部分函数都跟 <code>String</code> 一样，意味着你可以使用同样的方式去操作 <code>Substring</code> 和 <code>String</code>。然而，跟 <code>String</code> 不同的是，你只有在短时间内需要操作字符串时，才会使用 <code>Substring</code>。当你需要长时间保存结果时，就把 <code>Substring</code> 转化为 <code>String</code> 的实例：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Hello, world!"</span></span>
<span class="token keyword">let</span> index <span class="token operator">=</span> greeting<span class="token punctuation">.</span><span class="token function">firstIndex</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">","</span></span><span class="token punctuation">)</span> <span class="token operator">??</span> greeting<span class="token punctuation">.</span>endIndex
<span class="token keyword">let</span> beginning <span class="token operator">=</span> greeting<span class="token punctuation">[</span><span class="token operator">..&lt;</span>index<span class="token punctuation">]</span>
<span class="token comment">// beginning 的值为 "Hello"</span>
<span class="token comment">// 把结果转化为 String 以便长期存储。</span>
<span class="token keyword">let</span> newString <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">(</span>beginning<span class="token punctuation">)</span></code></pre>

<p>就像 <code>String</code>，每一个 <code>Substring</code> 都会在内存里保存字符集。而 <code>String</code> 和 <code>Substring</code> 的区别在于性能优化上，<code>Substring</code> 可以重用原 <code>String</code> 的内存空间，或者另一个 <code>Substring</code> 的内存空间（<code>String</code> 也有同样的优化，但如果两个 <code>String</code> 共享内存的话，它们就会相等）。这一优化意味着你在修改 <code>String</code> 和 <code>Substring</code> 之前都不需要消耗性能去复制内存。就像前面说的那样，<code>Substring</code> 不适合长期存储 —— 因为它重用了原 <code>String</code> 的内存空间，原 <code>String</code> 的内存空间必须保留直到它的 <code>Substring</code> 不再被使用为止。</p>
<h3 id="前缀-后缀相等"><a href="#前缀-后缀相等" class="headerlink" title="前缀/后缀相等"></a>前缀/后缀相等</h3><p>通过调用字符串的 <code>hasPrefix(_:)</code>/<code>hasSuffix(_:)</code> 方法来检查字符串是否拥有特定前缀/后缀，两个方法均接收一个 <code>String</code> 类型的参数，并返回一个布尔值。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> string4 <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"i after j"</span></span>
<span class="token function">print</span><span class="token punctuation">(</span>string4<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"i"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>string4<span class="token punctuation">.</span><span class="token function">hasSuffix</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"j"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>string4<span class="token punctuation">.</span><span class="token function">hasSuffix</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"r"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// true</span>
<span class="token comment">// true</span>
<span class="token comment">// false</span></code></pre>



<h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><blockquote>
<p><strong>注意</strong>：</p>
<p>字符串中的 <code>insert(_:at:)</code>、<code>insert(contentsOf:at:)</code>、<code>remove(at:)</code> 和 <code>removeSubrange(_:)</code> 方法在任意一个确认的并遵循 <code>RangeReplaceableCollection</code> 协议的类型里面都可以使用，如上文所示是使用在 <code>String</code> 中，你也可以使用在 <code>Array</code>、<code>Dictionary</code> 和 <code>Set</code> 中。</p>
</blockquote>
<p>所以这里就不加篇幅去举例子了，可以自己去尝试一下</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 创建一个空数组</span>
<span class="token keyword">var</span> someInts<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token comment">// 创建一个带有默认值的数组</span>
<span class="token keyword">var</span> threeDoubles <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> count<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">// threeDoubles 是一种 [Double] 数组，等价于 [0.0, 0.0, 0.0]</span>

<span class="token comment">// 用数组字面量构造数组</span>
<span class="token keyword">var</span> shoppingList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"Eggs"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Milk"</span></span><span class="token punctuation">]</span>

<span class="token comment">// 利用下标来一次改变一系列数据值</span>
shoppingList<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">...</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"Bananas"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Apples"</span></span><span class="token punctuation">]</span>

<span class="token comment">// 移除数组中的最后一项</span>
<span class="token keyword">let</span> apples <span class="token operator">=</span> shoppingList<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 同时遍历每个数据项的值和索引值</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> shoppingList<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Item </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token class-name">String</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">: </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>



<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><strong>集合</strong> 用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以使用集合而不是数组。</p>
<p>Swift 中的集合类型被写为 <code>Set&lt;Element&gt;</code>，这里的 <code>Element</code> 表示集合中允许存储的类型。和数组不同的是，集合没有等价的简化形式。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 创建和构造一个空的集合</span>
<span class="token keyword">var</span> letters <span class="token operator">=</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">Character</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"letters is of type Set&lt;Character&gt; with </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">letters<span class="token punctuation">.</span>count</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> items."</span></span><span class="token punctuation">)</span>
<span class="token comment">// letters is of type Set&lt;Character&gt; with 0 items.</span>

letters<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"a"</span></span><span class="token punctuation">)</span>
<span class="token comment">// letters 现在含有1个 Character 类型的值</span>

letters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token comment">// letters 现在是一个空的 Set，但是它依然是 Set&lt;Character&gt; 类型</span>

<span class="token comment">// 用数组字面量创建集合</span>
<span class="token keyword">var</span> favoriteGenres<span class="token punctuation">:</span> <span class="token class-name">Set</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"Rock"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Classical"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Hip hop"</span></span><span class="token punctuation">]</span>
<span class="token comment">// favoriteGenres 被构造成含有三个初始值的集合</span>

<span class="token comment">// 使用 contains(_:) 方法去检查集合中是否包含一个特定的值</span>
<span class="token function">print</span><span class="token punctuation">(</span>favoriteGenres<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Funk"</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>集合操作</p>
<ul>
<li><p>使用 <code>intersection(_:)</code> 方法根据两个集合的交集创建一个新的集合。</p>
</li>
<li><p>使用 <code>symmetricDifference(_:)</code> 方法根据两个集合不相交的值创建一个新的集合。</p>
</li>
<li><p>使用 <code>union(_:)</code> 方法根据两个集合的所有值创建一个新的集合。</p>
</li>
<li><p>使用 <code>subtracting(_:)</code> 方法根据不在另一个集合中的值创建一个新的集合。</p>
</li>
</ul>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> oddDigits<span class="token punctuation">:</span> <span class="token class-name">Set</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> evenDigits<span class="token punctuation">:</span> <span class="token class-name">Set</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> singleDigitPrimeNumbers<span class="token punctuation">:</span> <span class="token class-name">Set</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>

oddDigits<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>evenDigits<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
oddDigits<span class="token punctuation">.</span><span class="token function">intersection</span><span class="token punctuation">(</span>evenDigits<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// []</span>
oddDigits<span class="token punctuation">.</span><span class="token function">subtracting</span><span class="token punctuation">(</span>singleDigitPrimeNumbers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// [1, 9]</span>
oddDigits<span class="token punctuation">.</span><span class="token function">symmetricDifference</span><span class="token punctuation">(</span>singleDigitPrimeNumbers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// [1, 2, 9]</span></code></pre>



<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><strong>字典</strong> 是一种无序的集合，它存储的是键值对之间的关系，其所有键的值需要是相同的类型，所有值的类型也需要相同。每个值（value）都关联唯一的<em>键</em>（key），键作为字典中这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。你在需要通过标识符（键）访问数据的时候使用字典。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 创建一个空字典</span>
<span class="token keyword">var</span> namesOfIntegers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token comment">// namesOfIntegers 是一个空的 [Int: String] 字典</span>

<span class="token comment">// 用字典字面量创建字典</span>
<span class="token keyword">var</span> airports<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"YYZ"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"Toronto Pearson"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"DUB"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"Dublin"</span></span><span class="token punctuation">]</span>

<span class="token comment">// 给字典添加新的数据项</span>
airports<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"LHR"</span></span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"London"</span></span>

<span class="token comment">// 改变特定键对应的值</span>
airports<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"LHR"</span></span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"London Heathrow"</span></span>
<span class="token comment">// “LHR”对应的值被改为“London Heathrow”</span></code></pre>

<p>作为一种替代下标语法的方式，字典的 <code>updateValue(_:forKey:)</code> 方法可以设置或者更新特定键对应的值。就像上面所示的下标示例，<code>updateValue(_:forKey:)</code> 方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和下标的方式不同，<code>updateValue(_:forKey:)</code> 这个方法返回更新值之前的<em>原值</em>。这样使得你可以检查更新是否成功。</p>
<p><code>updateValue(_:forKey:)</code> 方法会返回对应值类型的可选类型。举例来说：对于存储 <code>String</code> 值的字典，这个函数会返回一个 <code>String?</code> 或者“可选 <code>String</code>”类型的值。如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是 <code>nil</code> ：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> oldValue <span class="token operator">=</span> airports<span class="token punctuation">.</span><span class="token function">updateValue</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Dublin Airport"</span></span><span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"DUB"</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The old value for DUB was </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">oldValue</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">."</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出“The old value for DUB was Dublin.”</span></code></pre>

<p>你也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回对应值类型的可选类型。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选类型，否则将返回 <code>nil</code>：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> airportName <span class="token operator">=</span> airports<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"DUB"</span></span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The name of the airport is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">airportName</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">."</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"That airport is not in the airports dictionary."</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 打印“The name of the airport is Dublin Airport.”</span></code></pre>



<p>还可以使用下标语法通过将某个键的对应值赋值为 <code>nil</code> 来从字典里移除一个键值对：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift">airports<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"APL"</span></span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"Apple Internation"</span></span>
<span class="token comment">// “Apple Internation”不是真的 APL 机场，删除它</span>
airports<span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"APL"</span></span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token nil constant">nil</span>
<span class="token comment">// APL 现在被移除了</span></code></pre>

<p>此外，<code>removeValue(forKey:)</code> 方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有对应值的情况下返回 <code>nil</code>：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> removedValue <span class="token operator">=</span> airports<span class="token punctuation">.</span><span class="token function">removeValue</span><span class="token punctuation">(</span>forKey<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"DUB"</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The removed airport's name is </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">removedValue</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">."</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The airports dictionary does not contain a value for DUB."</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 打印“The removed airport's name is Dublin Airport.”</span></code></pre>



<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><strong>扩展</strong> 可以给一个现有的类，结构体，枚举，还有协议添加新的功能。它还拥有不需要访问被扩展类型源代码就能完成扩展的能力。扩展和 Objective-C 的分类很相似，与 Objective-C 分类不同的是，Swift 扩展是没有名字的。</p>
<p>Swift 中的扩展可以：</p>
<ul>
<li>添加计算型实例属性和计算型类属性</li>
<li>定义实例方法和类方法</li>
<li>提供新的构造器</li>
<li>定义下标</li>
<li>定义和使用新的嵌套类型</li>
<li>使已经存在的类型遵循（conform）一个协议</li>
</ul>
<blockquote>
<p>注意</p>
<p>扩展可以给一个类型添加新的功能，但是不能重写已经存在的功能。</p>
</blockquote>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 使用 extension 关键字声明扩展</span>
<span class="token keyword">extension</span> <span class="token class-name">SomeType</span> <span class="token punctuation">{</span>
  <span class="token comment">// 在这里给 SomeType 添加新的功能</span>
<span class="token punctuation">}</span>

<span class="token comment">// 扩展可以扩充一个现有的类型，给它添加一个或多个协议</span>
<span class="token keyword">extension</span> <span class="token class-name">SomeType</span><span class="token punctuation">:</span> <span class="token class-name">SomeProtocol</span><span class="token punctuation">,</span> <span class="token class-name">AnotherProtocol</span> <span class="token punctuation">{</span>
  <span class="token comment">// 协议所需要的实现写在这里</span>
<span class="token punctuation">}</span></code></pre>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>扩展可以给现有类型添加新的实例方法和类方法。在下面的例子中，给 <code>Int</code> 类型添加了一个新的实例方法叫做 <code>repetitions</code>：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">func</span> <span class="token function-definition function">repetitions</span><span class="token punctuation">(</span>task<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..&lt;</span><span class="token keyword">self</span> <span class="token punctuation">{</span>
            <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token number">3</span><span class="token punctuation">.</span>repetitions <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"Hello!"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// Hello!</span>
<span class="token comment">// Hello!</span>
<span class="token comment">// Hello!</span></code></pre>

<h3 id="可变实例方法"><a href="#可变实例方法" class="headerlink" title="可变实例方法"></a>可变实例方法</h3><p>通过扩展添加的实例方法同样也可以修改（或 <em>mutating（改变）</em>）实例本身。结构体和枚举的方法，若是可以修改 <code>self</code> 或者它自己的属性，则必须将这个实例方法标记为 <code>mutating</code>，就像是改变了方法的原始实现。</p>
<p>在下面的例子中，对 Swift 的 <code>Int</code> 类型添加了一个新的 mutating 方法，叫做 <code>square</code>，它将原始值求平方：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token keyword">self</span> <span class="token operator">*</span> <span class="token keyword">self</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> someInt <span class="token operator">=</span> <span class="token number">3</span>
someInt<span class="token punctuation">.</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// someInt 现在是 9</span></code></pre>



<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><p>扩展可以给现有的类型添加新的下标。下面的例子中，对 Swift 的 <code>Int</code> 类型添加了一个整数类型的下标。下标 <code>[n]</code> 返回从数字右侧开始的第 <code>n</code> 位数字：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
    <span class="token keyword">subscript</span><span class="token punctuation">(</span>digitIndex<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> decimalBase <span class="token operator">=</span> <span class="token number">1</span>
        <span class="token keyword">for</span> <span class="token omit keyword">_</span> <span class="token keyword">in</span> <span class="token number">0</span><span class="token operator">..&lt;</span>digitIndex <span class="token punctuation">{</span>
            decimalBase <span class="token operator">*=</span> <span class="token number">10</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">self</span> <span class="token operator">/</span> decimalBase<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token number">746381295</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token comment">// 返回 5</span>
<span class="token number">746381295</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token comment">// 返回 9</span>
<span class="token number">746381295</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token comment">// 返回 2</span>
<span class="token number">746381295</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token comment">// 返回 7</span></code></pre>

<p>如果操作的 <code>Int</code> 值没有足够的位数满足所请求的下标，那么下标的现实将返回 <code>0</code>，将好像在数字的左边补上了 0：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token number">746381295</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token comment">// 返回 0，就好像你进行了这个请求：</span>
<span class="token number">0746381295</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span></code></pre>



<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的创建和调用"><a href="#函数的创建和调用" class="headerlink" title="函数的创建和调用"></a>函数的创建和调用</h3><pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">isMoreThanTen</span><span class="token punctuation">(</span>count<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> count <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">isMoreThanTen</span><span class="token punctuation">(</span>count<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token function">isMoreThanTen</span><span class="token punctuation">(</span>count<span class="token punctuation">:</span> <span class="token number">24</span><span class="token punctuation">)</span>

<span class="token comment">// 无参函数</span>
<span class="token keyword">func</span> <span class="token function-definition function">myFun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string-literal"><span class="token string">"kobe"</span></span>
<span class="token punctuation">}</span>
</code></pre>



<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myFuncReturnTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"func return test"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">myFuncReturnTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">myFuncReturnTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// func return test</span>
<span class="token comment">// func return test</span>
<span class="token comment">// ()</span></code></pre>



<blockquote>
<p>注意<br>严格上来说，虽然没有返回值被定义，<code>sayGoodbye(_:)</code> 函数依然返回了值。没有定义返回类型的函数会返回特殊的值，叫 <code>Void</code>。它其实是一个空的元组（tuple），没有任何元素，可以写成 <code>()</code>。</p>
</blockquote>
<h3 id="函数参数名"><a href="#函数参数名" class="headerlink" title="函数参数名"></a>函数参数名</h3><p>函数的参数名在各个编程语言中都有不同的特点，OC中的函数参数名是隐含于函数名称中的</p>
<pre class="language-objc" data-language="objc"><code class="language-objc"><span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>getDataFromDataID<span class="token punctuation">:</span><span class="token punctuation">(</span>NSString <span class="token operator">*</span><span class="token punctuation">)</span> dataID <span class="token punctuation">{</span>
  
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token keyword">self</span> getDataFromDataID<span class="token punctuation">:</span><span class="token string">@"1101"</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>

<p>虽然这样很容易推断出该函数的意义，但是当参数多了之后，函数名称变得非常冗长，很吓人，会使人觉得很繁琐，不过看久用多了也就习惯了</p>
<p>在 Java 中，参数名是直接添加到参数列表中的</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getMyData</span><span class="token punctuation">(</span><span class="token class-name">String</span> dataID<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token function">getMyData</span><span class="token punctuation">(</span><span class="token string">"1101"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>Swift 借鉴了这两者的优点，引入了参数内部命名和外部命名的概念，内部命名在函数实现时使用，外部命名在函数调用时使用，如果不设置外部命名，则默认函数参数的外部命名和内部命名相同。</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 多参数函数</span>
<span class="token comment">// 函数体内只有一行代码，省略 return</span>
<span class="token keyword">func</span> <span class="token function-definition function">myFunc1</span><span class="token punctuation">(</span>param1<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> param2<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> param3<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    param1 <span class="token operator">+</span> param2 <span class="token operator">+</span> param3
<span class="token punctuation">}</span>
<span class="token function">myFunc1</span><span class="token punctuation">(</span>param1<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> param2<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> param3<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span>

<span class="token comment">// 添加额外命名</span>
<span class="token keyword">func</span> <span class="token function-definition function">myFunc2</span><span class="token punctuation">(</span>out1 param1<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> out2 param2<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> out3 param3<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    param1 <span class="token operator">+</span> param2 <span class="token operator">+</span> param3
<span class="token punctuation">}</span>
<span class="token function">myFunc2</span><span class="token punctuation">(</span>out1<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> out2<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> out3<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">)</span>

<span class="token comment">// 使用下划线可以省略函数参数外部名称</span>
<span class="token keyword">func</span> <span class="token function-definition function">myFunc3</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> param1<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> param2<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> param3<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    param1 <span class="token operator">+</span> param2 <span class="token operator">+</span> param3
<span class="token punctuation">}</span>
<span class="token function">myFunc3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span></code></pre>



<h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myFunc4</span><span class="token punctuation">(</span>param1<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> param2<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> param3<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token number">88</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    param1 <span class="token operator">+</span> param2 <span class="token operator">+</span> param3
<span class="token punctuation">}</span>
<span class="token function">myFunc4</span><span class="token punctuation">(</span>param1<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token function">myFunc4</span><span class="token punctuation">(</span>param1<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span> param2<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function-definition function">myFunc5</span><span class="token punctuation">(</span>param1<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> param2<span class="token punctuation">:</span> <span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> param3<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    param1 <span class="token operator">+</span> param2 <span class="token operator">+</span> param3
<span class="token punctuation">}</span>
<span class="token function">myFunc5</span><span class="token punctuation">(</span>param1<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> param3<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span></code></pre>



<h3 id="不定数量参数"><a href="#不定数量参数" class="headerlink" title="不定数量参数"></a>不定数量参数</h3><p>在swift中，在某个参数类型后面追加符号 <code>...</code> 就会将此参数设置为数量可变。在函数内部，开发者传递的值会被包装成一个集合类型赋值给对应的参数</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myFunc6</span><span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> count <span class="token keyword">in</span> param <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> count
    <span class="token punctuation">}</span>
    <span class="token function">print</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">myFunc6</span><span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token function">myFunc6</span><span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span></code></pre>



<h3 id="inout输入输出参数"><a href="#inout输入输出参数" class="headerlink" title="inout输入输出参数"></a>inout输入输出参数</h3><p>swift函数中，如果传递的是值类型的参数，那么参数值在传递进去函数内部时会将原值复制为一份常量，且在函数内不可以修改。</p>
<p>错误示范</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myFunc7</span><span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    param <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment">// error: left side of mutating operator isn't mutable: 'param' is a 'let' constant</span>
<span class="token comment">//    param += 1</span></code></pre>

<p>如果需要在函数内部修改传递进去的变量的值，可以将此参数声明为 inout 类型</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myFunc7</span><span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    param <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> para <span class="token operator">=</span> <span class="token number">10</span>
<span class="token function">myFunc7</span><span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token operator">&amp;</span>para<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>para<span class="token punctuation">)</span></code></pre>

<p><code>&amp;</code> 符号传递参数变量的内存地址</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包</strong> 是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的匿名函数（Lambdas）比较相似。</p>
<p>先来看看用闭包怎么表示函数</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myFunc</span><span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> param <span class="token operator">*</span> param
<span class="token punctuation">}</span></code></pre>

<p>用闭包来表示</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> myClosures <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Int</span> <span class="token keyword">in</span>
   <span class="token keyword">return</span> param <span class="token operator">*</span> param
<span class="token punctuation">}</span>
<span class="token function">myFunc</span><span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token function">myClusures</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span></code></pre>

<p>闭包在语法上有这样的标准结构</p>
<p><code>{(参数列表) -&gt; 返回值 in 闭包体}</code></p>
<p>关键字 in 前面为闭包的参数列表和返回值，其书写规则和函数一致，in 后面为闭包体</p>
<p>与函数不一样的是，闭包的返回值是可以省略的，在闭包体中，如果有 return 返回，则闭包会自动将 return 的数据类型作为返回值类型，所以上面的闭包表达式可以简写为</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> myClosures <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>param<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token keyword">in</span>
   <span class="token keyword">return</span> param <span class="token operator">*</span> param
<span class="token punctuation">}</span></code></pre>



<h3 id="闭包用于排序方法"><a href="#闭包用于排序方法" class="headerlink" title="闭包用于排序方法"></a>闭包用于排序方法</h3><p>Swift 标准库提供了名为 <code>sorted(by:)</code> 的方法，它会基于你提供的排序闭包表达式的判断结果对数组中的值（类型确定）进行排序。一旦它完成排序过程，<code>sorted(by:)</code> 方法会返回一个与旧数组类型大小相同类型的新数组，该数组的元素有着正确的排序顺序。原数组不会被 <code>sorted(by:)</code> 方法修改</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"Chris"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Alex"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Ewa"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Barry"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"Daniella"</span></span><span class="token punctuation">]</span>
<span class="token comment">// 提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为 sorted(by:) 方法的参数传入</span>
<span class="token keyword">func</span> <span class="token function-definition function">backward</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> s1<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> s2<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s1 <span class="token operator">&gt;</span> s2
<span class="token punctuation">}</span>
<span class="token keyword">var</span> reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> backward<span class="token punctuation">)</span>
<span class="token comment">// reversedNames 为 ["Ewa", "Daniella", "Chris", "Barry", "Alex"]</span></code></pre>



<h3 id="闭包表达式语法"><a href="#闭包表达式语法" class="headerlink" title="闭包表达式语法"></a>闭包表达式语法</h3><pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token punctuation">{</span> <span class="token punctuation">(</span>parameters<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">return</span> type <span class="token keyword">in</span>
    statements
<span class="token punctuation">}</span></code></pre>

<p>上面的排序例子可以用闭包进行简化</p>
<pre class="language-swift" data-language="swift"><code class="language-swift">reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>s1<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span> s2<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span> <span class="token keyword">in</span>
    <span class="token keyword">return</span> s1 <span class="token operator">&gt;</span> s2
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>



<h3 id="根据上下文推断类型"><a href="#根据上下文推断类型" class="headerlink" title="根据上下文推断类型"></a>根据上下文推断类型</h3><p>因为排序闭包函数是作为 <code>sorted(by:)</code> 方法的参数传入的，Swift 可以推断其参数和返回值的类型。<code>sorted(by:)</code> 方法被一个字符串数组调用，因此其参数必须是 <code>(String, String) -&gt; Bool</code> 类型的函数。这意味着 <code>(String, String)</code> 和 <code>Bool</code> 类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（<code>-&gt;</code>）和围绕在参数周围的括号也可以被省略：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift">reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token punctuation">{</span> s1<span class="token punctuation">,</span> s2 <span class="token keyword">in</span> <span class="token keyword">return</span> s1 <span class="token operator">&gt;</span> s2 <span class="token punctuation">}</span> <span class="token punctuation">)</span></code></pre>



<h3 id="参数名称缩写"><a href="#参数名称缩写" class="headerlink" title="参数名称缩写"></a>参数名称缩写</h3><p>Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 <code>$0</code>，<code>$1</code>，<code>$2</code> 来顺序调用闭包的参数，以此类推。</p>
<p>如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。闭包接受的参数的数量取决于所使用的缩写参数的最大编号。<code>in</code> 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift">reversedNames <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>by<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token short-argument">$0</span> <span class="token operator">&gt;</span> <span class="token short-argument">$1</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span></code></pre>



<h3 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>如果你需要将一个很长的闭包表达式作为最后一个参数传递给函数，将这个闭包替换成为尾随闭包的形式很有用。尾随闭包是一个书写在函数圆括号之后的闭包表达式，函数支持将其作为最后一个参数调用。在使用尾随闭包时，你不用写出它的参数标签：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">// 以下是不使用尾随闭包进行函数调用</span>
<span class="token function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 以下是使用尾随闭包进行函数调用</span>
<span class="token function">someFunctionThatTakesAClosure</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span></code></pre>



<h3 id="逃逸闭包"><a href="#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中<em>逃逸</em>。当你定义接受闭包作为参数的函数时，你可以在参数名之前标注 <code>@escaping</code>，用来指明这个闭包是允许“逃逸”出这个函数的。</p>
<p>一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。举个例子，很多启动异步操作的函数接受一个闭包参数作为 completion handler。这类函数会在异步操作开始之后立刻返回，但是闭包直到异步操作结束后才会被调用。在这种情况下，闭包需要“逃逸”出函数，因为闭包需要在函数返回之后被调用。例如：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">var</span> completionHandlers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">func</span> <span class="token function-definition function">someFunctionWithEscapingClosure</span><span class="token punctuation">(</span>completionHandler<span class="token punctuation">:</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    completionHandlers<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>completionHandler<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>



<h3 id="自动闭包"><a href="#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p>swift 中有一种语法，可以实现对简单闭包的自动生成，这种闭包通常被称为自动闭包，自动闭包的参数的使用有严格条件的，首先此闭包不能够有参数，其次在调用参数传参时，闭包的实现只能由一句表达式组成，闭包的返回值即为此表达式的值，自动闭包参数由 <code>@autoclosure</code> 来声明</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// 将闭包参数声明为自动闭包</span>
<span class="token keyword">func</span> <span class="token function-definition function">myFunc</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token attribute atrule">@autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token punctuation">)</span></code></pre>

<p>自动闭包默认是非逃逸的，如果要使用逃逸类型的闭包参数，需要声明如下</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">myFunc</span><span class="token punctuation">(</span>closure<span class="token punctuation">:</span> <span class="token attribute atrule">@autoclosure</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span></code></pre>



<h2 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h2><p><strong>Swift 中结构体和类有很多共同点。两者都可以：</strong></p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义下标操作用于通过下标语法访问它们的值</li>
<li>定义构造器用于设置初始值</li>
<li>通过扩展以增加默认实现之外的功能</li>
<li>遵循协议以提供某种标准功能</li>
</ul>
<p><strong>与结构体相比，类还有如下的附加功能：</strong></p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>析构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用</li>
</ul>
<h3 id="结构体类型的成员逐一构造器"><a href="#结构体类型的成员逐一构造器" class="headerlink" title="结构体类型的成员逐一构造器"></a>结构体类型的成员逐一构造器</h3><p>所有结构体都有一个自动生成的 <strong>成员逐一构造器</strong>，用于初始化新结构体实例中成员的属性。新实例中各个属性的初始值可以通过属性的名称传递到成员逐一构造器之中：</p>
<pre class="language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> vga <span class="token operator">=</span> <span class="token class-name">Resolution</span><span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token number">640</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">480</span><span class="token punctuation">)</span></code></pre>

<p>与结构体不同，类实例没有默认的成员逐一构造器</p>
<p>注意：<strong>结构体和枚举是值类型，类是引用类型</strong></p>
<h3 id="恒等运算符"><a href="#恒等运算符" class="headerlink" title="恒等运算符"></a>恒等运算符</h3><p>因为类是引用类型，所以多个常量和变量可能在幕后同时引用同一个类实例。（对于结构体和枚举来说，这并不成立。因为它们作为值类型，在被赋予到常量、变量或者传递到函数时，其值总是会被拷贝。）</p>
<p>判定两个常量或者变量是否引用同一个类实例有时很有用。为了达到这个目的，Swift 提供了两个恒等运算符：</p>
<ul>
<li>相同（<code>===</code>）</li>
<li>不相同（<code>!==</code>）</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo：为next主题添加评论系统</title>
    <url>/2022/02/11/hexo-%E4%B8%BAnext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="为hexo的next主题添加评论系统，就能在评论区和网友激情对线了-doge"><a href="#为hexo的next主题添加评论系统，就能在评论区和网友激情对线了-doge" class="headerlink" title="为hexo的next主题添加评论系统，就能在评论区和网友激情对线了[doge]"></a>为hexo的next主题添加评论系统，就能在评论区和网友激情对线了[doge]</h3><p>早就想为自己的博客添加一个评论系统了，能在评论区发表自己的所思所得，还能和网友激情对线，想想都刺激。</p>
<p>还要清楚的是，Valine 评论系统在 Next 主题高版本 (7.+) 以上已没有支持，且 Valine 已经很久没有更新维护了。不过，有大佬在 Valine 的基础之上开发了 <a href="https://waline.js.org/">Waline</a> 。还有Gitment最新版next也不支持了。</p>
<p>这次，我们添加的是能够快速上手安装，配置更加人性化且带后端的 <a href="https://waline.js.org/">Waline</a> 评论系统</p>
<span id="more"></span>

<h4 id="1-配置数据库"><a href="#1-配置数据库" class="headerlink" title="1.配置数据库"></a>1.配置数据库</h4><p>我们需要注册一个 <a href="https://console.leancloud.app/register">Leancloud 国际版 </a>的账号，注意，一定要是 <strong>国际版</strong>，国内版需要绑定备案的域名，比较麻烦。具体可以在注册时的左上角看到：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9fwq8jjqj32p90u0wi2.jpg" style="zoom: 15%;">

<p>注册完成后，登录，然后我们找到<code>创建应用</code><br>在这里填写你的应用名称,名称可以自己定义，然后，下面选择<code>开发版</code> 点击<code>创建</code>。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9gaaylmmj31310u0tb4.jpg" style="zoom:25%;">

<p>然后点击设置，进入应用凭证页面，取得我们 <code>AppKey</code> 、<code>App id</code> 、以及 <code>MasterKey</code> ：</p>
<p>数据库配置完毕，接下来安装服务端。</p>
<h4 id="2-安装服务端"><a href="#2-安装服务端" class="headerlink" title="2.安装服务端"></a>2.安装服务端</h4><p><code>Waline</code> 支持多种服务端，这里我们使用第一种方式，即在 <code>Vercl</code> 上安装服务端。</p>
<p><a href="https://vercel.com/import/project?template=https://github.com/walinejs/waline/tree/main/example"><img src="https://vercel.com/button" alt="Vercel"></a></p>
<p>点击上方按钮，跳转至 Vercel 进行 Server 端部署。</p>
<p>如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9gidu3i3j310c0u0mz2.jpg" style="zoom:25%;">

<p><code>GIT POST</code>那里绑定你的<code>github</code>账号，第二栏输入一个你喜欢的 Vercel 项目名称并点击 <code>Create</code> 继续，等待一小会时间</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9go73rbij314z0u0q5i.jpg" style="zoom:25%;">

<p>创建成功还会有烟花，嗯，不错</p>
<img src="/Users/onlybei/Library/Application Support/typora-user-images/image-20220211123356740.png" alt="image-20220211123356740" style="zoom:10%;">

<p>点击 <code>Go to Dashboard</code>，点击顶部的 <code>Settings</code> - <code>Environment Variables</code> 进入环境变量配置页，并配置三个环境变量<code>LEAN_ID</code>, <code>LEAN_KEY</code> 和 <code>LEAN_MASTER_KEY</code> 。它们的值分别对应上一步在 LeanCloud 中获得的 <code>APP ID</code>, <code>APP KEY</code>, <code>Master Key</code>。</p>
<img src="/Users/onlybei/Library/Application Support/typora-user-images/image-20220211124013867.png" alt="image-20220211124013867" style="zoom:20%;">

<blockquote>
<p>提示</p>
<p>如果你使用 LeanCloud 国内版，请额外配置 <code>LEAN_SERVER</code> 环境变量，值为你绑定好的域名。</p>
</blockquote>
<p>环境变量配置完成之后点击顶部的 <code>Deployments</code> 点击顶部最新的一次部署右侧的 <code>Redeploy</code> 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。</p>
<p>此时会跳转到 <code>Overview</code> 界面开始部署，等待片刻后 <code>STATUS</code> 会变成 <code>Ready</code>。此时请点击 <code>Visit</code> ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。</p>
<h4 id="3-在Hexo-Next主题中配置"><a href="#3-在Hexo-Next主题中配置" class="headerlink" title="3. 在Hexo Next主题中配置"></a>3. 在Hexo Next主题中配置</h4><p>由于 Next 主题中并不自带 <code>Waline</code> 的评论配置，我们需要安装官方提供的插件。在 <code>Hexo</code> 根目录执行：</p>
<pre class="language-none"><code class="language-none">npm install @waline/hexo-next</code></pre>

<p>找到 Next 的主题配置文件，在最后加上，记得修改servarURL</p>
<pre class="language-none"><code class="language-none"># Waline
# For more information: https://waline.js.org, https://github.com/walinejs/waline
waline:
  enable: true #是否开启
  serverURL: waline-server-pearl.vercel.app # Waline #服务端地址，我们这里就是上面部署的 Vercel 地址
  placeholder: 请文明评论呀 # #评论框的默认文字
  avatar: mm # 头像风格
  meta: [nick, mail, link] # 自定义评论框上面的三个输入框的内容
  pageSize: 10 # 评论数量多少时显示分页
  lang: zh-cn # 语言, 可选值: en, zh-cn
  # Warning: 不要同时启用 `waline.visitor` 以及 `leancloud_visitors`.
  visitor: false # 文章阅读统计
  comment_count: true # 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示
  requiredFields: [] # 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]
  libUrl: # Set custom library cdn url</code></pre>

<p>重新部署 <code>Hexo</code> ，就可以看到结果了。</p>
<h4 id="4-登录管理端"><a href="#4-登录管理端" class="headerlink" title="4. 登录管理端"></a>4. 登录管理端</h4><p>由于 <code>Waline</code> 有服务端，支持评论管理。我们需要注册一个账号作为管理员。</p>
<p>找到评论框，点击 <code>登录</code> 按钮，会弹出一个窗口，找到用户注册，默认第一个注册的用户为管理员，所以部署好一定要记得及时注册。注册好了之后，登录之后即可进入评论管理的后台，可以对评论进行管理。</p>
<h4 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h4><h5 id="5-1-自定义头像"><a href="#5-1-自定义头像" class="headerlink" title="5.1 自定义头像"></a>5.1 自定义头像</h5><p>参考：<a href="https://waline.js.org/guide/client/avatar.html">头像配置 | Waline</a></p>
<blockquote>
<p> 注意：官方头像配置教程已过时，需要在服务端进行设置</p>
<p>已过时</p>
<p>建议配合最新版本的服务端，通过服务端的 <code>AVATAR_PROXY</code> 配置。</p>
</blockquote>
<p>在服务器设置中添加<code>AVATAR_PROXY</code>和<code>GRAVATAR_STR</code>设置，记得value要添加上默认的值，然后注册 <a href="https://www.libravatar.org/">Libravatar</a>账号，可以上传自己的喜欢的头像。</p>
<h5 id="5-2-参考"><a href="#5-2-参考" class="headerlink" title="5.2 参考"></a>5.2 参考</h5><p><a href="https://waline.js.org/guide/get-started.html">快速入门 ｜ Waline</a></p>
<p><a href="https://waline.js.org/reference/server.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">服务器配置 | Waline</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题切换样式问题</title>
    <url>/2022/04/03/hexo%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E6%A0%B7%E5%BC%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="hexo-主题切换样式问题及解决方法"><a href="#hexo-主题切换样式问题及解决方法" class="headerlink" title="hexo 主题切换样式问题及解决方法"></a>hexo 主题切换样式问题及解决方法</h3><p>在 hexo 不同主题直接切换的时候，上一个主题编译好的文件可能会影响到下一个主题的样式。原因就是因为使用了一个主题，这个主题的 css 样式会被引入到 public 的 css 文件夹中。</p>
<p>但是换了主题的时候，之前的主题编译的 css 还在 public 中，也就是说 hexo 只是更新了主题和重新编译了本地文件，并没有将重新编译的 public 文件更新到 github 的 page 页面上，所以造成了本地和线上的样式不一样。</p>
<span id="more"></span>

<p>可以看到，只用 hexo c、hexo g -d 的效果是这样，注意 css 文件的更新时间。无论怎么 hexo d，css 还是不更新嗷。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0wgqofijzj21jm0u0wjk.jpg"></p>
<p>但是要将重新编译好的本地文件更新到 github 上面怎么办，可以在 github 的 hexo 仓库新建一个分支，在 hexo 根目录下的配置文件里面更改一下推送的分支，然后再改回来原来的分支，就可以了（不改回来用新的分支也可以）</p>
<p>![image-20220403132522105](/Users/onlybei/Library/Application Support/typora-user-images/image-20220403132522105.png)</p>
<p>这样操作之后，可以看到 css 文件更新了</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0wgxzaddvj21550u0ae3.jpg"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>OC纯代码仿写微信首页记录文档</title>
    <url>/2022/08/20/Week4_1%EF%BC%9AOC%E4%BB%BF%E5%BE%AE%E4%BF%A1%E9%A1%B5%E9%9D%A2%E8%AE%B0%E5%BD%95%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="OC纯代码仿写微信首页记录文档"><a href="#OC纯代码仿写微信首页记录文档" class="headerlink" title="OC纯代码仿写微信首页记录文档"></a>OC纯代码仿写微信首页记录文档</h2><p>[toc]</p>
<h3 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0.前置知识"></a>0.前置知识</h3><ul>
<li>视图和控件</li>
</ul>
<p>大致了解iOS 中的视图和控件的作用，<a href="https://developer.apple.com/cn/documentation/uikit/views_and_controls/">苹果官方文档</a></p>
<p>一般APP的界面结构就是使用 导航栏 + 根视图+ 标签栏 构成的。</p>
<p><code>UIWindow</code> 是一种特殊的 UIView，通常在一个 app 中只会有一个 UIWindow，iOS 程序启动完毕后，创建的第一个视图控件就是 UIWindow，接下来再创建其他控件。所以在 AppDelegate 中的 didFinishLaunchingWithOptions 方法中，先创建 UIwindow，再创建控制器，创建控制器的 view，然后将控制器的 view 添加到 UIWindow 上。</p>
<p><code>UITabBarController </code> 选项卡控制器，与导航控制器一样，也被广泛用于各种ios应用程序。顾名思义，选项卡控制器在屏幕底部显示一系 “选项卡”，这些选项卡表示为图标和文本，用户触摸它们将在不同的场景间切换。和 UINavigationController 类似，UITabBarController 也可以用来控制多个页面导航，用户可以在多个视图控制器之间移动，并可以定制屏幕底部的选项卡栏。</p>
<p><code>UINavigationController</code> 栈视图控制器，它必须设置一个 RootViewController 根控制器，页面跳转时，通过它将下一个子 ViewController 的视图添加到RootViewController 的视图中。</p>
<span id="more"></span>

<ul>
<li>容器之间的关系图</li>
</ul>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h47q0rszlej20ek0mj758.jpg" style="zoom:100%;">





<h3 id="1-删除-Main-StoryBoard"><a href="#1-删除-Main-StoryBoard" class="headerlink" title="1.删除 Main.StoryBoard"></a>1.删除 Main.StoryBoard</h3><p>可以查看以下文档对 Main.StoryBoard 进行删除</p>
<p><a href="https://futu.lexiangla.com/teams/k100057/docs/47f56f8efe9611ecbf4b36fe418170f4?company_from=futu">OC删除故事板进行纯代码布局</a></p>
<h3 id="2-确定项目结构"><a href="#2-确定项目结构" class="headerlink" title="2. 确定项目结构"></a>2. 确定项目结构</h3><p>先是创建一个 window，这个 window 的 rootViewController 是 UINavigationController，用于控制页面的跳转。UINavigationController 的 rootViewController 是一个 UITabBarController，用于控制首页各页面直接的切换。</p>
<p>项目目录结构如下：</p>
<pre class="language-apl" data-language="apl"><code class="language-apl"><span class="token dyadic-operator operator">.</span>
├── AddressListViewController<span class="token dyadic-operator operator">.</span>h <span class="token monadic-operator operator">/</span><span class="token monadic-operator operator">/</span> 通讯录页
├── AddressListViewController<span class="token dyadic-operator operator">.</span>m
├── AppDelegate<span class="token dyadic-operator operator">.</span>h
├── AppDelegate<span class="token dyadic-operator operator">.</span>m
├── DiscoverViewController<span class="token dyadic-operator operator">.</span>h <span class="token monadic-operator operator">/</span><span class="token monadic-operator operator">/</span> 发现页
├── DiscoverViewController<span class="token dyadic-operator operator">.</span>m
├── Info<span class="token dyadic-operator operator">.</span>plist
├── MeViewController<span class="token dyadic-operator operator">.</span>h <span class="token monadic-operator operator">/</span><span class="token monadic-operator operator">/</span> 我
├── MeViewController<span class="token dyadic-operator operator">.</span>m
├── ViewController<span class="token dyadic-operator operator">.</span>h
├── ViewController<span class="token dyadic-operator operator">.</span>m
├── WeChatViewController<span class="token dyadic-operator operator">.</span>h <span class="token monadic-operator operator">/</span><span class="token monadic-operator operator">/</span> 微信页
├── WeChatViewController<span class="token dyadic-operator operator">.</span>m
└── main<span class="token dyadic-operator operator">.</span>m</code></pre>



<p> AppDelegate 中的 didFinishLaunchingWithOptions 的方法</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">// 1.创建UIWindow
self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

// 设置UIWindow的背景颜色
self.window.backgroundColor = [UIColor whiteColor];

UITabBarController *tabBar = [[UITabBarController alloc] init];

UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:tabBar];

self.window.rootViewController = nav;


[[UITabBar appearance] setBackgroundColor:[UIColor systemGray5Color]];

UIViewController *c1 = [[WeChatViewController alloc] init];

UIViewController *c2 = [[AddressListViewController alloc] init];
c2.tabBarItem.title = @"通讯录";
c2.tabBarItem.image=[UIImage imageNamed:@"people.png"];

UIViewController *c3 = [[DiscoverViewController alloc]init];
c3.tabBarItem.title = @"发现";
c3.tabBarItem.image=[UIImage imageNamed:@"discover.png"];

UIViewController *c4 = [[MeViewController alloc]init];
c4.tabBarItem.title = @"我";
c4.tabBarItem.image = [UIImage imageNamed:@"me.png"];

// 将视图添加到tabBar上
tabBar.viewControllers = @[c1, c2, c3, c4];
//    [tabBar addChildViewController:c1];
//    [tabBar addChildViewController:c2];
//    [tabBar addChildViewController:c3];
//    [tabBar addChildViewController:c4];

[self.window makeKeyAndVisible];
</code></pre>



<p>AddressListViewController.m 文件</p>
<pre class="language-objective-c" data-language="objective-c"><code class="language-objective-c">#import "AddressListViewController.h"

@interface AddressListViewController ()&lt;UITableViewDataSource, UITableViewDelegate&gt;

@property (nonatomic, copy) NSArray *arr;

@end

@implementation AddressListViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // Do any additional setup after loading the view.
    
    self.arr = @[@"科比", @"詹姆斯", @"欧文", @"乔丹", @"科比", @"詹姆斯", @"欧文", @"乔丹", @"科比", @"詹姆斯", @"欧文", @"乔丹", @"科比", @"詹姆斯", @"欧文", @"乔丹", @"科比", @"詹姆斯", @"欧文", @"乔丹", @"科比", @"詹姆斯", @"欧文", @"乔丹", @"乔丹", @"科比", @"詹姆斯", @"欧文", @"乔丹"];
   
    // 创建UItableView，style选择Grouped或Plain，这里我们以Grouped为例
    UITableView *tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height - 20) style:UITableViewStyleGrouped];
    // 声明 tableView 的代理和数据源
    tableView.delegate = self;
    tableView.dataSource = self;
    tableView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag;
    
    tableView.backgroundView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"people.png"]];
    
    UISearchBar *search = [[UISearchBar alloc] initWithFrame:CGRectMake(0, 0, self.view.frame.size.width, 40)];
    search.searchBarStyle = UISearchBarStyleMinimal;
    search.searchTextField.text = @"请输入要搜索的联系人";
    
    // 添加到 view 上
    [self.view addSubview:tableView];
    [tableView addSubview:search];
    
}

// tableView 中 Section 的个数
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    return 1;
}

// 每个 Section 中的 Cell 个数
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return 22;
}

// 设置 cell 的高度
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    return 55;
}

// cell 的文字缩进
- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath {
    return 0;
}

// 选中了 cell 时触发
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    NSLog(@"选中了第%li个cell", (long)indexPath.row);
    UIViewController *detailView = [[UIViewController alloc]init];
    NSString *title = self.arr[indexPath.row];
    detailView.title = title;
    detailView.view.backgroundColor = [UIColor systemGray3Color];
    [self.navigationController pushViewController:detailView animated:YES];//跳转到下一界面
}

// 设置 cell 是否允许左滑
- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath {
    return true;
}

// 设置默认的左滑按钮的title
- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath {
    return @"删除";
}

// 点击左滑出现的按钮时触发
- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath {
    NSLog(@"点击左滑出现的按钮时触发");
}

// 左滑结束时调用(只对默认的左滑按钮有效，自定义按钮时这个方法无效)
- (void)tableView:(UITableView *)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath {
    NSLog(@"左滑结束");
}

// 设置每个 Cell
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    // 创建一个cellID，用于cell的重用
    NSString *cellID = @"cellID";
    // 从tableview的重用池里通过cellID取一个cell
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellID];
    if (cell == nil) {
         // 如果tableview的重用池中没有取到，就创建一个新的cell，style为Value2，并用cellID对其进行标记。
        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellID];
    }
    // 设置 cell 的标题
    cell.textLabel.text = [NSString stringWithFormat:@"%@", self.arr[(long)indexPath.row]];
    
    // cell右侧的效果
    cell.accessoryType =  UITableViewCellAccessoryDisclosureIndicator;
    
    cell.imageView.image = [UIImage imageNamed:@"me.png"];
    
    return cell;
}

@end
</code></pre>



<h3 id="3-查看页面布局"><a href="#3-查看页面布局" class="headerlink" title="3.查看页面布局"></a>3.查看页面布局</h3><p>纯代码布局时，页面容器、控件直接的层级关系呈现的不直接，可以利用 Xcode 的自带功能查看</p>
<p>Debug -&gt; View Debugging -&gt; Capture View Hierarchy</p>
<p>![image-20220715155133669](/Users/admin/Library/Application Support/typora-user-images/image-20220715155133669.png)</p>
<h3 id="4-遇到的问题："><a href="#4-遇到的问题：" class="headerlink" title="4.遇到的问题："></a>4.遇到的问题：</h3><ol>
<li><p>tabBar 除第一个外其他的底部选项卡的图标和 title 没有加载出来。</p>
<p>如图所示：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h47qvnekntj20jq03g746.jpg" style="zoom:50%;">

<p>原因：对于 viewDidLoad 方法具体执行时间不清楚。虽然 AppDelegate 里面调用了该标签栏的页面，生成了实例，但是 viewDidLoad 方法还没执行，所以在实例方法里面定义的 tabBar 属性在 App 第一次加载的时候还没开始执行，对应的页面也没有显示出来。</p>
<p>解决方法：将除第一个选项卡的 tabBar 属性写在 AppDelegate 里面</p>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo：使用matery主题对博客进行美化</title>
    <url>/2022/02/16/hexo-%E4%BD%BF%E7%94%A8matery%E4%B8%BB%E9%A2%98%E5%AF%B9%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h1 id="使用-matery-主题搭建很好看的博客页面"><a href="#使用-matery-主题搭建很好看的博客页面" class="headerlink" title="使用 matery 主题搭建很好看的博客页面"></a>使用 <code>matery</code> 主题搭建很好看的博客页面</h1><p>因为最近看到一位腾讯大佬 <a href="https://yangchaoyi.vip/">一百个Chocolate</a> 的个人博客，使用的也是 <code>matery</code> 主题，而且用了 <a href="https://mazhuang.org/wiki/chinese-copywriting-guidelines/">中文文案排版指北 (简体中文版)</a>  对博客文章进行排版，第一眼感觉非常惊艳，这样的博客看起来很舒服，所以自己也想向大佬看齐。</p>
<p>一下如无特别说明，以下配置文件都是 <code>matery</code> 主题下的 <code>_config.yml</code> </p>
<span id="more"></span>

<h2 id="下载（最好下载master分支最新稳定版的代码）"><a href="#下载（最好下载master分支最新稳定版的代码）" class="headerlink" title="下载（最好下载master分支最新稳定版的代码）"></a>下载（最好下载master分支最新稳定版的代码）</h2><p>本主题<strong>推荐你使用 Hexo 5.0.0 及以上的版本</strong>。如果，你已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了，建议你将 Hexo 升级到最新稳定的版本。</p>
<p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。（用这种方式下载的文件夹名字是 <code>hexo-theme-matery-master</code>，需要改成 <code>hexo-theme-matery</code> 再复制到 Hexo 的 <code>themes</code> 文件夹中）</p>
<p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>git clone</code> 命令来下载:</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p>
<h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul>
<li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li>
<li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li>
<li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li>
</ul>
<h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "categories"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: categories
date: 2018-09-30 17:25:30
type: "categories"
layout: "categories"
---</code></pre>



<h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "tags"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: tags
date: 2018-09-30 18:23:38
type: "tags"
layout: "tags"
---</code></pre>



<h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "about"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: about
date: 2018-09-30 17:25:30
type: "about"
layout: "about"
---</code></pre>



<h3 id="新建留言板-contact-页（可选的）"><a href="#新建留言板-contact-页（可选的）" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h3><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "contact"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: contact
date: 2018-09-30 17:25:30
type: "contact"
layout: "contact"
---</code></pre>

<blockquote>
<p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p>
</blockquote>
<h3 id="新建友情链接-friends-页（可选的）"><a href="#新建友情链接-friends-页（可选的）" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "friends"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: friends
date: 2018-12-12 21:25:30
type: "friends"
layout: "friends"
---</code></pre>

<p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p>
<pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>
    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>
    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>
    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>
    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>
    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>
    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>
    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>
    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>
    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>
    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre>



<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p>
<p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>{</code> 和 <code>}</code> 的转义字符。</p>
<p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>
  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">prismjs</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span></code></pre>

<p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p>
<h3 id="中文链接转拼音（建议安装，否则底部的文章链接很乱）"><a href="#中文链接转拼音（建议安装，否则底部的文章链接很乱）" class="headerlink" title="中文链接转拼音（建议安装，否则底部的文章链接很乱）"></a>中文链接转拼音（建议安装，否则底部的文章链接很乱）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p>
<p>安装命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">npm i hexo-permalink-pinyin --save</code></pre>

<p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>

  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span>
</code></pre>

<p>之后再将 Hexo 根目录下的 <code>_config.yml</code> 文件下的 url 改为自己的站点首地址</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># URL</span>
<span class="token comment">## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'</span>
<span class="token key atrule">url</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//danonlylane.github.io <span class="token comment"># default: http://example.com</span>
<span class="token key atrule">permalink</span><span class="token punctuation">:</span> <span class="token punctuation">:</span>year/<span class="token punctuation">:</span>month/<span class="token punctuation">:</span>day/<span class="token punctuation">:</span>title/
<span class="token key atrule">permalink_defaults</span><span class="token punctuation">:</span>
<span class="token key atrule">pretty_urls</span><span class="token punctuation">:</span>
  <span class="token key atrule">trailing_index</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># Set to false to remove trailing 'index.html' from permalinks</span>
  <span class="token key atrule">trailing_html</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># Set to false to remove trailing '.html' from permalinks</span></code></pre>

<blockquote>
<p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p>
</blockquote>
<h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p>
<p>安装命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">npm i --save hexo-wordcount</code></pre>

<p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>
  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true.</span>
  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true.</span>
  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长.</span>
  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数.</span></code></pre>



<h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p>
<pre class="language-none"><code class="language-none">npm install hexo-filter-github-emojis --save</code></pre>

<p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p>
<pre class="language-none"><code class="language-none">githubEmojis:
  enable: true
  className: github-emoji
  inject: true
  styles:
  customEmojis:</code></pre>

<p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js之this</title>
    <url>/2022/04/06/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E4%B9%8Bthis/</url>
    <content><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>为什么需要 this ？</p>
<p>来看一下下面两段代码</p>
<p>先看不使用 this 的</p>
<span id="more"></span>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">identify</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> context<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token string">"Hello, I'm "</span> <span class="token operator">+</span> <span class="token function">identify</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> me <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"Kyle"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> you <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"Reader"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">identify</span><span class="token punctuation">(</span>you<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// READER</span>
<span class="token function">speak</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//hello, 我是 KYLE</span></code></pre>

<p>再看使用 this 的</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">identify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> greeting <span class="token operator">=</span> <span class="token string">"Hello, I'm "</span> <span class="token operator">+</span> <span class="token function">identify</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
  	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> me <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"Kyle"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> you <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">"Reader"</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">identify</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// KYLE</span>
<span class="token function">identify</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>you<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// READER</span>
<span class="token function">speak</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>me<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello, 我是 KYLE </span>
<span class="token function">speak</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>you<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Hello, 我是 READER</span></code></pre>

<p>也就是说 this 提供了一种更优雅的方式来隐式“传递”一个对象引用，是我们的代码可以更加灵活和易于维护</p>
<p>this 不是什么？</p>
<ul>
<li><p>this 不一定指向函数自身</p>
</li>
<li><p>this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的，需要明确的是，this 在任何情况下都不指向函数的词法作用域，在 JavaScript 内部，作用 域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。</p>
</li>
</ul>
<p>this 是什么？</p>
<ul>
<li> this 是在运行时进行绑定</li>
<li>this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式</li>
<li>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包 含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到</li>
</ul>
<h3 id="this-绑定规则"><a href="#this-绑定规则" class="headerlink" title="this 绑定规则"></a>this 绑定规则</h3><h4 id="默认绑定："><a href="#默认绑定：" class="headerlink" title="默认绑定："></a>默认绑定：</h4><p>首先要介绍的是最常用的函数调用类型: 独立函数调用，也就是默认绑定。可以把这条规则看作是无法应用其他规则时的默认规则。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></code></pre>

<p>需要注意的是，默认绑定在严格模式下会无效</p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>隐式绑定需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token operator">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></code></pre>

<p>需要注意的是隐式绑定丢失</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token operator">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"oops, global"</span><span class="token punctuation">;</span> <span class="token comment">// a 是全局对象的属性 </span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "oops, global"</span></code></pre>

<p>JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似:</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">**</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	<span class="token comment">// 等待 delay 毫秒</span>
 	<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 调用位置!</span>
<span class="token punctuation">}</span></code></pre>

<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>通过 call、apply、bind 进行绑定</p>
<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>通过 new 关键字创建新实例时进行的 this 绑定</p>
<h4 id="this-绑定的优先级"><a href="#this-绑定的优先级" class="headerlink" title="this 绑定的优先级"></a>this 绑定的优先级</h4><p>new &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<p>⚠️ 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p>
<p>比如</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span></code></pre>

]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始搭建hexo博客</title>
    <url>/2022/01/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="用Hexo-快速搭建属于自己的博客"><a href="#用Hexo-快速搭建属于自己的博客" class="headerlink" title="用Hexo 快速搭建属于自己的博客"></a>用Hexo 快速搭建属于自己的博客</h1><h3 id="环境准备（安装方法自行查阅网上资料）"><a href="#环境准备（安装方法自行查阅网上资料）" class="headerlink" title="环境准备（安装方法自行查阅网上资料）"></a>环境准备（安装方法自行查阅网上资料）</h3><ul>
<li>git</li>
<li>node</li>
<li>npm</li>
</ul>
<p>命令行里验证是否安装成功</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">git</span> --version
<span class="token function">git</span> version <span class="token number">2.30</span>.1 <span class="token punctuation">(</span>Apple Git-130<span class="token punctuation">)</span>

$ node --version
v16.4.2

$ <span class="token function">npm</span> -v
<span class="token number">7.18</span>.1</code></pre>

<span id="more"></span>

<h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>如果第一次用git工具，记得配置一下SSH key，为部署本地博客到 Github 做准备。</p>
<p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token function">git</span> config --global user.name <span class="token string">"GitHub用户名"</span>
<span class="token function">git</span> config --global user.email <span class="token string">"注册GitHub邮箱地址"</span></code></pre>

<p>生成密钥SSK key</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">ssh-keygen -t rsa -C <span class="token string">'上面的邮箱地址'</span></code></pre>

<p>输入上面的命令之后，按下三次回车，即可生成ssh key。<code>.ssh</code>目录下有两个文件，<code>id_rsa</code>和<code>id_rsa.pub</code>，这两个就是ssh key的密钥对，<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥</p>
<p>cat获取你的ssh</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token function">cat</span> ~/.ssh/id_rsa.pub</code></pre>

<p>复制输出内容</p>
<p>登录github，settings -&gt; SSH and GPG keys -&gt; New SSH key</p>
<p>Title随便写</p>
<p>Key填写刚才复制的内容，确认完成。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>执行命令</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli	<span class="token comment"># -g 代表着全局安装</span></code></pre>

<p>完成后建立自己的个人博客</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ hexo init blogName
$ <span class="token builtin class-name">cd</span> blogName
$ <span class="token function">npm</span> <span class="token function">install</span></code></pre>

<h3 id="创建你的第一篇博文"><a href="#创建你的第一篇博文" class="headerlink" title="创建你的第一篇博文"></a>创建你的第一篇博文</h3><p>新建一篇博文：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ hexo new <span class="token string">'blogName'</span></code></pre>

<p>在 <code>/source/_posts</code>文件夹下找到你的博文，使用typora（推荐）打开并编辑。</p>
<p>保存后运行：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ hexo generate <span class="token comment"># 生成静态文件，可简写为 hexo g</span>
$ hexo server <span class="token comment"># 启动服务器。默认情况下，访问网址为：http://localhost:4000/。可以简写为 hexo s</span></code></pre>

<p>此时已经可以在<code>public</code>文件夹下看到完整的静态文件。<br>在浏览器中输入<code>http://localhost:4000/</code>就可以看到预览效果了。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">// 如果写的文章太长的话，想要在Home页显示文章的前一小部分的话，可以在想要显示部分的后面加上&lt;!--more--&gt;，就可以实现文章折叠。</code></pre>

<p>以上是本地部署，下面讲博客部署到Github page上</p>
<h2 id="部署到Github-page"><a href="#部署到Github-page" class="headerlink" title="部署到Github page"></a>部署到Github page</h2><p>登录github，新建仓库，仓库名为<code>username.github.io</code>，<strong>注意：<code>username</code>应该是你github的用户名</strong></p>
<p>本地和github都完成之后，现在需要把这两者连接在一起</p>
<ol>
<li><p>修改被指</p>
<p>在项目根目录下的<code>_config.yml</code>修改配置参数（如果这里命令行显示连接不了GitHub，那就用仓库的ssh链接代替https链接，因为GitHub现在增强了安全性，用户名和密码登录不能保证安全性）</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># Deployment</span>
<span class="token comment">## Docs: https://hexo.io/docs/one-command-deployment</span>
deploy:
  type: <span class="token function">git</span>
  repo:
    github: https://github.com/你的用户名/你的用户名.github.io.git
  branch: master</code></pre></li>
<li><p>安装部署插件</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save</code></pre></li>
<li><p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</p>
</li>
<li><p>部署上线</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">hexo g -d</code></pre></li>
</ol>
<p>用浏览器输入，https://你的用户名.github.io，就可以看到你的博客了。</p>
<h2 id="配置主题及语言"><a href="#配置主题及语言" class="headerlink" title="配置主题及语言"></a>配置主题及语言</h2><p>个人用的是<a href="https://theme-next.js.org/">NexT主题</a></p>
<p>进入项目根目录，下载NexT主题</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">git</span> clone https://github.com/next-theme/hexo-theme-next themes/next</code></pre>

<p>修改<strong>项目根目录</strong>下的<code>_config.yml</code>的配置</p>
<p>注意：<code>_config.yml</code>配置文件有两个，一个在项目根目录，一个在<code>/themes/next</code>中，大部分配置在主题里面改。</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token comment">## Themes: https://hexo.io/themes/</span>
theme: next</code></pre>

<p>修改语言：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Site</span>
<span class="token key atrule">title</span><span class="token punctuation">:</span> 博客的名字
<span class="token key atrule">subtitle</span><span class="token punctuation">:</span> <span class="token string">''</span>
<span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">''</span>
<span class="token key atrule">keywords</span><span class="token punctuation">:</span>
<span class="token key atrule">author</span><span class="token punctuation">:</span> 
<span class="token key atrule">language</span><span class="token punctuation">:</span> zh<span class="token punctuation">-</span>CN
<span class="token key atrule">timezone</span><span class="token punctuation">:</span> <span class="token string">''</span></code></pre>



<h2 id="NexT配置"><a href="#NexT配置" class="headerlink" title="NexT配置"></a>NexT配置</h2><p>以下均在<code>/blogName/themes/next/_config.yml</code>文件中修改</p>
<blockquote>
<p>修改主题的时候，可以使用hexo s现在本地预览，然后再部署上线。部署上线的效果可能有几分钟的延迟，耐心等待就好</p>
</blockquote>
<h3 id="修改NexT风格"><a href="#修改NexT风格" class="headerlink" title="修改NexT风格"></a>修改NexT风格</h3><p>NexT主题有四个风格，想要的取消注释</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># Schemes</span>
<span class="token comment">#scheme: Muse</span>
scheme: Mist
<span class="token comment">#scheme: Pisces</span>
<span class="token comment">#scheme: Gemini</span></code></pre>

<h3 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h3><pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># Dark Mode</span>
darkmode: <span class="token boolean">true</span></code></pre>

<h3 id="改变网页标签icon"><a href="#改变网页标签icon" class="headerlink" title="改变网页标签icon"></a>改变网页标签icon</h3><p>把你想要用的图片放在<code>/themes/next/source/images</code>中</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">favicon:
  small: /images/图片名字
  medium: /images/图片名字</code></pre>

<h3 id="增加或删除博客页面功能"><a href="#增加或删除博客页面功能" class="headerlink" title="增加或删除博客页面功能"></a>增加或删除博客页面功能</h3><p>想用的取消注释，</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">menu:
  home: / <span class="token operator">||</span> fa fa-home
  about: /about/ <span class="token operator">||</span> fa fa-user
  tags: /tags/ <span class="token operator">||</span> fa fa-tags
  categories: /categories/ <span class="token operator">||</span> fa fa-th
  archives: /archives/ <span class="token operator">||</span> fa fa-archive
  <span class="token comment">#schedule: /schedule/ || fa fa-calendar</span>
  <span class="token comment">#sitemap: /sitemap.xml || fa fa-sitemap</span>
  <span class="token comment">#commonweal: /404/ || fa fa-heartbeat</span></code></pre>

<h4 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h4><p>在项目根目录</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">hexo new page tags
<span class="token builtin class-name">cd</span> ./source/tags</code></pre>

<p>打开<code>index.md</code>文件，增加一个<code>type</code>字段</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">---
title: tags
type: <span class="token string">"tags"</span>
comments: <span class="token boolean">false</span>
date: <span class="token number">2022</span>-01-04 <span class="token number">13</span>:29:07
---</code></pre>

<h4 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h4><p>在项目根目录</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">hexo new page categories
<span class="token builtin class-name">cd</span> ./source/categories</code></pre>

<p>打开<code>index.md</code>文件，增加一个<code>type</code>字段</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">---
title: categories
type: <span class="token string">"categories"</span>
date: <span class="token number">2022</span>-01-04 <span class="token number">13</span>:55:58
---</code></pre>

<h4 id="添加about页面"><a href="#添加about页面" class="headerlink" title="添加about页面"></a>添加about页面</h4><p>在项目根目录</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">hexo new page about
<span class="token builtin class-name">cd</span> ./source/about</code></pre>

<p>打开<code>index.md</code>文件，可以在里面写自己的个人介绍。</p>
<h3 id="调整侧边栏位置"><a href="#调整侧边栏位置" class="headerlink" title="调整侧边栏位置"></a>调整侧边栏位置</h3><pre class="language-shell" data-language="shell"><code class="language-shell">sidebar:
  <span class="token comment"># Sidebar Position.</span>
  <span class="token comment">#position: left</span>
  position: right</code></pre>

<h3 id="添加侧边栏头像图片"><a href="#添加侧边栏头像图片" class="headerlink" title="添加侧边栏头像图片"></a>添加侧边栏头像图片</h3><pre class="language-sh" data-language="sh"><code class="language-sh"># Sidebar Avatar
avatar:
  # 把要展示的图片放在images中
  url: /images/avatar.jpg
  # If true, the avatar will be displayed in circle.
  rounded: false
  # If true, the avatar will be rotated with the cursor.
  rotated: false</code></pre>

<h3 id="启用不蒜子统计"><a href="#启用不蒜子统计" class="headerlink" title="启用不蒜子统计"></a>启用不蒜子统计</h3><p>不蒜子是用于统计文章的阅读次数</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">busuanzi_count:
  enable: true
  total_visitors: true
  total_visitors_icon: fa fa-user
  total_views: true
  total_views_icon: fa fa-eye
  post_views: true
  post_views_icon: fa fa-eye</code></pre>

<h3 id="添加网页加载进度条"><a href="#添加网页加载进度条" class="headerlink" title="添加网页加载进度条"></a>添加网页加载进度条</h3><pre class="language-sh" data-language="sh"><code class="language-sh">cd themes/next
git clone https://github.com/theme-next/theme-next-pace source/lib/pace</code></pre>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">pace:
  enable: <span class="token boolean">true</span>
  theme: minimal</code></pre>

<h3 id="添加页面顶部阅读进度条"><a href="#添加页面顶部阅读进度条" class="headerlink" title="添加页面顶部阅读进度条"></a>添加页面顶部阅读进度条</h3><pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> themes/next
<span class="token function">git</span> clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress</code></pre>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">reading_progress:
  enable: <span class="token boolean">true</span>
  position: <span class="token function">top</span>               <span class="token comment"># 进度条的位置：top | bottom</span>
  color: <span class="token string">"#37c6c0"</span>            <span class="token comment"># 进度条的颜色</span>
  height: 3px                 <span class="token comment"># 进度条的大小</span></code></pre>

<h3 id="显示侧栏底部阅读进度百分比"><a href="#显示侧栏底部阅读进度百分比" class="headerlink" title="显示侧栏底部阅读进度百分比"></a>显示侧栏底部阅读进度百分比</h3><p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">back2top:
  enable: <span class="token boolean">true</span>
  sidebar: <span class="token boolean">false</span>
  scrollpercent: <span class="token boolean">true</span></code></pre>

<h3 id="字数与阅读时长统计插件"><a href="#字数与阅读时长统计插件" class="headerlink" title="字数与阅读时长统计插件"></a>字数与阅读时长统计插件</h3><pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> 项目根目录
<span class="token function">npm</span> <span class="token function">install</span> eslint --save
<span class="token function">npm</span> <span class="token function">install</span> hexo-symbols-count-time --save</code></pre>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">symbols_count_time:
  time: <span class="token boolean">true</span>                   <span class="token comment"># 文章阅读时长</span>
  symbols: <span class="token boolean">true</span>                <span class="token comment"># 文章字数统计</span>
  total_time: <span class="token boolean">true</span>             <span class="token comment"># 站点总阅读时长</span>
  total_symbols: <span class="token boolean">true</span>          <span class="token comment"># 站点总字数统计</span>
  exclude_codeblock: <span class="token boolean">true</span>      <span class="token comment"># 排除代码字数统计</span></code></pre>



<h3 id="添加search栏"><a href="#添加search栏" class="headerlink" title="添加search栏"></a>添加search栏</h3><pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token builtin class-name">cd</span> 项目根目录
<span class="token function">npm</span> <span class="token function">install</span> hexo-generator-searchdb --save</code></pre>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">local_search:
  enable: <span class="token boolean">true</span>

// 在local_search:下面添加，注意search和local_search是在同一缩进上
search:
  path: search.xml
  field: post
  format: html
  limit: <span class="token number">10000</span></code></pre>



<h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><ul>
<li><p><code>hexo init [folder]</code></p>
<ul>
<li>Hexo 默认在目前的文件夹建立网站。</li>
<li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li>
<li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li>
</ul>
</li>
<li><pre><code>hexo new '文章标题'
</code></pre>
<ul>
<li>新建文件，写的时候自己用typora打开写。可简写为<code>hexo n '文章标题'</code></li>
</ul>
</li>
<li><p><code>hexo clean</code></p>
<ul>
<li>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</li>
<li>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</li>
</ul>
</li>
<li><p><code>hexo generate</code></p>
<ul>
<li>生成静态文件，可简写为<code>hexo g</code></li>
</ul>
</li>
<li><p><code>hexo server</code></p>
<ul>
<li>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。可以简写为 hexo s</li>
</ul>
</li>
<li><p><code>hexo deploy</code></p>
<ul>
<li>部署网站，可简写为<code>hexo d</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>手写 Promise/A+ 规范</title>
    <url>/2022/03/20/%E6%89%8B%E5%86%99-Promise-A-%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="手写-Promise-A-规范"><a href="#手写-Promise-A-规范" class="headerlink" title="手写 Promise/A+ 规范"></a>手写 Promise/A+ 规范</h3><p>所谓 <code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>想要写出 Promise/A+ 规范的 promsie，首先要熟读 Promise/A+ 的<a href="https://promisesaplus.com/">英文规范文档</a>，建议先看几遍英文文档，了解一下规则。还有这篇中文文档翻译的也很到位 <a href="https://zhuanlan.zhihu.com/p/143204897">中文规范文档</a></p>
<span id="more"></span>

<p>状态：</p>
<p>Promise存在三个状态（state）pending、fulfilled、rejected</p>
<p>pending（等待态）为初始态，并可以转化为 fulfilled（成功态）和 rejected（失败态），一旦确定就不可以改变</p>
<p>如果 executor 函数报错，则直接执行 reject(reason);</p>
<p>then 方法：</p>
<p>promise的 <code>then</code> 方法接收两个可选参数，表示该 <code>promise</code> 状态改变时的回调</p>
<p><code>then</code>方法返回一个<code>promise</code>，<code>then</code> 方法可以被同一个 promise 调用多次</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">promise2 <span class="token operator">=</span> promise1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span></code></pre>



<p>resolvePromise 方法：</p>
<p>这个方法是用来处理 then 方法中的 <code>onFulfilled</code> 和 <code>onRejected</code> 这两个参数，当这两个参数是函数的时候，处理它们的返回值</p>
<p>下面就根据日常对 promise 的使用规则出发去写一下 Promise/A+ 规范吧。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">PENDING</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>


        <span class="token comment">// 同一个 promsie 实例可能会被多次调用</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
              
                <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">let</span> <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>

                <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 解决 onFufilled，onRejected 没有传值的问题</span>
        onFulfilled <span class="token operator">=</span> <span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function-variable function">onFulfilled</span> <span class="token operator">:</span> <span class="token parameter">v</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">;</span>
        <span class="token comment">// 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获</span>
        onRejected <span class="token operator">=</span> <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function-variable function">onRejected</span> <span class="token operator">:</span> <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> err <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 每次调用 then 都返回一个新的 promise</span>
        <span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//Promise/A+ 2.2.4 --- setTimeout</span>
                <span class="token comment">// 在执行上下文栈中只包含平台代码之前，onFulfilled或onRejected一定不能被调用 [3.1]</span>
                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// x可能是一个proimise</span>
                        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                            <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>

                <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                            <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment">// Promise/A+ 2.2.7. then必须返回一个promise [3.3]</span>
        <span class="token keyword">return</span> promise2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">resolvePromise</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'err'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Promise/A+ 2.3.3.3.3 只能调用一次</span>
    <span class="token keyword">let</span> called<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，防止 Object.defineProperty 中设置的 get 只能访问一次的情况  Promise/A+ 2.3.3.3</span>
                <span class="token function">then</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>
                    <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 根据 promise 的状态决定是成功还是失败</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
                        called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token comment">// 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span>

                        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> value<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token punctuation">,</span>
                    <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 只要失败就失败 Promise/A+ 2.3.3.3.2</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
                        called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Promise/A+ 2.3.3.2</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
            called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>

<p>Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// promise.js</span>
<span class="token comment">// 这里是上面写的 Promise 全部代码</span>
Promise<span class="token punctuation">.</span>defer <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function-variable function">deferred</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dfd <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    dfd<span class="token punctuation">.</span>promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        dfd<span class="token punctuation">.</span>resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span>
        dfd<span class="token punctuation">.</span>reject <span class="token operator">=</span> reject<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dfd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Promise<span class="token punctuation">;</span></code></pre>

<p>全局安装：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token function">npm</span> i promises-aplus-tests -g</code></pre>

<p>终端下执行验证命令：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">promises-aplus-tests promise.js</code></pre>



<p>结语：刚开始接触 promise 的时候，觉得这东西好抽象，但是用了段时间之后，感觉确实好用。作为一名有追求的程序员，怎么能不挑战一下 promise/A+ 呢！不能被它的规范很多吓到，其实它的规范也是我们平时使用的规则，从这个点出发去写，就不那么枯燥了嘿嘿</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js之作用域</title>
    <url>/2022/03/03/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”</p>
<ul>
<li><p>分词/词法分析（Tokening/Lexing）</p>
<p>如var a = 2;。会被分解为:var、a、=、2 、;</p>
</li>
<li><p>解析/语法分析 (Parsing)</p>
<p>这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树” (Abstract Syntax Tree，AST)</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>代码生成</p>
<p>将 AST 转换为可执行代码的过程称被称为代码生成</p>
</li>
</ul>
<p>感觉 HTML 的编译过程和这个有点类似。果然天下语言不分家</p>
<h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>名词解释：</p>
<ul>
<li> 引擎</li>
</ul>
<p>  从头到尾负责整个 JavaScript 程序的编译及执行过程。</p>
<ul>
<li><p>编译器</p>
<p>负责语法分析及代码生成</p>
</li>
<li><p>作用域（重点）</p>
<p>负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>
</li>
</ul>
<p>为了理解三者关系，举一个🌰来说明</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span></code></pre>

<ul>
<li>首先编译器会将这段代码进行词法分析，生成词法单元。然后将词法单元解析，生成 AST</li>
</ul>
<ul>
<li>编译器编译具体过程：<ul>
<li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。（var 变量提升）</li>
<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量（运行时赋值）</li>
</ul>
</li>
</ul>
<p>LHS 查询 和 RHS 查询</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取得 a 的值，这样才能将值传递给 console.log(..)；</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre>

<p>这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为<code>= 2</code>这个赋值操作找到一个目标。</p>
<p>LHS 查询 和 RHS 查询总结：</p>
<p>LHS：赋值操作的目标是谁</p>
<p>RHS：谁是赋值操作的源头</p>
<p>对 LHS 和 RHS 进一步的理解：</p>
<p>考虑如下代码:</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> 
		b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变 量，因为在任何相关的作用域中都无法找到它。</p>
<p>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。</p>
<p>相较之下，当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，</p>
<p>全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。（非严格模式下才会创建，严格模式禁止自动或隐式地创建全局变量。因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常）</p>
<p>知识补充：ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域是什么？</p>
<p>大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。</p>
<p>这个概念是理解词法作用域及其名称来历的基础。</p>
<p>词法作用域能不能更改？</p>
<p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的，可以使用 eval 进行更改)</p>
<p>欺骗词法，更改词法作用域（但在严格模式下，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域）</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	<span class="token function">eval</span><span class="token punctuation">(</span> str <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 欺骗! </span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token string">"var b = 3;"</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 3</span></code></pre>

<p>eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代 码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实 上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽 了外部(全局)作用域中的同名变量。</p>
<p>当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到 外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。</p>
<p>但是这种在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。因为使用了 eval 之后，编译器的优化几乎起不到作用！</p>
<p>⚠️ <strong>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</strong></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>断点看源码系列：探究React-router内部工作流程</title>
    <url>/2022/03/03/%E6%96%AD%E7%82%B9%E7%9C%8B%E6%BA%90%E7%A0%81%EF%BC%9A%E6%8E%A2%E7%A9%B6react-router%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="从实际出发搞清楚react-router内部原理"><a href="#从实际出发搞清楚react-router内部原理" class="headerlink" title="从实际出发搞清楚react-router内部原理"></a>从实际出发搞清楚react-router内部原理</h3><p>[toc]</p>
<p>前言：最近在看 <code>react-router</code> 的工作原理网上看了一圈文章，发现很多都是介绍了 <code>history</code> 库的原理和 <code>react-router</code> 里面的 <code>BrowserRouter</code> 组件、<code>Router</code> 组件等等，看了原理是大概知道了，但是它的内部是怎么样的一个工作流程还是一脸懵逼，又在找了一圈资料，看完还是觉得具体流程理不太清。想到平时在 js 代码的调试中可以打断点观察各个变量的情况以及程序的流程，<code>react</code> 程序那应该也可以这样调试。</p>
<p>随后写了一个小 demo 测试一下：</p>
<span id="more"></span>

<h4 id="准备文件："><a href="#准备文件：" class="headerlink" title="准备文件："></a>准备文件：</h4><p><code>App.js</code> 文件</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> PureComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Link<span class="token punctuation">,</span> Switch<span class="token punctuation">,</span> Route<span class="token punctuation">,</span> withRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span>

<span class="token comment">// 为了看 history 的源码而引入</span>
<span class="token keyword">import</span> history <span class="token keyword">from</span> <span class="token string">'history'</span>

<span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'./pages/home'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Profile <span class="token keyword">from</span> <span class="token string">'./pages/profile'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">PureComponent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>Link className<span class="token operator">=</span><span class="token string">'mylink'</span> to<span class="token operator">=</span><span class="token string">"/"</span><span class="token operator">&gt;</span>首页<span class="token operator">&lt;</span><span class="token operator">/</span>Link<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>Link className<span class="token operator">=</span><span class="token string">'mylink'</span> to<span class="token operator">=</span><span class="token string">"/profile"</span><span class="token operator">&gt;</span>我的<span class="token operator">&lt;</span><span class="token operator">/</span>Link<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">jumpToProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>测试<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>

                <span class="token operator">&lt;</span>Switch<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>Route exact path<span class="token operator">=</span><span class="token string">"/"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/profile"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Profile<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>Switch<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">jumpToProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"/profile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withRouter</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p><code>index.js</code> 文件</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span>
  BrowserRouter<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span><span class="token punctuation">;</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>BrowserRouter<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>BrowserRouter<span class="token operator">&gt;</span>
  <span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p><code>profile.js</code> 组件， Home 一样</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> PureComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Profile</span> <span class="token keyword">extends</span> <span class="token class-name">PureComponent</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>Profile<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<p>到这里就可以开始了我们的流程探究了，在 <code>App.js</code> 文件的 <code>jumpToProduct</code> 里面的一行代码打上断点。</p>
<p>打断点的具体方式是：将 demo 跑起来 -&gt; 打开浏览器的控制台 -&gt; source -&gt; 具体文件 -&gt; 打上断点</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">jumpToProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"/profile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzwst9j6j4j225y0n844l.jpg"></p>
<p>点击 <code>button</code> 按钮，进行单步调试。然后程序就跳到 <code>node_modules/history/cjs/history.js</code> 的 <code>push</code> 函数里面了。</p>
<p>这是为什么呢？因为 <code>Link</code> 组件里面判断了是用什么方法改变路径的。这里我们模拟的是 <code>push</code> 方法</p>
<h4 id="1-Link-里面的判断代码片段（以下源码均为节选）"><a href="#1-Link-里面的判断代码片段（以下源码均为节选）" class="headerlink" title="1. Link 里面的判断代码片段（以下源码均为节选）"></a>1. Link 里面的判断代码片段（以下源码均为节选）</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 1. Link 里面的判断代码片段</span>
<span class="token keyword">var</span> props <span class="token operator">=</span> <span class="token function">_extends</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> rest<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      href<span class="token operator">:</span> href<span class="token punctuation">,</span>
      <span class="token function-variable function">navigate</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">navigate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> location <span class="token operator">=</span> <span class="token function">resolveToLocation</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> context<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> isDuplicateNavigation <span class="token operator">=</span> history<span class="token punctuation">.</span><span class="token function">createPath</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>location<span class="token punctuation">)</span> <span class="token operator">===</span> history<span class="token punctuation">.</span><span class="token function">createPath</span><span class="token punctuation">(</span><span class="token function">normalizeToLocation</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> method <span class="token operator">=</span> replace <span class="token operator">||</span> isDuplicateNavigation <span class="token operator">?</span> history$<span class="token number">1.</span>replace <span class="token operator">:</span> history$<span class="token number">1.</span>push<span class="token punctuation">;</span>
        <span class="token function">method</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// React 15 compat</span></code></pre>

<h4 id="2-这里调用的是-history-下的-push-方法"><a href="#2-这里调用的是-history-下的-push-方法" class="headerlink" title="2. 这里调用的是 history 下的 push 方法"></a>2. 这里调用的是 <code>history</code> 下的 <code>push</code> 方法</h4><p><code>push</code> 方法里面创建一个新的 <code>location</code> 对象，然后通过 <code>globalHistory</code> 方法改变浏览器当前路由,最后通过<code>setState</code> 方法通知 <code>React-Router</code> 更新（这里会跳到 <code>ReactRefreshEntry.js</code> 这个文件），并传递当前的 <code>location</code> 对象</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> action <span class="token operator">=</span> <span class="token string">'PUSH'</span><span class="token punctuation">;</span>
  	<span class="token comment">/* 2. 创建location对象 */</span>
    <span class="token keyword">var</span> location <span class="token operator">=</span> <span class="token function">createLocation</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token function">createKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> history<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">/* 3. 确定是否能进行路由转换 */</span>
    transitionManager<span class="token punctuation">.</span><span class="token function">confirmTransitionTo</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> action<span class="token punctuation">,</span> getUserConfirmation<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">ok</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ok<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> href <span class="token operator">=</span> <span class="token function">createHref</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> key <span class="token operator">=</span> location<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
          state <span class="token operator">=</span> location<span class="token punctuation">.</span>state<span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>canUseHistory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 改变 url */</span>
        globalHistory<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          key<span class="token operator">:</span> key<span class="token punctuation">,</span>
          state<span class="token operator">:</span> state
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> href<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>forceRefresh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> href<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">/* 改变 react-router location对象, 创建更新环境 */</span>
          <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            action<span class="token operator">:</span> action<span class="token punctuation">,</span>
            location<span class="token operator">:</span> location
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>



<h4 id="3-history-下的-createTransitionManager-函数"><a href="#3-history-下的-createTransitionManager-函数" class="headerlink" title="3. history 下的 createTransitionManager 函数"></a>3. <code>history</code> 下的 <code>createTransitionManager</code> 函数</h4><p>作用是监听判断是否能进行路由转换 </p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/* 3. 确定是否能进行路由转换 */</span>
<span class="token keyword">function</span> <span class="token function">createTransitionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> prompt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
  <span class="token keyword">function</span> <span class="token function">confirmTransitionTo</span><span class="token punctuation">(</span><span class="token parameter">location<span class="token punctuation">,</span> action<span class="token punctuation">,</span> getUserConfirmation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prompt <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">typeof</span> prompt <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">prompt</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token operator">:</span> prompt<span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> getUserConfirmation <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">getUserConfirmation</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// Return false from a transition hook to cancel the transition.</span>
        <span class="token function">callback</span><span class="token punctuation">(</span>result <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">var</span> listeners <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token keyword">function</span> <span class="token function">appendListener</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> isActive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isActive<span class="token punctuation">)</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    listeners<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isActive <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      listeners <span class="token operator">=</span> listeners<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> item <span class="token operator">!==</span> listener<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">notifyListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    listeners<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">listener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">listener</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>



<h4 id="4-history-中-createBrowserHistory-props-函数的-setState"><a href="#4-history-中-createBrowserHistory-props-函数的-setState" class="headerlink" title="4. history  中 createBrowserHistory(props) 函数的 setState"></a>4. <code>history</code>  中 <code>createBrowserHistory(props)</code> 函数的 <code>setState</code></h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token comment">/* 通知listener更新，这里通知到 react-router了 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">nextState</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 合并信息 */</span>
    Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>history<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span>
    history<span class="token punctuation">.</span>length <span class="token operator">=</span> globalHistory<span class="token punctuation">.</span>length
    <span class="token comment">/* 通知每一个listens路由已经发生变化 */</span>
    transitionManager<span class="token punctuation">.</span><span class="token function">notifyListeners</span><span class="token punctuation">(</span>
      history<span class="token punctuation">.</span>location<span class="token punctuation">,</span>
      history<span class="token punctuation">.</span>action
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span></code></pre>



<h4 id="5-路由匹配"><a href="#5-路由匹配" class="headerlink" title="5. 路由匹配"></a>5. 路由匹配</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token comment">/* 5. 监听并进行路由匹配 */</span>
<span class="token keyword">class</span> <span class="token class-name">Router</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">computeRootMatch</span><span class="token punctuation">(</span><span class="token parameter">pathname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> url<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> isExact<span class="token operator">:</span> pathname <span class="token operator">===</span> <span class="token string">"/"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      location<span class="token operator">:</span> props<span class="token punctuation">.</span>history<span class="token punctuation">.</span>location
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingLocation <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>props<span class="token punctuation">.</span>staticContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>unlisten <span class="token operator">=</span> props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token parameter">location</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> location <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingLocation <span class="token operator">=</span> location<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>路由转换的大致流程就是：</p>
<ol>
<li>模拟点击 <code>Link</code></li>
<li>调用 <code>history.push</code> 方法，通过 <code>history.pushState</code> 来改变当前 <code>url</code></li>
<li>接下来触发 <code>history</code> 下面的 <code>setState</code> 方法，产生新的 location 对象，</li>
<li>然后通知 <code>Router</code> 组件更新 <code>location</code></li>
<li>路由匹配组件中监听更新的消息，找出符合的组件，最后进行页面更新。</li>
</ol>
<p><strong>纸上得来终觉浅,绝知此事要躬行</strong></p>
<p>还得再多加油 多多 coding 多多看源码</p>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://juejin.cn/post/6886290490640039943#heading-13">「源码解析 」这一次彻底弄懂react-router路由原理</a></p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React React源码</tag>
      </tags>
  </entry>
  <entry>
    <title>网易云音乐使用 next.js 框架优化体验开发记录</title>
    <url>/2022/05/06/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E4%BD%BF%E7%94%A8%20next.js%20%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E4%BD%93%E9%AA%8C%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="网易云音乐使用-next-js-框架优化体验开发记录"><a href="#网易云音乐使用-next-js-框架优化体验开发记录" class="headerlink" title="网易云音乐使用 next.js 框架优化体验开发记录"></a>网易云音乐使用 next.js 框架优化体验开发记录</h1><p>为什么要使用 next.js 呢？</p>
<p>因为使用 react 框架，开发出来的单页面富应用，是先从服务器请求下来 HTML、CSS、JS 文件，然后在客户端再进行解析。这样的话，会有一段时间的白屏，而且首屏加载速度很慢很慢，自己都受不了自己开发的项目速度这么慢了。本着要把事情做的更好的精神（其实就是受不了这么慢的加载速度），决定使用 next.js 框架对项目进行服务端渲染，加快访问速度。</p>
<p>使用客户端渲染时的性能分析：</p>
<p>从下图可以看出，在客户端渲染的情况下解析 HTML 和重新计算样式还有布局占用了很多的时间</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1z9nx4oi3j21mg0u012g.jpg"></p>
<span id="more"></span>

<p>使用服务端渲染时的性能分析：</p>
<p>从下图可以看出，SSR（服务端渲染）解析 HTML 和重新计算样式还有布局的时间占比是很少的（这里的话应该是在服务端将页面渲染好的），而且服务端渲染的总时间已经减少了很长的时间，所以应用的打开速度比客户端渲染打开的速度快很多。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1zai3mppgj21m90u010c.jpg"></p>
<h3 id="使用路径别名"><a href="#使用路径别名" class="headerlink" title="使用路径别名"></a>使用路径别名</h3><p>首先</p>
<pre class="language-none"><code class="language-none">yarn add -D babel-plugin-module-resolver</code></pre>

<p>然后再创建一个  <code>.babelrc</code> 文件</p>
<pre class="language-none"><code class="language-none">{
    "presets": ["next/babel"],
    "plugins": [
      [
        "module-resolver",
        {
          "alias": {
            "@/components": "./components",
            "@/pages": "./pages",
            "@/public": "./public",
            "@/utils": "./utils"
          }
        }
      ]
    ]
  }</code></pre>

<p>就可以了。比普通的 react 框架简单多了</p>
<h3 id="使用-styled-components"><a href="#使用-styled-components" class="headerlink" title="使用 styled-components"></a>使用 styled-components</h3><p>首先安装</p>
<pre class="language-none"><code class="language-none">yarn add styled-components</code></pre>

<pre class="language-none"><code class="language-none">yarn add -D babel-plugin-styled-components</code></pre>

<p>然后在   <code>.babelrc</code>  文件加上</p>
<pre class="language-none"><code class="language-none">["styled-components"]</code></pre>

<p>也就是</p>
<pre class="language-diff" data-language="diff"><code class="language-diff">{
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   "presets": ["next/babel"],
</span><span class="token prefix unchanged"> </span><span class="token line">   "plugins": [
</span><span class="token prefix unchanged"> </span><span class="token line">     [
</span><span class="token prefix unchanged"> </span><span class="token line">       "module-resolver",
</span><span class="token prefix unchanged"> </span><span class="token line">       {
</span><span class="token prefix unchanged"> </span><span class="token line">         "alias": {
</span><span class="token prefix unchanged"> </span><span class="token line">           "@/components": "./components",
</span><span class="token prefix unchanged"> </span><span class="token line">           "@/pages": "./pages",
</span><span class="token prefix unchanged"> </span><span class="token line">           "@/public": "./public",
</span><span class="token prefix unchanged"> </span><span class="token line">           "@/utils": "./utils"
</span><span class="token prefix unchanged"> </span><span class="token line">         }
</span><span class="token prefix unchanged"> </span><span class="token line">       }
</span><span class="token prefix unchanged"> </span><span class="token line">     ],
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">      ["styled-components"]
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">   ]
</span><span class="token prefix unchanged"> </span><span class="token line"> }</span></span></code></pre>



<h3 id="路由的重写"><a href="#路由的重写" class="headerlink" title="路由的重写"></a>路由的重写</h3><p>将根目录重写为发现页，在  <code>next.config.js</code> 文件添加如下代码</p>
<pre class="language-diff" data-language="diff"><code class="language-diff">/** @type {import('next').NextConfig} */
const nextConfig = {
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"> reactStrictMode: true,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  async redirects() {
</span><span class="token prefix inserted">+</span><span class="token line">    return [
</span><span class="token prefix inserted">+</span><span class="token line">      {
</span><span class="token prefix inserted">+</span><span class="token line">        source: '/',
</span><span class="token prefix inserted">+</span><span class="token line">        destination: '/discover',
</span><span class="token prefix inserted">+</span><span class="token line">        permanent: true,
</span><span class="token prefix inserted">+</span><span class="token line">      },
</span><span class="token prefix inserted">+</span><span class="token line">    ]
</span><span class="token prefix inserted">+</span><span class="token line">  }
</span><span class="token prefix inserted">+</span><span class="token line">}
</span></span>
module.exports = nextConfig</code></pre>



<h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><pre class="language-none"><code class="language-none">yarn build</code></pre>

<p>这个过程可能会遇到很多问题，根据控制台的问题提示和 Google 就能很快解决。</p>
<p>打包之后，可以用于产线服务的代码就准备好了！之后，执行：<code>yarn start</code> 就可以把服务启动起来了</p>
<p>可以通过 curl 访问验证一下服务有没有启动：</p>
<pre class="language-none"><code class="language-none">curl -v http://127.0.0.1:3000 # 如果没有更改端口的话</code></pre>

<p>看到有返回信息，说用服务已经起来了。</p>
<h3 id="部署到-vercel-服务器"><a href="#部署到-vercel-服务器" class="headerlink" title="部署到 vercel 服务器"></a>部署到 vercel 服务器</h3><p>从官网链接点进去，按照说明一步一步进行部署</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js之闭包</title>
    <url>/2022/04/06/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E4%B9%8B%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包一直是一个困扰初学者的一个问题，网上对闭包的各种定义和解释都大不相同，有的人说闭包很简单，也有的人说闭包很复杂，甚至在评论区 battle，这下可苦坏了初学者，该信哪个啊😢</p>
<p>其实我们可以看看《你不知道的 JavaScript》的作者对于闭包的理解：</p>
<span id="more"></span>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript">对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看
作是某种意义上的重生，但是需要付出非常多的努力和牺牲才能理解这个概念。
回忆我前几年的时光，大量使用 JavaScript 但却完全不理解闭包是什么。总是感觉这门语 言有其隐蔽的一面，如果能够掌握将会功力大涨，但讽刺的是我始终无法掌握其中的门 道。还记得我曾经大量阅读早期框架的源码，试图能够理解闭包的工作原理。现在还能回 忆起我的脑海中第一次浮现出关于“模块模式”相关概念时的激动心情。
那时我无法理解并且倾尽数年心血来探索的，也就是我马上要传授给你的秘诀<span class="token operator">:</span>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。闭包并不是一个需要学习新的语法或模式才能使用的工具。
闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意 识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿 来识别、拥抱和影响闭包的思维环境。
最后你恍然大悟<span class="token operator">:</span>原来在我的代码中已经到处都是闭包了，现在我终于能理解它们了。</code></pre>



<h4 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h4><p><strong>下面是直接了当的定义，你需要掌握它才能理解和识别闭包:</strong></p>
<pre class="language-none"><code class="language-none">当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。</code></pre>

<p>注意：⚠️ <strong>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</strong></p>
<p>下面来看一段代码：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
	<span class="token punctuation">}</span>
	<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数 bar() 可以访问外部作用域中的变量 a (这个例子中的是一个 RHS 引用查询)。</p>
<p>这是闭包吗?</p>
<p>技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。(但却是非常重要的一部分!)</p>
<p>👀这段你不知道的 JavaScript 原话说明了闭包应该是有严格意义上的闭包和广义的闭包。可能也就是这么多人争论的原因。所以上面的例子并不算是严格意义上的闭包，因为 bar(…) 这个函数没有在当前词法作用域之外执行。</p>
<p>下面我们来看一段代码，清晰地展示了闭包:</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 —— 朋友，这就是闭包的效果。</span></code></pre>

<p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。</p>
<p>在 foo() 执行后，其返回值(也就是内部的 bar() 函数)赋值给变量 baz 并调用 baz()， 际上只是通过不同的标识符引用调用了内部的函数 bar()。</p>
<p>bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。</p>
<p>在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。</p>
<p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域?原来是 bar() 本身在使用。</p>
<p>拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。</p>
<p>bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>
<p>总结上面这段话：就是函数 foo() 内定义一个变量和一个函数  bar() ，函数 bar() 里面使用了函数 foo() 内的变量 a，也就是函数 bar() 访问了函数 foo() 的词法作用域，所以函数 bar() 拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活。最后函数 bar() 以值传递的方式到 baz，然后函数 baz 在函数 bar 定义时的词法作用域之外执行，所以这两个条件就构成了闭包。</p>
<p>感慨：原书的作者对比闭包讲的非常清楚了，果然还是看书效率最高，看网上不同的说法都要把自己看出人格分裂了。</p>
<p>闭包总结：本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使用了回调函数，实际上就是在使用闭包！还有防抖节流保持状态和 React 里面的函数组件保持状态的原理都是闭包。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo：next主题美化进阶设置</title>
    <url>/2022/01/11/hexo%E4%B9%8Bnext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h2 id="hexo进阶教程"><a href="#hexo进阶教程" class="headerlink" title="hexo进阶教程"></a>hexo进阶教程</h2><p>[toc]</p>
<h3 id="Hexo博客-绑定个人域名"><a href="#Hexo博客-绑定个人域名" class="headerlink" title="Hexo博客-绑定个人域名"></a>Hexo博客-绑定个人域名</h3><ol>
<li><p>首先得有一个域名，在腾讯云阿里云购买都可以。</p>
</li>
<li><p>设置域名解析</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy926kk6t7j32l60ba76f.jpg" style="zoom: 25%;">

<span id="more"></span>

<ol start="3">
<li><p>设置CNAME</p>
</li>
<li><p>在 hexo 项目下的<code>source</code> 文件夹下面创建 CNAME 文件（没有后缀名的），Mac用户可以</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9285o2ncj308e01ut8j.jpg" style="zoom:50%;">



<p>在里面写上购买的域名。</p>
</li>
<li><p>在 github 上面，打开 <a href="http://username.github.io/">username.github.io</a> 项目的（Settings）设置，然后在 <code>GitHub Pages</code>的 <code>Custom domain</code>设置里填上购买的域名。比如：</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy922se47aj31v60f0myl.jpg" style="zoom:23%;">



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy923cjs5hj313g0ag0tp.jpg" style="zoom:37%;">

<p>点击save就可以了。</p>
<h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><p><strong>实现效果图</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy90vctmacj30za03kgli.jpg"></p>
<p><strong>具体实现方法</strong></p>
<p>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.njk</code> 文件,并添加以下内容：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token keyword">if</span> not is_index <span class="token operator">%</span><span class="token punctuation">}</span>
        <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token string">"text-align:center;color: #ccc;font-size:14px;"</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 本文结束 <span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"fas fa-book-reader"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">&gt;</span> 感谢阅读 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token operator">%</span> endif <span class="token operator">%</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></code></pre>

<p>接着打开<code>\themes\next\layout\_macro\post.njk</code>文件，在<code>post-body</code> 之后， <code>post-footer</code> 之前添加如下圈住的代码：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  {% if not is_index %}
  {% include 'passage-end-tag.njk' %}
  {% endif %}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre>

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy90wy5kuhj31ip0u0wiw.jpg" style="zoom:33%;">

<p>然后打开主题配置文件（<code>_config.yml</code>),在末尾添加：</p>
<pre class="language-none"><code class="language-none"># 文章末尾添加“本文结束”标记
passage_end_tag:
  enabled: true</code></pre>

<p>完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。</p>
<h3 id="代码复制和设置Mac风格"><a href="#代码复制和设置Mac风格" class="headerlink" title="代码复制和设置Mac风格"></a>代码复制和设置Mac风格</h3><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">copy_button</span><span class="token punctuation">:</span> <span class="token comment"># 复制代码按钮</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#原始false</span>
  <span class="token key atrule">show_result</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#原始true</span>
  <span class="token comment"># Available values: default | flat | mac</span>
  <span class="token key atrule">style</span><span class="token punctuation">:</span> mac <span class="token comment">#代码更换mac风格</span></code></pre>



<h3 id="添加本站运行时间和底部信息排列优化"><a href="#添加本站运行时间和底部信息排列优化" class="headerlink" title="添加本站运行时间和底部信息排列优化"></a>添加本站运行时间和底部信息排列优化</h3><p>打开<code>themes/next/layout/_partials/footer.njk</code>文件，在末尾加入如下代码：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 网站运行时间的设置 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>timeDate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入天数...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>times<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入时分秒...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">createtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> grt<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">"01/01/2022 00:00:00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处修改你的建站时间或者网站上线时间</span>
        now<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        days <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> grt <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">24</span><span class="token punctuation">;</span> dnum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>days<span class="token punctuation">)</span><span class="token punctuation">;</span>
        hours <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> grt <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> dnum<span class="token punctuation">)</span><span class="token punctuation">;</span> hnum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>hours<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>hnum<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>hnum <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token operator">+</span> hnum<span class="token punctuation">;</span><span class="token punctuation">}</span> minutes <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> grt <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span><span class="token number">60</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> dnum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> hnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mnum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>minutes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>mnum<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>mnum <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token operator">+</span> mnum<span class="token punctuation">;</span><span class="token punctuation">}</span>
        seconds <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> grt <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> dnum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> hnum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> mnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        snum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>snum<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>snum <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token operator">+</span> snum<span class="token punctuation">;</span><span class="token punctuation">}</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"timeDate"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"本站已运行 "</span><span class="token operator">+</span>dnum<span class="token operator">+</span><span class="token string">" 天 "</span><span class="token punctuation">;</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"times"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> hnum <span class="token operator">+</span> <span class="token string">" 小时 "</span> <span class="token operator">+</span> mnum <span class="token operator">+</span> <span class="token string">" 分 "</span> <span class="token operator">+</span> snum <span class="token operator">+</span> <span class="token string">" 秒"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token string">"createtime()"</span><span class="token punctuation">,</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>要是觉得时间有两行不好看的花，也可以将</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>timeDate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入天数...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>times<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入时分秒...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>改成以下代码</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>timeDate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入天数...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>times<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入时分秒...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span></code></pre>



<p>将访问人数和字数统计合并在同一行，用一个span标签包裹起来,在<code>themes/next/layout/_partials/footer.njk</code>这个文件中，找到<code>class="wordcount"</code>，将其标签从div改成span。<code>class="busuanzi-count"</code>这个div也同样改成span，然后再用一个span将它们两个包裹起来。</p>
<p><strong><font color="red">这里博主有个不明白的地方，span本来就是行内元素，假设有两个span为a和b，怎么两个span就变成了两行，然后将a和b这两个span用一个span包裹起来，它们就可以在同一行上了，如果有知道的大佬可以告知本菜鸡一些，不胜感激！</font></strong></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器操作记录</title>
    <url>/2022/02/01/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="阿里云服务器默认不开启-root-远程登录"><a href="#阿里云服务器默认不开启-root-远程登录" class="headerlink" title="阿里云服务器默认不开启 root 远程登录"></a>阿里云服务器默认不开启 root 远程登录</h3><p>需要先进行 VNC 远程连接登录，再进行实例登录。</p>
<p>可以在Mac的命令行进行登录</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token function">ssh</span> root@你的公网地址
password 你的密码</code></pre>

<span id="more"></span>

<h3 id="阿里云-centos-安装-nginx"><a href="#阿里云-centos-安装-nginx" class="headerlink" title="阿里云 centos 安装 nginx"></a>阿里云 centos 安装 nginx</h3><pre class="language-none"><code class="language-none">yum install nginx</code></pre>

<p>就一条命令就行，yum 会自动帮我们安装 nginx 所需要的依赖的</p>
<p>如果出现错误，那么就是 etc/yum.repos.d/CentOS-AppStream.repo 里面的镜像源出现了错误。</p>
<p>2022.02.16（出现了镜像源改变，所以我们需要改配置文件里面的路径）</p>
<p>将这个文件夹下的所有</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable">baseurl</span><span class="token operator">=</span>http://mirrors.cloud.aliyuncs.com/<span class="token variable">$contentdir</span>/<span class="token variable">$releasever</span>/AppStream/<span class="token variable">$basearch</span>/os/</code></pre>

<p>改成：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token assign-left variable">baseurl</span><span class="token operator">=</span>https://mirrors.aliyun.com/<span class="token variable">$contentdir</span>/<span class="token variable">$releasever</span>-stream/AppStream/<span class="token variable">$basearch</span>/os/</code></pre>

<p>比如：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># CentOS-AppStream.repo</span>
<span class="token comment">#</span>
<span class="token comment"># The mirror system uses the connecting IP address of the client and the</span>
<span class="token comment"># update status of each mirror to pick mirrors that are updated to and</span>
<span class="token comment"># geographically close to the client.  You should use this for CentOS updates</span>
<span class="token comment"># unless you are manually picking other mirrors.</span>
<span class="token comment">#</span>
<span class="token comment"># If the mirrorlist= does not work for you, as a fall back you can try the</span>
<span class="token comment"># remarked out baseurl= line instead.</span>
<span class="token comment">#</span>
<span class="token comment">#</span>

<span class="token punctuation">[</span>AppStream<span class="token punctuation">]</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span>CentOS-<span class="token variable">$releasever</span> - AppStream
<span class="token comment">#baseurl=http://mirrors.cloud.aliyuncs.com/$contentdir/$releasever/AppStream/$basearch/os/</span>
<span class="token comment">#改为下面这个</span>
<span class="token assign-left variable">baseurl</span><span class="token operator">=</span>http://mirrors.aliyuncs.com/<span class="token variable">$contentdir</span>/<span class="token variable">$releasever</span>-stream/AppStream/<span class="token variable">$basearch</span>/os/
<span class="token assign-left variable">gpgcheck</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token assign-left variable">gpgkey</span><span class="token operator">=</span>file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</code></pre>

<p>安装成功，配置端口之后重启服务即可</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马程序员C++提高编程笔记</title>
    <url>/2022/01/03/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C-%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="黑马程序员C-提高编程笔记"><a href="#黑马程序员C-提高编程笔记" class="headerlink" title="黑马程序员C++提高编程笔记"></a>黑马程序员C++提高编程笔记</h1><p>[toc]</p>
<h2 id="1-STL"><a href="#1-STL" class="headerlink" title="1. STL"></a>1. STL</h2><h3 id="1-1-STL"><a href="#1-1-STL" class="headerlink" title="1.1 STL"></a>1.1 STL</h3><ul>
<li>标准模版库（Standard Templete Library）</li>
</ul>
<span id="more"></span>

<h3 id="1-2-STL基本概念："><a href="#1-2-STL基本概念：" class="headerlink" title="1.2 STL基本概念："></a>1.2 STL基本概念：</h3><ul>
<li><p>STL六大组件：</p>
<ul>
<li>容器：各种数据结构、如vector、list、map、set、deque</li>
<li>算法：各种常见的算法、比如sort、find、copy、for_each</li>
<li>迭代器：扮演了容器和算法之间的粘合剂</li>
<li>仿函数：行为类似函数、可以作为 算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理</li>
</ul>
</li>
<li><p>容器就是用来存放数据的</p>
</li>
<li><p>STL容器就是将一些运用最广泛的数据结构实现出来</p>
</li>
<li><p>常用的数据结构：数组、链表、二叉树、栈、队列、集合、映射表</p>
</li>
<li><p>这些容器分为序列式容器和关联式容器</p>
<ul>
<li>序列式容器强调值的排序，里面每个值都有固定的位置</li>
<li>关联式容器：二叉树结构、各元素之间没有严格的物理上的顺序关系</li>
</ul>
</li>
</ul>
<h3 id="1-2-容器算法"><a href="#1-2-容器算法" class="headerlink" title="1.2 容器算法"></a>1.2 容器算法</h3><ul>
<li>算法<ul>
<li>算法就是用有限的步骤，解决数学或者逻辑上的问题</li>
<li>算法分为质变算法和非质变算法<ul>
<li>质变算法是指运算过程中会更改区间内的元素，例如拷贝、删除、替换</li>
<li>非质变算法是指运算过程中不会更改区间内的元素。例如查找、计数、遍历、寻找极值等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-迭代器"><a href="#1-3-迭代器" class="headerlink" title="1.3 迭代器"></a>1.3 迭代器</h3><ul>
<li>迭代器就是容器和算法之间的粘合剂<ul>
<li>提供一种方法，使之能够依序访问容器内的各个元素，而不暴露容器的内部表示方式</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  迭代器初识
//
//  Created by OnlyBei on 2021/9/24.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void myPrint(int val) {
    cout &lt;&lt; val &lt;&lt; endl;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    
    vector&lt;int&gt;::iterator pBegin = v.begin();
    vector&lt;int&gt;::iterator pEnd = v.end();
    
    // 第一种遍历方式
    while(pBegin != pEnd) {
        cout &lt;&lt; *pBegin &lt;&lt; endl;
        pBegin++;
    }
    
    // 第二种
    for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; endl;
    }
    
    for_each(v.begin(), v.end(), myPrint);
    
}
</code></pre>



<h3 id="1-4-vector存放自定义数组"><a href="#1-4-vector存放自定义数组" class="headerlink" title="1.4 vector存放自定义数组"></a>1.4 vector存放自定义数组</h3><pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  vector中存放自定义数据类型
//
//  Created by OnlyBei on 2021/9/24.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

class Person {
public:
    Person(string name, int age) {
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    }
public:
    string m_Name;
    int m_Age;
};

void test01() {
    vector&lt;Person&gt; v;
    
    Person p1("aaa", 10);
    Person p2("bbb", 20);
    Person p3("ccc", 30);
    Person p4("ddd", 40);
    
    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    
    for(vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) {
//        cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_Name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
        cout &lt;&lt; "姓名：" &lt;&lt; (*it).m_Name &lt;&lt; "年龄：" &lt;&lt; (*it).m_Age &lt;&lt; endl;

    }

}

void test02() {
    vector&lt;Person*&gt; v;
    
    Person p1("aaa", 10);
    Person p2("bbb", 20);
    Person p3("ccc", 30);
    Person p4("ddd", 40);
    
    v.push_back(&amp;p1); // 取地址
    v.push_back(&amp;p2);
    v.push_back(&amp;p3);
    v.push_back(&amp;p4);
    
    for(vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) {
      // 双重指针
//        cout &lt;&lt; "2姓名：" &lt;&lt; (*(*it)).m_Name &lt;&lt; "年龄：" &lt;&lt; (*(*it)).m_Age &lt;&lt; endl;
        cout &lt;&lt; "2姓名：" &lt;&lt; (*it)-&gt;m_Name &lt;&lt; "年龄：" &lt;&lt; (*it)-&gt;m_Age &lt;&lt; endl;

    }

}

int main(int argc, const char * argv[]) {
    // insert code here...
//    test01();
    test02();
}
</code></pre>



<h3 id="1-5-vector的嵌套结构"><a href="#1-5-vector的嵌套结构" class="headerlink" title="1.5 vector的嵌套结构"></a>1.5 vector的嵌套结构</h3><pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  vector中的嵌套数据类型
//
//  Created by OnlyBei on 2021/9/24.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void test() {
    vector&lt;vector&lt;int&gt; &gt; v;
    
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    vector&lt;int&gt; v3;
    vector&lt;int&gt; v4;
    
    for(int i = 0; i &lt; 4; i++) {
        v1.push_back(i);
        v2.push_back(i + 4);
        v3.push_back(i + 8);
        v4.push_back(i + 12);
    }
    
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);
    v.push_back(v4);
    
    for(vector&lt;vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end(); it++) {
        for(vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) {
            cout &lt;&lt; *vit &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }

}

int main(int argc, const char * argv[]) {
    // insert code here...
    test();
}
</code></pre>



<h2 id="2-String容器"><a href="#2-String容器" class="headerlink" title="2. String容器"></a>2. String容器</h2><h3 id="2-0-前置知识："><a href="#2-0-前置知识：" class="headerlink" title="2.0 前置知识："></a>2.0 前置知识：</h3><ul>
<li><p>在C语言中:</p>
<ul>
<li>char是定义一个字符，存储一个字符，占一个字节。</li>
<li>string是定义一个字符串，存储的是一段如“abcd”的数据，而且最后还有一个结束符’\0’。</li>
</ul>
</li>
<li><p>在C++中:</p>
<ul>
<li><p>string有两种，要区别理解；</p>
</li>
<li><p>第一种是字符串char[ ]，例如’a’是char, “a”是char string，这两者都是普通的字符和字符串，和C语言中没什么不同值得注意的是后者包含两个字符，末尾有一个隐身的’\0’。</p>
</li>
<li><p>第二种是封装好的字符串类，如string str = “a” 是C++ 封装好的string。</p>
</li>
<li><p>C++中的char string和string不是一回事。当用到了”string”这个关键词，就不是普通的字符串，而是用到了封装后的类。</p>
</li>
<li><p>在C++中，char仍然是一个primitive type(原始类型)，而string已经经过封装，成为了一个class(类)用到它时，我们需要 #include<string>，它是C++ Standard Library (C++标准库)的一部分。</string></p>
</li>
</ul>
</li>
<li><p>c中的char* 定义字符串，不能改变字符串内的字符的内容，但却可以把另外一个字符串赋给它。</p>
</li>
</ul>
<h3 id="2-1-String的基本概念"><a href="#2-1-String的基本概念" class="headerlink" title="2.1 String的基本概念"></a>2.1 String的基本概念</h3><ul>
<li>string是C++风格的字符串，而string本质是一个类</li>
<li>string和char *的区别<ul>
<li>char *是一个指针</li>
<li>string是一个类，类内部封装了char * ，管理这个字符串，是一个char * 的容器</li>
</ul>
</li>
<li>特点：<ul>
<li>string内部封装了很多成员方法</li>
<li>例如：find查找、insert插入、delete删除、replace替换、copy拷贝</li>
<li>string管理char*的内存，不用担心复制越界和取值越界等，由类内部负责</li>
</ul>
</li>
</ul>
<h3 id="2-2-String的构造函数"><a href="#2-2-String的构造函数" class="headerlink" title="2.2 String的构造函数"></a>2.2 String的构造函数</h3><ul>
<li>string();     //创建一个空的字符串，例如string str</li>
<li>string(const char* s);   // 使用字符串s初始化</li>
<li>string(const string&amp; str); // 使用一个string对象初始化另一个string对象</li>
<li>string(int n, char c); // 使用n个字符c初始化</li>
</ul>
<h3 id="2-3-Sring的赋值操作"><a href="#2-3-Sring的赋值操作" class="headerlink" title="2.3 Sring的赋值操作"></a>2.3 Sring的赋值操作</h3><ul>
<li>string&amp; operator = (const char* s);        //char*类型字符串，赋值给当前字符串</li>
<li>string&amp; operator = (const  string &amp;s);    //把字符串s赋值给当前字符串</li>
<li>string&amp; operator = (char c);                     //把字符赋值给当前字符串</li>
<li>string&amp; assign(const char* s);                //把字符串s赋值给当前字符串 </li>
<li>string&amp; assign(const char* s, int n);      //把字符串s的前n位赋值给当前字符串 </li>
<li>string&amp; assign(const stringr &amp;s);           //把字符串s赋值给当前字符串 </li>
<li>string&amp; assign(int n, char c);                   //用n个字符赋值给当前字符串</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  String的赋值操作
//
//  Created by OnlyBei on 2021/9/24.
//

#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void test() {
    string s1;
    s1 = "hello,world";
    cout &lt;&lt; "s1 = " &lt;&lt; s1 &lt;&lt; endl;
    
    string s2 = s1;
    cout &lt;&lt; "s2 = " &lt;&lt; s2 &lt;&lt; endl;
    
    string s3;
    s3 = "a";
    cout &lt;&lt; "s3 = " &lt;&lt; s3 &lt;&lt; endl;
    
    string s4;
    s4.assign("hello, c++");
    cout &lt;&lt; "s4 = " &lt;&lt; s4 &lt;&lt; endl;
    
    string s5;
    s5.assign("hello, c++", 5);
    cout &lt;&lt; "s5 = " &lt;&lt; s5 &lt;&lt; endl;
    
    string s6;
    s6.assign(s5);
    cout &lt;&lt; "s6 = " &lt;&lt; s6 &lt;&lt; endl;
    
    string s7;
    s7.assign(15, 'h');
    cout &lt;&lt; "s7 = " &lt;&lt; s7 &lt;&lt; endl;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    test();
}
</code></pre>



<h3 id="2-4-String字符串拼接"><a href="#2-4-String字符串拼接" class="headerlink" title="2.4 String字符串拼接"></a>2.4 String字符串拼接</h3><ul>
<li>string&amp; operator += (const char* str); // 重载+=操作符</li>
<li>string&amp; operator += (const char c); // 重载+=操作符</li>
<li>string&amp; operator += (const string&amp; str); // 重载+=操作符</li>
<li>string&amp; append(const char *s); // 把字符串s连接到当前字符串的结尾</li>
<li>string&amp; append(const char *s,int n);  // 把字符串s的前n位连接到当前字符串的结尾</li>
<li>string&amp; append(const string &amp;s); //同string&amp; operator += (const char* str)</li>
<li>string&amp; append(const string &amp;s, int pos, int n); // 字符串s从pos开始的n个字符拼接到当前字符串的尾部</li>
</ul>
<h3 id="2-5-String字符串的查找"><a href="#2-5-String字符串的查找" class="headerlink" title="2.5 String字符串的查找"></a>2.5 String字符串的查找</h3><ul>
<li>功能描述<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
</li>
<li>函数原型：<ul>
<li>int find(const string&amp; str, int pos = 0) const; // 查找str第一次出现的位置，从pos开始查找</li>
<li>Int find(cosnt char* s, int pos = 0) const; // 查找s第一次出现的位置，从pos开始查找</li>
<li>int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置</li>
<li>int find(const char c, int pos = 0) const; // 查找字符c第一次出现位置</li>
<li>int rfind(const string&amp; str, int pos = npos) const; // 查找str最后一次位置，从pos开始查找</li>
<li>int find(const char* s, int pos = npos) const;  // 查找s最后一次出现位置，从pos开始查找</li>
<li>int rfind(const char* s, int pos, int n) const;   //从pos查找s的前n个字符最后一次出现位置</li>
<li>int rfind(const char s, int pos = 0) const;  //查找字符c最后一次出现位置</li>
<li>string&amp; replace(int pos, int n , const string&amp; str); //替换从pos开始n个字符位字符串str</li>
<li>string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串</li>
</ul>
</li>
</ul>
<h3 id="2-6-String字符串比较"><a href="#2-6-String字符串比较" class="headerlink" title="2.6 String字符串比较"></a>2.6 String字符串比较</h3><ul>
<li><p>功能描述：</p>
<ul>
<li>字符串之间的比较</li>
</ul>
</li>
<li><p>比较方式：</p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
<li>=  的话返回 0</li>
<li><code>&gt;的话返回 1</code></li>
<li><code>&lt;的话返回 -1</code></li>
</ul>
</li>
<li><p>函数原型：</p>
<ul>
<li>int compare(const string &amp;s) const; //与字符串s进行比较</li>
<li>int compare(const char *s) const; //与字符串s进行比较</li>
</ul>
</li>
</ul>
<h3 id="2-7-String字符串的存取"><a href="#2-7-String字符串的存取" class="headerlink" title="2.7 String字符串的存取"></a>2.7 String字符串的存取</h3><ul>
<li>string中单个字符的存取有两种方式</li>
<li>char&amp; operator[] (int n); //通过[]方式取字符</li>
<li>Char&amp; at(int n); //通过at方式取字符</li>
</ul>
<p>修改的话直接，str[i] = “”; 或者 str.at(n) = “”;</p>
<h3 id="2-8-String插入和删除"><a href="#2-8-String插入和删除" class="headerlink" title="2.8 String插入和删除"></a>2.8 String插入和删除</h3><ul>
<li>功能描述：<ul>
<li>对string字符串进行插入和删除操作</li>
</ul>
</li>
<li>函数原型：<ul>
<li>string&amp; insert(int pos, const char* s); //插入字符串</li>
<li>string&amp; insert(int pos, const string&amp; s); //插入字符串</li>
<li>string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符串c</li>
<li>string&amp; erase(int pos, int n = npos); //删除从pos开始的n个字符</li>
</ul>
</li>
</ul>
<h3 id="2-9-String字符串子串"><a href="#2-9-String字符串子串" class="headerlink" title="2.9 String字符串子串"></a>2.9 String字符串子串</h3><ul>
<li>功能描述：<ul>
<li>从字符串中获取想要的子串</li>
</ul>
</li>
<li>函数原型：<ul>
<li>string substr(int pos = 0, int n = npos) const; // 返回从pos开始由n个字符组成的字符串</li>
</ul>
</li>
</ul>
<h2 id="3-Vector容器"><a href="#3-Vector容器" class="headerlink" title="3. Vector容器"></a>3. Vector容器</h2><h3 id="3-1-Vector基本概念"><a href="#3-1-Vector基本概念" class="headerlink" title="3.1 Vector基本概念"></a>3.1 Vector基本概念</h3><ul>
<li>功能：<ul>
<li>vector数据结构和数组非常相似，也称为单端数组</li>
</ul>
</li>
<li>vector与普通数组的区别<ul>
<li>vector可以动态扩展</li>
</ul>
</li>
<li>动态扩展：<ul>
<li>并不是在原有空间之后拼接新空间，而是找更大的内存空间，然后将数据拷贝到新空间，释放原空间</li>
</ul>
</li>
<li>vector容器迭代器是支持随机访问的一个迭代器</li>
</ul>
<h3 id="3-2-Vector容量和大小"><a href="#3-2-Vector容量和大小" class="headerlink" title="3.2 Vector容量和大小"></a>3.2 Vector容量和大小</h3><ul>
<li>功能描述：<ul>
<li>对vector的容器的容量和大小进行操作</li>
</ul>
</li>
<li>函数原型<ul>
<li>empty();     //判断容器是否为空</li>
<li>capacity(); //容器的容量</li>
<li>size(); //返回容器中元素的个数</li>
<li>resize(int num); //重新指定容器的大小为num，若容器变长，则以默认值填充新位置，若变短，则末尾超出容器元素被删除</li>
<li>resize(int num, in elem);//重新指定容器的大小为num，若容器变长，则以elem值填充新位置，若变短，则末尾超出容器元素被删除</li>
</ul>
</li>
</ul>
<h3 id="3-3-Vector容器的插入和删除"><a href="#3-3-Vector容器的插入和删除" class="headerlink" title="3.3 Vector容器的插入和删除"></a>3.3 Vector容器的插入和删除</h3><ul>
<li>push_back(); //尾插法</li>
<li>pop_back(); // 删除尾部的元素</li>
<li>clear(); //删除容器中所有元素</li>
<li>front(); // 返回容器中第一个元素</li>
<li>back(); // 返回容器中最后一个元素</li>
<li>swap(); //实现两个容器进行互换操作，实现内存收缩的效果<ul>
<li>用swap可以玩很多花样</li>
<li><a href="https://blog.csdn.net/m0_37251750/article/details/100071023">一篇关于swap写的很好的博客</a></li>
</ul>
</li>
<li>reverse(int len); //容器预留len个元素长度，预留位置不初始化，元素不可访问</li>
</ul>
<h2 id="4-deque容器"><a href="#4-deque容器" class="headerlink" title="4. deque容器"></a>4. deque容器</h2><h3 id="3-1-deque容器基本概念"><a href="#3-1-deque容器基本概念" class="headerlink" title="3.1 deque容器基本概念"></a>3.1 deque容器基本概念</h3><ul>
<li>功能<ul>
<li>双端数组，可以对头端进行插入删除</li>
</ul>
</li>
<li>deque的区别<ul>
<li>vector对于头部的插入删除效率低、数据量越大、效率越低</li>
<li>deque相对而言，在头部进行数据插入删除的效率比vector高</li>
<li>vector访问元素的速度比deque快，这是由两者的内部实现有关</li>
</ul>
</li>
</ul>
<h2 id="5-List容器"><a href="#5-List容器" class="headerlink" title="5. List容器"></a>5. List容器</h2><h3 id="5-1-list基本概念"><a href="#5-1-list基本概念" class="headerlink" title="5.1 list基本概念"></a>5.1 list基本概念</h3><ul>
<li>功能<ul>
<li>将数据进行链式存储</li>
<li>链表（list）是一种物理存储非连续的物理结构，数据元素的逻辑顺序是通过指针链接实现的</li>
<li>STL中的链表是一个双向循环链表</li>
</ul>
</li>
</ul>
<h2 id="6-Set容器"><a href="#6-Set容器" class="headerlink" title="6.Set容器"></a>6.Set容器</h2><ul>
<li>set简介<ul>
<li>所有元素在插入时会自动排序</li>
</ul>
</li>
<li>本质<ul>
<li>set/multiset属于关联式容器，底层用二叉树实现</li>
</ul>
</li>
<li>set不允许用重复元素</li>
<li>multiset允许重复元素</li>
</ul>
<h2 id="7-Map容器"><a href="#7-Map容器" class="headerlink" title="7.Map容器"></a>7.Map容器</h2><ul>
<li><p>简介：</p>
<ul>
<li>map中所有元素都是pair（对组）</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（元素）</li>
<li>所有元素都会按照key值进行排序</li>
</ul>
</li>
<li><p>本质</p>
<ul>
<li>map/multimap属于关联式容器，底层用二叉树实现</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li>map不允许用重复元素</li>
<li>multimap允许重复元素</li>
</ul>
</li>
</ul>
<h2 id="8-谓词"><a href="#8-谓词" class="headerlink" title="8. 谓词"></a>8. 谓词</h2><h3 id="8-1-谓词概念"><a href="#8-1-谓词概念" class="headerlink" title="8.1 谓词概念"></a>8.1 谓词概念</h3><ul>
<li>概念：<ul>
<li>返回布尔类型的仿函数称为谓词</li>
<li>如果operator（）接受一个参数，那么叫做一元谓词</li>
<li>如果operator（）接受两个参数，那么叫做二元谓词</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  谓词
//
//  Created by OnlyBei on 2021/9/25.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class getFive{
public:
    bool operator()(int val) { // 仿函数为什么这样写呢，可以看下面一段代码的源码
        return val &gt; 5;
    }
};

void test() {
    vector&lt;int&gt; v;
    for(int i = 0; i &lt; 10; i++) {
        v.push_back(i);
    }
    
    // getFive()是一个仿函数
    vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), getFive());
    
    if(it != v.end()) {
        cout &lt;&lt; "找到了 " &lt;&lt; *it &lt;&lt; endl;
    }else {
        cout &lt;&lt; "未找到" &lt;&lt; endl;
    }
    
}

int main(int argc, const char * argv[]) {
    // insert code here...
    test();
}
</code></pre>



<pre class="language-c++" data-language="c++"><code class="language-c++">find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first)) // 如果这个为真，则跳出循环，放回一个迭代器
            break;
    return __first; 
}</code></pre>



<ul>
<li><p>二元谓词</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  谓词
//
//  Created by OnlyBei on 2021/9/25.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class FuncSort {
public:
    bool operator() (int a, int b) {
        return a &gt; b;
    }
};

void test02() {
    vector&lt;int&gt; v1;
    v1.push_back(10);
    v1.push_back(30);
    v1.push_back(80);
    v1.push_back(50);
    v1.push_back(20);
    
//    sort(v1.begin(), v1.end()); // 默认从小打大
    sort(v1.begin(), v1.end(), FuncSort());
    
    for(vector&lt;int&gt;::iterator it = v1.begin(); it != v1.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

}

int main(int argc, const char * argv[]) {
    test02();
}
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马程序员C++核心编程笔记</title>
    <url>/2022/01/03/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="黑马程序员C-核心编程笔记"><a href="#黑马程序员C-核心编程笔记" class="headerlink" title="黑马程序员C++核心编程笔记"></a>黑马程序员C++核心编程笔记</h2><p>[toc]</p>
<h2 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h2><h3 id="0-基础知识"><a href="#0-基础知识" class="headerlink" title="0.基础知识"></a>0.基础知识</h3><p>结构体：</p>
<ul>
<li>  结构体属于用户自定义的类型，允许用户存储不同的数据</li>
</ul>
<p>C语言和C++结构体的区别</p>
<span id="more"></span>

<ul>
<li>  在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private</li>
</ul>
<h3 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1. 内存分区模型"></a>1. 内存分区模型</h3><p>c++在执行时，将内存大方向划分为4个区域</p>
<p>●    代码区：存放函数体的二进制代码，由操作系统进行管理。</p>
<ul>
<li>  代码区是共享和只读的</li>
</ul>
<p>●    全局区：存放全局变量和静态变量以及常量。</p>
<ul>
<li>  全局区还包含了常量区：字符串常量和const修饰的全局常量也存放在此</li>
<li>  该区域的数据在程序结束后由操作系统释放</li>
</ul>
<p>●    栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。局部常量也是存放在栈区的</p>
<p>●    堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p>
<p><strong>内存四区的意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。</p>
<h4 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h4><p>在程序编译以后，生成了exe可执行程序，<strong>未执行程序前</strong>分为两个区域。</p>
<p><strong>代码区</strong>：    </p>
<p>​        存放CPU执行的机器指令</p>
<p>​        代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>
<p>​        代码区是只读的，为了防止程序意外的修改它的指令，造成损失。</p>
<p><strong>全局区</strong>：</p>
<p>​        全局变量和静态变量存放于此。</p>
<p>​        全局区还包含了常量区，字符串常量和其他常量存放于此。</p>
<p>​        该区域的数据在程序结束后由操作系统释放。</p>
<p>​        （在函数中的变量都是局部变量。全局变量就是写在函数外的。）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro09wr02j30wm09uq5a.jpg"></p>
<p><strong>总结：</strong></p>
<p>​        ●    C++在程序运行前分为全局区和代码区。</p>
<p>​        ●    代码区的特点是共享和只读</p>
<p>​        ●    全局区中存放全局变量，静态变量，常量</p>
<p>​        ●    常量区中存放const修饰的全局常量和字符串常量</p>
<h4 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h4><p>​    <strong>栈区：</strong></p>
<p>​            由编译器自动分配释放，存放函数的参数值，局部变量等。</p>
<p>​            注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

//栈区数据注意事项：不要返回局部变量的地址
//栈区的数据由编译器管理开发的释放

int *func()	//形参数据也会放在栈区
{
    int a = 10;	//局部变量：存放在栈区，栈区的数据在函数执行完后自动释放
    return &amp;a;	//返回局部变量的地址
}	

int main()
{
  	//接受func函数的返回值
    int *p = func();
    cout &lt;&lt; *p &lt;&lt; endl;	//第一次可以打印正确的数字，是因为编译器做了保留
    cout &lt;&lt; *p &lt;&lt; endl;	//没有保留
}</code></pre>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro6fredqj30va07aq3n.jpg"></p>
<p>​    <strong>堆区：</strong></p>
<p>​            由程序员分配释放，若程序员不释放，程序结束时由操作系统释放。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

int *func()
{
  	//利用new关键字 将数据开辟到堆区
  	//new int(188)返回的是一个地址，所有用指针去接受地址
  	//指针本质上也是局部变量，放在栈上，指针保存的数据是放在堆区
    int *p=new int(188);	//小括号里面就是堆区开辟地址初始值。
    return p;

}
int main()
{
  	//在堆区开辟数据
    int *p=func();
    cout&lt;&lt;*p&lt;&lt;endl;
    cout&lt;&lt;*p&lt;&lt;endl;
}</code></pre>



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro7o51hzj30j607gjrm.jpg" style="zoom:67%;">

<p>​    <strong>总结：</strong></p>
<p>​            堆区数据有程序员管理开辟和释放。</p>
<p>​            堆区数据利用new关键字进行开辟内存。            </p>
<p>​            </p>
<h4 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h4><p>​        </p>
<p>​        C++中利用new操作符在堆区开辟数据</p>
<p>​        堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete</p>
<p>​        语法：new 数据类型</p>
<p>​        利用new创建的数据，会返回该数据对应的类型的指针</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int *func()
{
    //在堆区创建整型数据
    //new返回的是 该创建数据类型的指针
    //int* 是接受这个地址并且解引用
    int *a = new int(18);
    return a;
}

void test01()
{
    int *p = func();
    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; *p &lt;&lt; endl;
    delete p;
    cout &lt;&lt; *p &lt;&lt; endl;	//不知道为什么，这个在Mac上的vscode上可以输出
}

void test02()
{
    //创建一个10整型数据的数组，在堆区
    int *arr = new int[10]; //代表数组由10个元素
  
    for (int i = 0; i &lt; 10; i++)
    {
        arr[i] = i + 100;
    }
  
    for (int i = 0; i &lt; 10; i++)
    {
        cout &lt;&lt; arr[i] &lt;&lt; endl;
    }
  	//释放堆区数组
  	//如果不加[],只释放了第一个指针，后面的指针被称为野指针。
  	delete[] arr;
}

int main()
{
    test01();
  
    test02();
}
</code></pre>



<h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h3><h4 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h4><p>作用：给变量起别名 </p>
<p>语法：数据类型 &amp;别名 = 原名</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro8f0t2fj30vg0ggwip.jpg"></p>
<h4 id="2-2-引用的注意事项"><a href="#2-2-引用的注意事项" class="headerlink" title="2.2 引用的注意事项"></a>2.2 引用的注意事项</h4><p>​    ●    引用必须初始化</p>
<p>​    ●    引用在初始化后，不可以改变</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

//引用必须要初始化 如int &amp;b；是错误的
//引用一旦初始化后，局部可以更改
int main()
{
    int a = 10;
    int &amp;b = a;
    cout &lt;&lt; b &lt;&lt; endl;
    int c = 30;
    b = c;  //这是赋值操作，不是更改引用

    cout &lt;&lt; b &lt;&lt; endl;
}</code></pre>



<h4 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h4><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>
<p>优点：可以简化指针修改实参</p>
<p>代码：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;


//  值传递
void swap01(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

//  地址传递
void swap02(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

//  引用传递
void swap03(int &amp;a, int &amp;b)
{
    int temp = a;
    a = b;
    b = temp;
}
int main()
{
    int a=11;
    int b=888;
    swap01(a,b);
    cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;"\tb="&lt;&lt;b&lt;&lt;endl;

    swap02(&amp;a,&amp;b);
    cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;"\tb="&lt;&lt;b&lt;&lt;endl;


    int c=777;
    int d=12222;
    swap03(c,d);
    cout&lt;&lt;"c="&lt;&lt;c&lt;&lt;"\td="&lt;&lt;d&lt;&lt;endl;
}</code></pre>

<p>运行结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro9g1dnvj30vc06igme.jpg"></p>
<p>总结：总结：通过引用参数产生的效果同按地址传递是一样的，引用的语法更清楚简单。</p>
<h4 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h4><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int &amp;test01()
{
    int a = 10;
    //return a;
}

int &amp;test02()
{
    static int a = 99;
    return a;
}

int main()
{

    //不能返回局部变量的引用
    int &amp;ret = test01();
		//非法操作
    cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl;
    cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl;

    //如果函数做左值，那么必须返回引用
    int &amp;ret2 = test02();

    cout &lt;&lt; "ret=" &lt;&lt; ret2 &lt;&lt; endl;
    cout &lt;&lt; "ret=" &lt;&lt; ret2 &lt;&lt; endl;

    test02() = 1000;
    cout &lt;&lt; "ret=" &lt;&lt; ret2 &lt;&lt; endl;
    cout &lt;&lt; "ret=" &lt;&lt; ret2 &lt;&lt; endl;
}</code></pre>



<h4 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h4><p>本质：<strong>引用的本质在c++内部实现是一个指针常量</strong></p>
<p>也就是指针的指向不可以更改，而指针指向的值可以改，也就符合了引用定义后就不能修改的原则</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

// 发现是引用 转换为int* const ref = &amp;a；
void func(int &amp;ref)
{
    ref=100; // ref是引用，转换为*ref = 100
}


int main()
{
    int a=11;

    //自动转换为int* const ref = &amp;a；指针常量是指针指向不可改，也说明为什么引用不可改
    int &amp;ref=a;
    ref=20; // 发现是引用 转换为*ref = 20；

    cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;"ref="&lt;&lt;ref&lt;&lt;endl;

    func(a);
    return 0;
}</code></pre>

<p>总结：C++推荐用引用技术，是因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了。</p>
<h4 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqsehx3ealj31180sg15a.jpg"> </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqse66vlomj31ai0n0anv.jpg"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

// 引用使用的场景，通常用来修饰形参,如果不加const，就会可能无意被修改，特别是以后代码量大的时候，
// 可能会忘记自己曾经写的这个值能不能改
void showValue(int &amp;val)
{
    val=10088;
    cout &lt;&lt; val &lt;&lt; endl;
}

void showValueTwo(const int &amp;val)
{
    // val=888; // 错误，这里就不能改了
    cout&lt;&lt;val&lt;&lt;endl;
}


int main()
{

    // 函数中利用常量引用防止误操作修改实参
    int a = 10;
    showValue(a);

    cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
}</code></pre>



<h3 id="3-函数的提高"><a href="#3-函数的提高" class="headerlink" title="3. 函数的提高"></a>3. 函数的提高</h3><h4 id="3-1-函数的默认参数"><a href="#3-1-函数的默认参数" class="headerlink" title="3.1 函数的默认参数"></a>3.1 函数的默认参数</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqsemgo09fj314y0ssqec.jpg"></p>
<h4 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h4><p>c++中函数的参数列表可以用占位参数，用来做占位，调用函数时必须填补该位置。</p>
<p>语法：返回值类型 函数名 （数据类型）{}</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqses5y3bhj30rc0dgdkh.jpg"></p>
<p>也可以这些写</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqsesmh6elj30v80k0tif.jpg" style="zoom: 50%;">



<h4 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h4><h5 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h5><p> <strong>作用：函数名可以相同，提高复用性</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqsezyq7mvj313m0tqk4p.jpg"></p>
<h5 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h5><p>● 引用作为重载条件</p>
<p>● 函数重载碰到函数默认参数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

// 函数重载的注意事项
// 1.引用作为重载的条件
//假如func(10)调用的是这个的话，那么是int &amp;a = 10； 不合法
// 10存储在全局区的常量区，而引用必须要一个合法的内存空间，要么在栈区要么在堆区。
// 所以这样引用明显不合法
void func(int &amp;a) 
{
    cout&lt;&lt;"func(int &amp;a)'s call of"&lt;&lt;endl;
}


void func(const int &amp;a) // const int &amp;a = 10;
{
    cout&lt;&lt;"func(const int &amp;a)'s call of"&lt;&lt;endl;
}

void func2(int a,int b=10)
{
    cout&lt;&lt;"func(int a,int b=10)'s call of"&lt;&lt;endl;
}


void func2(int a)
{
    cout&lt;&lt;"func(int a)'s call of"&lt;&lt;endl;
}


int main()
{
    int a=10; //调用的是a是一个变量，可读可写，所以引用的是第一个函数
    func(a);

    func(10); //

    // !func2(10); error 
    // because There are 
    // multiple instances of overloaded function "func2" 
    // that match the parameter list
    return 0;

}</code></pre>

<p>总结：</p>
<p>● 写函数重载的时候不要写默认参数，容易发生错误。</p>
<h3 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4.类和对象"></a>4.类和对象</h3><h4 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h4><h5 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h5><p>构造函数：</p>
<pre class="language-none"><code class="language-none">1. 构造函数没有返回值
2. 构造函数可以重载
3. 程序在调用对象时会自动调用构造，而且只调用一次</code></pre>

<p>析构函数：</p>
<pre class="language-none"><code class="language-none">1. 析构函数没有返回值
2. 析构函数没有参数不可以重载
3. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次</code></pre>

<h5 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h5><p>两种分类方式：</p>
<p>​    按参数分为：有参构造和无参构造</p>
<p>​    按类型分为：普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​    括号法 </p>
<p>​    显示法</p>
<p>​    隐式转换法</p>
<p><font color="red">example：</font></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Person
{
private:
    /* data */
public:
    Person();
    Person(int a);
    Person(const Person &amp;a);
    ~Person();
    int age;
};

Person::Person()
{
    cout &lt;&lt; "Person's call of nonparametric constructor" &lt;&lt; endl;
}

Person::Person(int a)
{
    age = a;
    cout &lt;&lt; "Person's call of parametric constructor" &lt;&lt; endl;
}

Person::Person(const Person &amp;p) //就是把一个对象的所有值拷贝给另一个对象
{
    age = p.age;
    cout &lt;&lt; "Person's call of copy constructor" &lt;&lt; endl;
}

Person::~Person()
{
    cout &lt;&lt; "Person's call of destructor" &lt;&lt; endl;
}

// call fo
void test01()
{
    // 1.括号法
    // Person p1;     //默认构造函数调用
    // Person p2(10); // 有参构造函数
    // Person p3(p2); //拷贝构造函数

    //! 注意事项
    // 调用默认构造函数的时候，不要加（）
    // 因为下面这行代码，编译器会认为是一个函数的声明，不会认为在创建对象

    //? Person p1();
    // 比如 void test(); 这样

    // cout &lt;&lt; "p2's age:" &lt;&lt; p2.age &lt;&lt; endl;
    // cout &lt;&lt; "p3's age:" &lt;&lt; p3.age &lt;&lt; endl;

    // 2.显示法

    // Person p11;
    // Person p21 = Person(10); //有参调用
    // Person p31 = Person(p21); //拷贝构造函数

    // Person(20); // 匿名对象 // 特点：当前行执行结束后，系统会立即回收匿名对象
    // cout &lt;&lt; "aaaaa" &lt;&lt; endl;

    // 注意事项2: 

    // 不要利用拷贝构造函数初始化匿名对象
    // 编译器会认为是 Person （p3） == Person p3；

    //Person(p31); 

    // 3.隐式调用
    Person p4=10; // Person p4 = Person(10);
    Person p5=p4;

}

int main()
{
    test01();

    return 0;
}</code></pre>



<h5 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Person
{
private:
    /* data */
public:
    Person();
    Person(int a);
    Person(const Person &amp;a);
    ~Person();
    int m_age;
};

Person::Person()
{
    // 无参构造，也就是默认构造
    cout &lt;&lt; "Person's call of nonparametric constructor" &lt;&lt; endl;
}

Person::Person(int age)
{
    m_age = age;
    cout &lt;&lt; "Person's call of parametric constructor" &lt;&lt; endl;
}

Person::Person(const Person &amp;p)
{
    m_age = p.m_age;
    cout &lt;&lt; "Person's call of copy constructor" &lt;&lt; endl;
}

Person::~Person()
{
    cout &lt;&lt; "Person's call of destructor" &lt;&lt; endl;
}

// 1.使用一个以及创建完毕的对象来初始化一个新对象
void test01()
{
    
    Person p1(20);
    Person p2(p1);

    cout &lt;&lt; "p2's age is:" &lt;&lt; endl;
}

// 2.值传递的方式给函数参数传值
void doWork(Person p)
{

}

void test02()
{
    Person p; // 默认构造
    doWork(p); // 拷贝构造
}

// 3.值方式返回局部对象

Person dowork2()
{
    Person p11;
    cout&lt;&lt;(int*)&amp;p11&lt;&lt;endl;
    return p11; // 拷贝构造
}

void test03()
{
    Person p=dowork2();
    cout&lt;&lt;(int*)&amp;p&lt;&lt;endl;
}

int main()
{
    //test01();
    test03();
    return 0;
}</code></pre>



<h5 id="4-2-4-拷贝构造函数调用规则"><a href="#4-2-4-拷贝构造函数调用规则" class="headerlink" title="4.2.4 拷贝构造函数调用规则"></a>4.2.4 拷贝构造函数调用规则</h5><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<ol>
<li> 默认构造函数（无参，函数体为空）</li>
<li> 默认析构函数（无参，函数体为空）</li>
<li> 默认拷贝构造函数，对属性进行值拷贝</li>
</ol>
<p>构造函数调用规则如下:</p>
<p>● 如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造<br>● 如果用户定义拷贝构造函数, C++不会再提供其他构造函数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class Person {
public:
	Person() {
		cout &lt;&lt; "无参构造函数!" &lt;&lt; endl;
		mAge = 0;
	}
	Person(int age) {
		cout &lt;&lt; "有参构造函数!" &lt;&lt; endl;
		mAge = age;
	}
	Person(const Person&amp; p) {
		cout &lt;&lt; "拷贝构造函数!" &lt;&lt; endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout &lt;&lt; "析构函数!" &lt;&lt; endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;
}


int main() {

	//test01();
	//test02();
	test03();

	system("pause");

	return 0;
}
</code></pre>



<h5 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h5><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<h5 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt; 
using namespace std;

class Student {
public:
  Student(int a, int s, int h):m_Age(a), m_Score(s), m_Hight(h){}
private:
  int m_Age;
  int m_Score;
  int m_Hight;
}

int main() {
  Student s1;
  return 0;
}</code></pre>



<h5 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt; 
using namespace std;

class Phone {
public:
  Phone(string name) {
    m_PhoneName = name;
  }
  string m_PhoneName;
}

class Student {
public:
  Student(int a, int s, int h):m_Age(a), m_Score(s), m_Hight(h){}
  Phone m_Phone;
private:
  int m_Age;
  int m_Score;
  int m_Hight;
}

int main() {
  Student s1;
  return 0;
}</code></pre>



<h5 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h5><p>静态成员就是类中的成员变量和成员函数前面加上static，就是静态成员</p>
<ul>
<li>静态成员变量：<ul>
<li>  所有对象共享一份数据</li>
<li>  在编译阶段分配内存</li>
<li>  类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数：<ul>
<li>  所有对象共享一个函数</li>
<li>  静态成员函数只能访问静态成员变量</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h4><h5 id="4-3-2-成员变量和成员函数分开存储"><a href="#4-3-2-成员变量和成员函数分开存储" class="headerlink" title="4.3.2 成员变量和成员函数分开存储"></a>4.3.2 成员变量和成员函数分开存储</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

// 类的大小为类的非静态成员变量
// 类的成员函数和静态成员函数不在类的存储空间中
// 此时类的大小为4
class Person {
  static int m_Score;
  int m_Age;
  void run() {
    cout &lt;&lt; "run" &lt;&lt; endl;
  }
}

// 空类的大小为1
class Person1 {
  
}

int main() {
  cout &lt;&lt; sizeof(Person()) &lt;&lt; endl;
  return 0;
}</code></pre>

<h5 id="4-3-2-this指针"><a href="#4-3-2-this指针" class="headerlink" title="4.3.2 this指针"></a>4.3.2 this指针</h5><p>通过前面一节我们知道C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型对象会共用一块代码</p>
<p>那么这一块代码究竟是怎么区分那个对象调用自己的呢</p>
<p>C++通过提供特殊对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<p><code>this指针的本质是指针常量，this的指向不可以改变</code></p>
<ul>
<li>  当形参和成员变量同名时，用来区分二者</li>
<li>  在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  this指针
//
//  Created by ChengBei's iMac on 2021/9/8.
//

#include &lt;iostream&gt;
using namespace std;

class Person {
public:
    Person(int age) {
        m_Age = age;
    }
    void addPersonAge(int age) {
        m_Age = m_Age + age;
    }
    
    // 返回类的本身，可以链式调用
    // 这里为什么要返回引用呢，因为要引用传递，放回这个类的本身，而不是它的拷贝
    Person&amp; addPersonAgeTwo(int age) {
        m_Age += age;
        return *this; // 为什么返回的是this呢，因为this指向的是这个对象的指针，所以*this是这个对象本身
    }
    int m_Age = 0;
};

int main(int argc, const char * argv[]) {
    
    Person p1(10);
    p1.addPersonAge(10);
    
    Person p2(20);
    p2.addPersonAgeTwo(30).addPersonAge(20);
    cout &lt;&lt; p1.m_Age &lt;&lt; endl;
    cout &lt;&lt; p2.m_Age &lt;&lt; endl;
    return 0;
}
</code></pre>

<h5 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h5><p>常函数：</p>
<ul>
<li>  成员函数前面加上const后称为常函数</li>
<li>  常函数内不可以修改成员属性</li>
<li>  成员属性内加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p>常对象：</p>
<ul>
<li>  声明对象前加const称该对象为常对象</li>
<li>  常对象只能调用常函数</li>
</ul>
<h4 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h4><h5 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h5><p>作用：实现两个自定义数据的相加</p>
<h5 id="4-5-6-继承同名成员处理方式"><a href="#4-5-6-继承同名成员处理方式" class="headerlink" title="4.5.6 继承同名成员处理方式"></a>4.5.6 继承同名成员处理方式</h5><ol>
<li>  子类对象可以直接访问到子类中同名成员</li>
<li>  子类对象加作用域可以访问到父类同名成员</li>
<li>  当子类与父类拥有同名的成员函数，子类会隐藏父类中的成员函数，这时候加作用域可以访问到父类中的成员函数</li>
</ol>
<h3 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5. 文件操作"></a>5. 文件操作</h3><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放。</p>
<p>通过文件可以将数据存储。</p>
<p>文件类型分为两种：</p>
<p>1.文本文件：文件以文本ASCII码形式存储在计算机中</p>
<p>2.二进制文件：文件以文本二进制形式存储在计算机中</p>
<p>操作文件三大类：</p>
<ol>
<li> ofstream：写操作</li>
<li> ifstream：读操作</li>
<li> fstream：读写操作</li>
</ol>
<h4 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h4><h5 id="4-7-1-多态的基本概念："><a href="#4-7-1-多态的基本概念：" class="headerlink" title="4.7.1 多态的基本概念："></a>4.7.1 多态的基本概念：</h5><p>多态分为两类：</p>
<ul>
<li>  静态多态：函数重载和运算符重载属于静态多态，复用函数名</li>
<li>  动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态的区别：</p>
<ul>
<li>  静态多态的地址早绑定  - 编译阶段确定函数地址</li>
<li>  动态多态的地址晚绑定 - 运行阶段确定函数地址（因为运行时才确定到底走哪个函数）</li>
</ul>
<h5 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h5><p>多态使用时，如果子类有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为虚析构或纯虚析构</p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>  可以解决父类指针释放子类对象的问题</li>
<li>  都需要有具体的函数实现</li>
</ul>
<p>区别：</p>
<ul>
<li>  如果是纯虚析构，该类属于抽象类，无法实例化</li>
</ul>
<p>总结：</p>
<ol>
<li>  虚析构和纯虚析构就是用来解决通过父类指针释放子类对象的</li>
<li>  如果子类中没有堆区数据，可以不写虚析构或纯虚析构</li>
<li>  拥有纯虚析构的函数也属于抽象类</li>
</ol>
<h4 id="5-1-文本文件"><a href="#5-1-文本文件" class="headerlink" title="5.1 文本文件"></a>5.1 文本文件</h4><h5 id="5-1-1-写文件"><a href="#5-1-1-写文件" class="headerlink" title="5.1.1 写文件"></a>5.1.1 写文件</h5><p>写文件步骤如下：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">1.包含头文件
	#include&lt;fstream&gt;

2.创建流对象
  ofstream.ofs;

3.打开文件
  ofs.open("文件路径",打开方式)；
  
4.写数据
  ofs&lt;&lt;"写入"；
  
5.关闭文件
  ofs.close();</code></pre>



<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th align="center">打开方式</th>
<th align="center">解释:</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::in</td>
<td align="center">为读文件而打开文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::out</td>
<td align="center">为写文件而打开文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">初始位置：文件尾</td>
<td></td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">追加方式写文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">如果文件存在先删除，再创建</td>
<td></td>
</tr>
<tr>
<td align="center">iOS::binary</td>
<td align="center">二进制方式</td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意：文件打开方式可以配合|使用</strong></p>
<p><strong>用二进制方式写文件 ios::binary | ios::out</strong></p>
<h5 id="5-1-2-读文件"><a href="#5-1-2-读文件" class="headerlink" title="5.1.2 读文件"></a>5.1.2 读文件</h5><p>写文件步骤如下：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">1.包含头文件
	#include&lt;fstream&gt;

2.创建流对象
  ifstream ifs;

3.打开文件
  ofs.open("文件路径",打开方式)；
  
4.写数据
  四种方式读取
  
5.关闭文件
  ifs.close();</code></pre>



<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th align="center">打开方式</th>
<th align="center">解释:</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::in</td>
<td align="center">为读文件而打开文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::out</td>
<td align="center">为写文件而打开文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">初始位置：文件尾</td>
<td></td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">追加方式写文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">如果文件存在先删除，再创建</td>
<td></td>
</tr>
<tr>
<td align="center">iOS::binary</td>
<td align="center">二进制方式</td>
<td></td>
</tr>
</tbody></table>
<h4 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h4><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ios::binary</p>
<h5 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h5><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;fstream&gt;
#include &lt;string&gt;

using namespace std;

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

//二进制文件  写文件
void test01()
{
	//1、包含头文件

	//2、创建输出流对象
	ofstream ofs("person.txt", ios::out | ios::binary);
	
	//3、打开文件
	//ofs.open("person.txt", ios::out | ios::binary);

	Person p = {"张三"  , 18};

	//4、写文件
	ofs.write((const char *)&amp;p, sizeof(p));

	//5、关闭文件
	ofs.close();
}

int main() {

	test01();
	return 0;
}
</code></pre>

<p>总结：</p>
<ul>
<li>  文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h5 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h5><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

void test01()
{
	ifstream ifs("person.txt", ios::in | ios::binary);
	if (!ifs.is_open())
	{
		cout &lt;&lt; "文件打开失败" &lt;&lt; endl;
	}

	Person p;
	ifs.read((char *)&amp;p, sizeof(p));

	cout &lt;&lt; "姓名： " &lt;&lt; p.m_Name &lt;&lt; " 年龄： " &lt;&lt; p.m_Age &lt;&lt; endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>





<pre class="language-none"><code class="language-none">class Solution {
public:
    int integerBreak(int n) {
        vector&lt;int&gt; dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i &lt;= n ; i++) {
            for (int j = 1; j &lt; i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};

5
i = 3 dp[3] = </code></pre>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
