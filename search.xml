<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022的日常</title>
    <url>/2022/01/10/2022%E7%9A%84%E6%97%A5%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="January"><a href="#January" class="headerlink" title="January"></a>January</h3><span id="more"></span>

<p>1-10</p>
<p>学习从懒散恢复状态，开始啃红宝书以及写文档输出。肩胛骨疼痛的症状也缓解了不少。果然打游戏是一件脑力和体力活。对身体确实不太好。</p>
<p>1-16</p>
<p>今天坐高铁回家，因为宿舍天天吵到晚上两三点，而自己想要一个更安静的环境学习，所以跑路回家。回来收拾了房间和行李，整顿好电脑桌显示器。明天准备开工干项目。</p>
<p>现在准备泡个脚睡个早觉，明天早起把coderwhy的react一到六复习一遍，将代码再打一遍，然后继续一天两集react两道算法题一篇面经的节奏。11:29</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>生活&amp;记录</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote02:了解JSX语法</title>
    <url>/2022/01/12/ReactNote02:%E4%BA%86%E8%A7%A3JSX%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="欲要学好React，JSX语法须先行"><a href="#欲要学好React，JSX语法须先行" class="headerlink" title="欲要学好React，JSX语法须先行"></a>欲要学好React，JSX语法须先行</h3><h3 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h3><p>先来看这样的一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</span><br></pre></td></tr></table></figure>

<p>是不是感觉有点怪怪的，因为它既不是字符串，也不是HTML，它就是 JSX，是一个 JavaScript 的语法扩展。React官方建议在 React 中配合使用 JSX，因为JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。</p>
<span id="more"></span>

<p><strong>在JSX中插入javascript的方式</strong></p>
<p>在 JSX 语法中，你可以在大括号内放置任何有效的 <strong>JavaScript 表达式</strong>。（什么是表达式？）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const name = &#x27;james kobe&#x27;;</span><br><span class="line">const element = &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>为了便于阅读，我们可以将JSX语法拆分成多行，并将内容包裹在小括号中，这样可以避免陷入自动插入分号的陷阱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p><strong>JSX也是一个表达式</strong></p>
<p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p>
<p>也就是说，你可以在 <code>if</code> 语句和 <code>for</code> 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getGreeting(user) &#123;</span><br><span class="line">  if (user) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>JSX的特定属性</strong></p>
<p>你可以通过使用引号，来将属性值指定为字符串字面量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;</span><br></pre></td></tr></table></figure>

<p>也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;;</span><br></pre></td></tr></table></figure>

<p>在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。</p>
<p><strong>需要注意的是：</strong></p>
<ul>
<li><p>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p>
</li>
<li><p>例如，JSX 里的 <code>class</code> 变成了 <code>className</code>，而 <code>tabindex</code> 则变为 <code>tabIndex</code>。</p>
</li>
<li><p>JSX的顶层<strong>只能有一个根元素</strong>，所以我们很多时候会在外层包裹一个div原生(或者使用后面我们学习的Fragment);</p>
</li>
<li><p>JSX中的标签可以是单标签，也可以是双标签。注意:如果是单标签，必须以<code>/&gt;</code>结尾;     </p>
</li>
</ul>
<p><strong>使用 JSX 指定子元素</strong></p>
<p>假如一个标签里面没有内容，也就是说这个标签是一个单标签的话，你可以使用 <code>/&gt;</code> 来闭合标签，就像 XML 语法一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;;</span><br></pre></td></tr></table></figure>

<p>JSX 标签里能够包含很多子元素:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p><strong>JSX 表示对象</strong></p>
<p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p>
<p>以下两种示例代码完全等效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const element = (</span><br><span class="line">  &lt;h1 className=&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">const element = React.createElement(</span><br><span class="line">  &#x27;h1&#x27;,</span><br><span class="line">  &#123;className: &#x27;greeting&#x27;&#125;,</span><br><span class="line">  &#x27;Hello, world!&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="疑问：（什么是表达式？表达式和语句又有什么区别呢？）"><a href="#疑问：（什么是表达式？表达式和语句又有什么区别呢？）" class="headerlink" title="疑问：（什么是表达式？表达式和语句又有什么区别呢？）"></a>疑问：（什么是表达式？表达式和语句又有什么区别呢？）</h4><p>语句指的是执行单元，通常以行为单位，表达式指的是可用于计算的式子，即可能产生一个值的式子。语句可以包含有表达式，表达式也可以单独形成一个语句。</p>
<p><strong>表达式会产生一个值，如赋值表达式：a=1。在控制台输出1。</strong></p>
<p><strong>表达式可以参与运算</strong>，如：</p>
<p>var c = 1==2 ? 3 : 4;</p>
<p>1==2 是一个表达式，1==2 ? 3 : 4这也是一个表达式，表达式是由运算符构成并运算产生结果的语法结构。</p>
<p>我们通常用”;”来分隔语句，组成程序，而本身就是语句的语法结构如：</p>
<p>if(){}else{} for(){} 等。</p>
<p>表达式一般由操作符和操作数组成，而我们把表达式按照语法结构组成语句，然后组成程序，表达式跟语句有重合的部分。</p>
<p>因此可以理解为表达式通常是语句的一部分或者本身就能起到一个语句的作用，而语句代表一段可执行的程序的最小单元。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo美化</title>
    <url>/2022/01/11/hexo%E4%B9%8Bnext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h2 id="hexo进阶教程"><a href="#hexo进阶教程" class="headerlink" title="hexo进阶教程"></a>hexo进阶教程</h2><span id="more"></span>

<h3 id="Hexo博客-绑定个人域名"><a href="#Hexo博客-绑定个人域名" class="headerlink" title="Hexo博客-绑定个人域名"></a>Hexo博客-绑定个人域名</h3><ol>
<li><p>首先得有一个域名，在腾讯云阿里云购买都可以。</p>
</li>
<li><p>设置域名解析</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy926kk6t7j32l60ba76f.jpg" style="zoom: 25%;" />



<ol start="3">
<li><p>设置CNAME</p>
</li>
<li><p>在 hexo 项目下的<code>source</code> 文件夹下面创建 CNAME 文件（没有后缀名的），Mac用户可以</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9285o2ncj308e01ut8j.jpg" style="zoom:50%;" />



<p>在里面写上购买的域名。</p>
</li>
<li><p>在 github 上面，打开 <a href="http://username.github.io/">username.github.io</a> 项目的（Settings）设置，然后在 <code>GitHub Pages</code>的 <code>Custom domain</code>设置里填上购买的域名。比如：</p>
</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy922se47aj31v60f0myl.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy923cjs5hj313g0ag0tp.jpg"></p>
<p>点击save就可以了。</p>
<h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><p><strong>实现效果图</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy90vctmacj30za03kgli.jpg"></p>
<p><strong>具体实现方法</strong></p>
<p>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.njk</code> 文件,并添加以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% <span class="keyword">if</span> not is_index %&#125;</span><br><span class="line">        &lt;div style=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;&quot;</span>&gt;------------- 本文结束 &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;fas fa-book-reader&quot;</span>&gt;&lt;<span class="regexp">/i&gt; 感谢阅读 -------------&lt;/</span>div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>接着打开<code>\themes\next\layout\_macro\post.njk</code>文件，在<code>post-body</code> 之后， <code>post-footer</code> 之前添加如下圈住的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">  &#123;% include &#x27;passage-end-tag.njk&#x27; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy90wy5kuhj31ip0u0wiw.jpg"></p>
<p>然后打开主题配置文件（<code>_config.yml</code>),在末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章末尾添加“本文结束”标记</span></span><br><span class="line"><span class="attr">passage_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。</p>
<h3 id="代码复制和设置Mac风格"><a href="#代码复制和设置Mac风格" class="headerlink" title="代码复制和设置Mac风格"></a>代码复制和设置Mac风格</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">copy_button:</span> <span class="comment"># 复制代码按钮</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#原始false</span></span><br><span class="line">  <span class="attr">show_result:</span> <span class="literal">true</span> <span class="comment">#原始true</span></span><br><span class="line">  <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">mac</span> <span class="comment">#代码更换mac风格</span></span><br></pre></td></tr></table></figure>



<h3 id="开启评论功能"><a href="#开启评论功能" class="headerlink" title="开启评论功能"></a>开启评论功能</h3><h3 id="添加本站运行时间和底部美化"><a href="#添加本站运行时间和底部美化" class="headerlink" title="添加本站运行时间和底部美化"></a>添加本站运行时间和底部美化</h3><p>打开<code>themes/next/layout/_partials/footer.njk</code>文件，在末尾加入如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网站运行时间的设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">createtime</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> grt= <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;01/01/2022 00:00:00&quot;</span>);<span class="comment">//此处修改你的建站时间或者网站上线时间</span></span></span><br><span class="line"><span class="javascript">        now.setTime(now.getTime()+<span class="number">250</span>);</span></span><br><span class="line"><span class="javascript">        days = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span>; dnum = <span class="built_in">Math</span>.floor(days);</span></span><br><span class="line"><span class="javascript">        hours = (now - grt ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> - (<span class="number">24</span> * dnum); hnum = <span class="built_in">Math</span>.floor(hours);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">String</span>(hnum).length ==<span class="number">1</span> )&#123;hnum = <span class="string">&quot;0&quot;</span> + hnum;&#125; minutes = (now - grt ) / <span class="number">1000</span> /<span class="number">60</span> - (<span class="number">24</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * hnum);</span></span><br><span class="line"><span class="javascript">        mnum = <span class="built_in">Math</span>.floor(minutes); <span class="keyword">if</span>(<span class="built_in">String</span>(mnum).length ==<span class="number">1</span> )&#123;mnum = <span class="string">&quot;0&quot;</span> + mnum;&#125;</span></span><br><span class="line"><span class="javascript">        seconds = (now - grt ) / <span class="number">1000</span> - (<span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * dnum) - (<span class="number">60</span> * <span class="number">60</span> * hnum) - (<span class="number">60</span> * mnum);</span></span><br><span class="line"><span class="javascript">        snum = <span class="built_in">Math</span>.round(seconds); <span class="keyword">if</span>(<span class="built_in">String</span>(snum).length ==<span class="number">1</span> )&#123;snum = <span class="string">&quot;0&quot;</span> + snum;&#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;timeDate&quot;</span>).innerHTML = <span class="string">&quot;本站已运行 &quot;</span>+dnum+<span class="string">&quot; 天 &quot;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;times&quot;</span>).innerHTML = hnum + <span class="string">&quot; 小时 &quot;</span> + mnum + <span class="string">&quot; 分 &quot;</span> + snum + <span class="string">&quot; 秒&quot;</span>;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"><span class="built_in">setInterval</span>(<span class="string">&quot;createtime()&quot;</span>,<span class="number">250</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要是觉得时间有两行不好看的花，也可以将</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>改成以下代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;timeDate&quot;</span>&gt;</span>载入天数...<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;times&quot;</span>&gt;</span>载入时分秒...<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>将访问人数和字数统计合并在同一行，用一个span标签包裹起来,在<code>themes/next/layout/_partials/footer.njk</code>这个文件中，找到<code>class=&quot;wordcount&quot;</code>，将其标签从div改成span。<code>class=&quot;busuanzi-count&quot;</code>这个div也同样改成span，然后再用一个span将它们两个包裹起来。</p>
<p><strong><font color=red>这里博主有个不明白的地方，span本来就是行内元素，假设有两个span为a和b，怎么两个span就变成了两行，然后将a和b这两个span用一个span包裹起来，它们就可以在同一行上了，如果有知道的大佬可以告知本菜鸡一些，不胜感激！</font></strong></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始搭建hexo博客</title>
    <url>/2022/01/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="用Hexo-快速搭建属于自己的博客"><a href="#用Hexo-快速搭建属于自己的博客" class="headerlink" title="用Hexo 快速搭建属于自己的博客"></a>用Hexo 快速搭建属于自己的博客</h1><span id="more"></span>

<h3 id="环境准备（安装方法自行查阅网上资料）"><a href="#环境准备（安装方法自行查阅网上资料）" class="headerlink" title="环境准备（安装方法自行查阅网上资料）"></a>环境准备（安装方法自行查阅网上资料）</h3><ul>
<li>git</li>
<li>node</li>
<li>npm</li>
</ul>
<p>命令行里验证是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line">git version 2.30.1 (Apple Git-130)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> node --version</span></span><br><span class="line">v16.4.2</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line">7.18.1</span><br></pre></td></tr></table></figure>

<h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>如果第一次用git工具，记得配置一下SSH key，为部署本地博客到 Github 做准备。</p>
<p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub用户名&quot;</span><br><span class="line">git config --global user.email &quot;注册GitHub邮箱地址&quot;</span><br></pre></td></tr></table></figure>

<p>生成密钥SSK key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;上面的邮箱地址&#x27;</span><br></pre></td></tr></table></figure>

<p>输入上面的命令之后，按下三次回车，即可生成ssh key。<code>.ssh</code>目录下有两个文件，<code>id_rsa</code>和<code>id_rsa.pub</code>，这两个就是ssh key的密钥对，<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥</p>
<p>cat获取你的ssh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>复制输出内容</p>
<p>登录github，settings -&gt; SSH and GPG keys -&gt; New SSH key</p>
<p>Title随便写</p>
<p>Key填写刚才复制的内容，确认完成。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli	<span class="comment"># -g 代表着全局安装</span></span></span><br></pre></td></tr></table></figure>

<p>完成后建立自己的个人博客</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo init blogName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> blogName</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install</span></span><br></pre></td></tr></table></figure>

<h3 id="创建你的第一篇博文"><a href="#创建你的第一篇博文" class="headerlink" title="创建你的第一篇博文"></a>创建你的第一篇博文</h3><p>新建一篇博文：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo new <span class="string">&#x27;blogName&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>在 <code>/source/_posts</code>文件夹下找到你的博文，使用typora（推荐）打开并编辑。</p>
<p>保存后运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo generate <span class="comment"># 生成静态文件，可简写为 hexo g</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server <span class="comment"># 启动服务器。默认情况下，访问网址为：http://localhost:4000/。可以简写为 hexo s</span></span></span><br></pre></td></tr></table></figure>

<p>此时已经可以在<code>public</code>文件夹下看到完整的静态文件。<br>在浏览器中输入<code>http://localhost:4000/</code>就可以看到预览效果了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果写的文章太长的话，想要在Home页显示文章的前一小部分的话，可以在想要显示部分的后面加上&lt;!--more--&gt;，就可以实现文章折叠。</span></span><br></pre></td></tr></table></figure>

<p>以上是本地部署，下面讲博客部署到Github page上</p>
<h2 id="部署到Github-page"><a href="#部署到Github-page" class="headerlink" title="部署到Github page"></a>部署到Github page</h2><p>登录github，新建仓库，仓库名为<code>username.github.io</code>，<strong>注意：<code>username</code>应该是你github的用户名</strong></p>
<p>本地和github都完成之后，现在需要把这两者连接在一起</p>
<ol>
<li><p>修改被指</p>
<p>在项目根目录下的<code>_config.yml</code>修改配置参数（如果这里命令行显示连接不了GitHub，那就用仓库的ssh链接代替https链接，因为GitHub现在增强了安全性，用户名和密码登录不能保证安全性）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Deployment</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Docs: https://hexo.io/docs/one-command-deployment</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: https://github.com/你的用户名/你的用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li>
<li><p>安装部署插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li><p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</p>
</li>
<li><p>部署上线</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li>
</ol>
<p>用浏览器输入，https://你的用户名.github.io，就可以看到你的博客了。</p>
<h2 id="配置主题及语言"><a href="#配置主题及语言" class="headerlink" title="配置主题及语言"></a>配置主题及语言</h2><p>个人用的是<a href="https://theme-next.js.org/">NexT主题</a></p>
<p>进入项目根目录，下载NexT主题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next themes/next</span></span><br></pre></td></tr></table></figure>

<p>修改<strong>项目根目录</strong>下的<code>_config.yml</code>的配置</p>
<p>注意：<code>_config.yml</code>配置文件有两个，一个在项目根目录，一个在<code>/themes/next</code>中，大部分配置在主题里面改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: https://hexo.io/themes/</span></span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>修改语言：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">博客的名字</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> </span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="NexT配置"><a href="#NexT配置" class="headerlink" title="NexT配置"></a>NexT配置</h2><p>以下均在<code>/blogName/themes/next/_config.yml</code>文件中修改</p>
<blockquote>
<p>修改主题的时候，可以使用hexo s现在本地预览，然后再部署上线。部署上线的效果可能有几分钟的延迟，耐心等待就好</p>
</blockquote>
<h3 id="修改NexT风格"><a href="#修改NexT风格" class="headerlink" title="修改NexT风格"></a>修改NexT风格</h3><p>NexT主题有四个风格，想要的取消注释</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Schemes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Muse</span></span><br><span class="line">scheme: Mist</span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Pisces</span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<h3 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Dark Mode</span></span><br><span class="line">darkmode: true</span><br></pre></td></tr></table></figure>

<h3 id="改变网页标签icon"><a href="#改变网页标签icon" class="headerlink" title="改变网页标签icon"></a>改变网页标签icon</h3><p>把你想要用的图片放在<code>/themes/next/source/images</code>中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/图片名字</span><br><span class="line">  medium: /images/图片名字</span><br></pre></td></tr></table></figure>

<h3 id="增加或删除博客页面功能"><a href="#增加或删除博客页面功能" class="headerlink" title="增加或删除博客页面功能"></a>增加或删除博客页面功能</h3><p>想用的取消注释，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line"><span class="meta">  #</span><span class="bash">schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h4 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h4><p>在项目根目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">cd ./source/tags</span><br></pre></td></tr></table></figure>

<p>打开<code>index.md</code>文件，增加一个<code>type</code>字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">date: 2022-01-04 13:29:07</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h4><p>在项目根目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br><span class="line">cd ./source/categories</span><br></pre></td></tr></table></figure>

<p>打开<code>index.md</code>文件，增加一个<code>type</code>字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">date: 2022-01-04 13:55:58</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="添加about页面"><a href="#添加about页面" class="headerlink" title="添加about页面"></a>添加about页面</h4><p>在项目根目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">cd ./source/about</span><br></pre></td></tr></table></figure>

<p>打开<code>index.md</code>文件，可以在里面写自己的个人介绍。</p>
<h3 id="调整侧边栏位置"><a href="#调整侧边栏位置" class="headerlink" title="调整侧边栏位置"></a>调整侧边栏位置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line"><span class="meta">  #</span><span class="bash"> Sidebar Position.</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">position: left</span></span><br><span class="line">  position: right</span><br></pre></td></tr></table></figure>

<h3 id="添加侧边栏头像图片"><a href="#添加侧边栏头像图片" class="headerlink" title="添加侧边栏头像图片"></a>添加侧边栏头像图片</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line">avatar:</span><br><span class="line">  <span class="comment"># 把要展示的图片放在images中</span></span><br><span class="line">  url: /images/avatar.jpg</span><br><span class="line">  <span class="comment"># If true, the avatar will be displayed in circle.</span></span><br><span class="line">  rounded: <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  rotated: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="启用不蒜子统计"><a href="#启用不蒜子统计" class="headerlink" title="启用不蒜子统计"></a>启用不蒜子统计</h3><p>不蒜子是用于统计文章的阅读次数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  total_visitors: <span class="literal">true</span></span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: <span class="literal">true</span></span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: <span class="literal">true</span></span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

<h3 id="添加网页加载进度条"><a href="#添加网页加载进度条" class="headerlink" title="添加网页加载进度条"></a>添加网页加载进度条</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace <span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  theme: minimal</span><br></pre></td></tr></table></figure>

<h3 id="添加页面顶部阅读进度条"><a href="#添加页面顶部阅读进度条" class="headerlink" title="添加页面顶部阅读进度条"></a>添加页面顶部阅读进度条</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  position: top               # 进度条的位置：top | bottom</span><br><span class="line">  color: &quot;#37c6c0&quot;            # 进度条的颜色</span><br><span class="line">  height: 3px                 # 进度条的大小</span><br></pre></td></tr></table></figure>

<h3 id="显示侧栏底部阅读进度百分比"><a href="#显示侧栏底部阅读进度百分比" class="headerlink" title="显示侧栏底部阅读进度百分比"></a>显示侧栏底部阅读进度百分比</h3><p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  sidebar: false</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>

<h3 id="字数与阅读时长统计插件"><a href="#字数与阅读时长统计插件" class="headerlink" title="字数与阅读时长统计插件"></a>字数与阅读时长统计插件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 项目根目录</span><br><span class="line">npm install eslint --save</span><br><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  time: true                   # 文章阅读时长</span><br><span class="line">  symbols: true                # 文章字数统计</span><br><span class="line">  total_time: true             # 站点总阅读时长</span><br><span class="line">  total_symbols: true          # 站点总字数统计</span><br><span class="line">  exclude_codeblock: true      # 排除代码字数统计</span><br></pre></td></tr></table></figure>



<h3 id="添加search栏"><a href="#添加search栏" class="headerlink" title="添加search栏"></a>添加search栏</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 项目根目录</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">// 在local_search:下面添加，注意search和local_search是在同一缩进上</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>



<h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><ul>
<li><p><code>hexo init [folder]</code></p>
<ul>
<li>Hexo 默认在目前的文件夹建立网站。</li>
<li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li>
<li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li>
</ul>
</li>
<li><pre><code>hexo new &#39;文章标题&#39;
</code></pre>
<ul>
<li>新建文件，写的时候自己用typora打开写。可简写为<code>hexo n &#39;文章标题&#39;</code></li>
</ul>
</li>
<li><p><code>hexo clean</code></p>
<ul>
<li>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</li>
<li>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</li>
</ul>
</li>
<li><p><code>hexo generate</code></p>
<ul>
<li>生成静态文件，可简写为<code>hexo g</code></li>
</ul>
</li>
<li><p><code>hexo server</code></p>
<ul>
<li>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。可以简写为 hexo s</li>
</ul>
</li>
<li><p><code>hexo deploy</code></p>
<ul>
<li>部署网站，可简写为<code>hexo d</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>js数组</title>
    <url>/2022/01/08/js%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="JavaScript数组探究"><a href="#JavaScript数组探究" class="headerlink" title="JavaScript数组探究"></a>JavaScript数组探究</h1><p>数组作为最基础的数据结构，我们不仅要熟练掌握它，还要了解它的许多特性</p>
<p>js的数组很灵活，和其他语言的数组不一样，js的数组可以存储不同类型的值</p>
<span id="more"></span>

<h3 id="创建一维数组的两种方法"><a href="#创建一维数组的两种方法" class="headerlink" title="创建一维数组的两种方法"></a>创建一维数组的两种方法</h3><p>1.数组字面量法</p>
<p>需要注意的是：使用数组字面量法创建数组并不会调用Array构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">24</span>];</span><br></pre></td></tr></table></figure>

<p>2.使用Array的构造函数，new一个数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="comment">// 指定数组长度</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 指定长度，且填充1</span></span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>).fill(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// new操作符可以省略，一个长度为二的数组</span></span><br><span class="line"><span class="keyword">let</span> arr6 = <span class="built_in">Array</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;arr6:&quot;</span>, arr6);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当参数只有一个数字的时候，就是创建一个长度为传入参数的数组</span></span><br><span class="line"><span class="keyword">let</span> arr7 = <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;arr7:&quot;</span>, arr7);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line">arr4.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, index);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以用map来遍历数组</span></span><br><span class="line"><span class="comment">// map 方法在调用形式上与 forEach 无异，</span></span><br><span class="line"><span class="comment">// 区别在于 map 方法会根据你传入的函数逻辑对数组中每个元素进行处理、进而返回一个全新的数组。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;map遍历&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> arr5 = arr4.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item, index);</span><br><span class="line">    <span class="keyword">return</span> item + <span class="number">11</span>;</span><br><span class="line">&#125;)·</span><br></pre></td></tr></table></figure>



<h3 id="二维数组的创建"><a href="#二维数组的创建" class="headerlink" title="二维数组的创建"></a>二维数组的创建</h3><p>一维数组可以使用数组字面量和使用Array的构造函数创建</p>
<p>那么二维数组呢？</p>
<p>下面来看一下这样初始化对不对</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill([]);</span><br><span class="line"><span class="comment">// 现在我们来改变一下二维数组里面的值</span></span><br><span class="line">arr1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">35</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// 这里发现里面的值全都变成了35，这是为什么呢</span></span><br></pre></td></tr></table></figure>

<p>这里是因为 fill 的工作机制导致的。 当给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用。所以fill里面的数组是同一个引用、指向的是同一块内存空间，它们本质上是同一个数组所以应该用for循环来初始化一个二维数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  arr2[i] = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组的一些方法"><a href="#数组的一些方法" class="headerlink" title="数组的一些方法"></a>数组的一些方法</h3><h4 id="pop-push-shift-unshift-方法"><a href="#pop-push-shift-unshift-方法" class="headerlink" title="pop/push, shift/unshift 方法"></a>pop/push, shift/unshift 方法</h4><ul>
<li><p><code>push</code> 在末端添加一个元素</p>
</li>
<li><p><code>pop</code> 从末端取出一个元素</p>
</li>
<li><p><code>unshift</code> 在队列首端添加一个元素，整个队列往后移一位</p>
</li>
<li><p><code>shift</code> 取出队列首端的一个元素，整个队列往前移一位</p>
</li>
</ul>
<p>这里会有一个性能问题，那就是<code>push</code>和 <code>pop</code>的性能会比<code>shift</code>和<code>unshift</code>高，因为<code>shift</code>和<code>unshift</code>会移动整个数组，这样很浪费时间。</p>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>数组的遍历方式有三种</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;beiyep&quot;</span>, <span class="string">&quot;kobe&quot;</span>, <span class="string">&quot;james&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用数组的长度遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用for of遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用for in遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;pause&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>需要说明的是，for in返回的是数组的下标值，并且要注意：</p>
<ol>
<li><p><code>for..in</code> 循环会遍历 <strong>所有属性</strong>，不仅仅是这些数字属性。</p>
<p>在浏览器和其它环境中有一种称为“类数组”的对象，它们 <strong>看似是数组</strong>。也就是说，它们有 <code>length</code> 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。<code>for..in</code> 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。</p>
<p>来看下面的🌰：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myfun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;myfun&#x27;</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr2) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy8x3wx4ndj30z80903yk.jpg"></p>
<p>上面的例子很好的反映了for…in…循环的缺点，原本只想循环取出该数组的数据，但是由于之前给数组添加了原型函数，导致循环的结果多了一个函数</p>
</li>
<li><p><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。</p>
</li>
</ol>
<h4 id="数组中的搜索"><a href="#数组中的搜索" class="headerlink" title="数组中的搜索"></a>数组中的搜索</h4><ol>
<li>严格相等</li>
</ol>
<p>js提供了indexOf/lastIndexOf 和 includes三种严格相等的搜索方法。其中</p>
<ul>
<li><code>arr.indexOf(item, from)</code> 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</li>
<li><code>arr.lastIndexOf(item, from)</code> —— 和上面相同，只是从右向左搜索。</li>
<li><code>arr.includes(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>，如果没找到，则返回 <code>false</code></li>
</ul>
<p>请注意，这些方法使用的是严格相等 <code>===</code> 比较。所以如果我们搜索 <code>false</code>，会精确到的确是 <code>false</code> 而不是数字 <code>0</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">11</span>, <span class="number">24</span>, <span class="number">35</span>, <span class="number">13</span>, <span class="literal">false</span>, <span class="literal">true</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始搜索1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引3开始搜索13</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">13</span>, <span class="number">3</span>)); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从零开始搜索true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">true</span>)); <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">0</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure>



<p>如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 <code>arr.includes</code> 是首选。</p>
<p>此外，<code>includes</code> 的一个非常小的差别是它能正确处理<code>NaN</code>，而不像 <code>indexOf/lastIndexOf</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="literal">NaN</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.indexOf(<span class="literal">NaN</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.includes(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>断言函数搜索</li>
</ol>
<p>arr.find和arr.findIndex是js提供的断言函数搜索，每个索引都会调用这个函数。</p>
<p>arr.find的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.find(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果返回 true，则返回 item 并停止迭代</span></span><br><span class="line">  <span class="comment">// 对于假值（false）的情况，则返回 undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>arr.findIndex 方法（与 <code>arr.find</code> 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 <code>-1</code>。</p>
<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h4><p>由于数组是基于对象的，不构成单独的语言类型，所以 typeof 不能帮助从数组中区分出普通对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，Array.isArray应运而生，如果 <code>value</code> 是一个数组，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(&#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="数组中方法的补充说明"><a href="#数组中方法的补充说明" class="headerlink" title="数组中方法的补充说明"></a>数组中方法的补充说明</h4><p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.find(func, thisArg);</span><br><span class="line">arr.filter(func, thisArg);</span><br><span class="line">arr.map(func, thisArg);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// thisArg 是可选的最后一个参数</span></span><br></pre></td></tr></table></figure>

<p>举个🌰：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> army = &#123;</span><br><span class="line">    <span class="attr">minAge</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">maxAge</span>: <span class="number">27</span>,</span><br><span class="line">    <span class="function"><span class="title">canJoin</span>(<span class="params">user</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> user.age &gt;= <span class="built_in">this</span>.minAge &amp;&amp; user.age &lt; <span class="built_in">this</span>.maxAge;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> users = [</span><br><span class="line">    &#123;<span class="attr">age</span>: <span class="number">16</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">age</span>: <span class="number">30</span>&#125;</span><br><span class="line">  ];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 找到 army.canJoin 返回 true 的 user</span></span><br><span class="line">	<span class="keyword">let</span> soldiers = users.filter(army.canJoin, army);</span><br><span class="line">  <span class="comment">// let soldiers = users.filter(army.canJoin); // 错误</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(soldiers.length); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(soldiers[<span class="number">0</span>].age); <span class="comment">// 20</span></span><br><span class="line">  <span class="built_in">console</span>.log(soldiers[<span class="number">1</span>].age); <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<p>如果在上面的示例中我们使用了 <code>users.filter(army.canJoin)</code>，那么 <code>army.canJoin</code> 将被作为独立函数调用，并且这时 <code>this=undefined</code>，从而会导致即时错误。所以我们这里一般都用剪头函数。</p>
<h3 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h3><p>数组是一种特殊的对象，比如数组访问元素的方式是arr[0]和对象obj[key]很相似，其中arr是对象，数字用作键。数组和类相似，也是引用类型。但是数组又拓展了对象，因为数组可以处理有序的数据集合。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>算法——二叉树</title>
    <url>/2022/01/05/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="力扣刷题之二叉树总结"><a href="#力扣刷题之二叉树总结" class="headerlink" title="力扣刷题之二叉树总结"></a>力扣刷题之二叉树总结</h2><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>难度简单727</p>
<p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
<span id="more"></span>

<p><strong>示例:</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入: <span class="comment">[1,null,2,3]</span>  </span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3 </span><br><span class="line"></span><br><span class="line">输出: <span class="comment">[3,2,1]</span></span><br></pre></td></tr></table></figure>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><strong>图示：画出了几个关键的步骤</strong></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxlruvnf4gj30p72abn3n.jpg" style="zoom:67%;" />

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> st = [];</span><br><span class="line">    <span class="keyword">let</span> cur = root;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur || st.length) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = st.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.right == <span class="literal">null</span> || cur.right == prev) &#123;</span><br><span class="line">            res.push(cur.val);</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            st.push(cur);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><p>难度：简单</p>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 10000</code></li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grr9clch10j310e08mwf5.jpg" style="zoom:50%;" />



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//解法一：这个耗时有点长</span></span><br><span class="line"><span class="comment">//递归做法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_depth=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right==<span class="literal">nullptr</span>&amp;&amp;root-&gt;left==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            max_depth=<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),max_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            max_depth=<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;right),max_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_depth+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二：耗时短</span></span><br><span class="line"><span class="comment">//递归做法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nleft=<span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> nright=<span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(nleft&gt;nright)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nleft+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> nright+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><p>难度简单525</p>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min_depth=INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min_depth=<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min_depth=<span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;right),min_depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_depth+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="112-路径总和：！非常重要的一道题，字节跳动常考"><a href="#112-路径总和：！非常重要的一道题，字节跳动常考" class="headerlink" title="112. 路径总和：！非常重要的一道题，字节跳动常考"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a>：！非常重要的一道题，字节跳动常考</h4><p>难度简单604收藏分享切换为英文接收动态反馈</p>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="literal">null</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], <span class="attr">targetSum</span> = <span class="number">22</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="attr">targetSum</span> = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="attr">targetSum</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp;root-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum==root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left,targetSum-root-&gt;val)||<span class="built_in">hasPathSum</span>(root-&gt;right, targetSum-root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p>难度简单891收藏分享切换为英文接收动态反馈</p>
<p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>     <span class="number">7</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">1</span>   <span class="number">3</span> <span class="number">6</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">     <span class="number">4</span></span><br><span class="line">   /   <span class="string">\</span></span><br><span class="line">  <span class="number">7</span>     <span class="number">2</span></span><br><span class="line"> / <span class="string">\</span>   / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>   <span class="number">6</span> <span class="number">3</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* temp=<span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;left=<span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;right=temp;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己写的版本，代码还是不够简洁，对递归的理解还不能做到清晰</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     TreeNode* invertTree(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">//         if(!root)return 0;</span></span><br><span class="line"><span class="comment">//         invertTree(root-&gt;left);</span></span><br><span class="line"><span class="comment">//         invertTree(root-&gt;right);</span></span><br><span class="line"><span class="comment">//         TreeNode* temp;</span></span><br><span class="line"><span class="comment">//         temp=root-&gt;left;</span></span><br><span class="line"><span class="comment">//         root-&gt;left=root-&gt;right;</span></span><br><span class="line"><span class="comment">//         root-&gt;right=temp;</span></span><br><span class="line"><span class="comment">//         return root;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br></pre></td></tr></table></figure>



<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h4><p>难度简单639收藏分享切换为英文接收动态反馈</p>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入：<span class="selector-tag">p</span> = <span class="selector-attr">[1,2,3]</span>, <span class="selector-tag">q</span> = <span class="selector-attr">[1,2,3]</span></span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">p</span> = [<span class="number">1</span>,<span class="number">2</span>], <span class="attr">q</span> = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="img"></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">输入：<span class="selector-tag">p</span> = <span class="selector-attr">[1,2,1]</span>, <span class="selector-tag">q</span> = <span class="selector-attr">[1,1,2]</span></span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* v1 没有考虑到遍历二叉树的时候，左右子树空和非空的情况在数组中是一样的。</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; treep;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; treeq;</span></span><br><span class="line"><span class="comment">    void orderp(TreeNode* p)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(!p)return;</span></span><br><span class="line"><span class="comment">        orderp(p-&gt;left);</span></span><br><span class="line"><span class="comment">        treep.push_back(p-&gt;val);</span></span><br><span class="line"><span class="comment">        orderp(p-&gt;right);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void orderq(TreeNode* q)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(!q)return;</span></span><br><span class="line"><span class="comment">        orderq(q-&gt;left);</span></span><br><span class="line"><span class="comment">        treeq.push_back(q-&gt;val);</span></span><br><span class="line"><span class="comment">        orderq(q-&gt;right);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span></span><br><span class="line"><span class="comment">        int lenp=treep.size(),lenq=treeq.size(),n=0;</span></span><br><span class="line"><span class="comment">        if(lenp!=lenq)return false;</span></span><br><span class="line"><span class="comment">        else if(n&lt;lenq)&#123;</span></span><br><span class="line"><span class="comment">        for(int i=0;i&lt;lenq;i++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            n++;</span></span><br><span class="line"><span class="comment">            if(treeq[i]!=treep[i])</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return true; </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">nullptr</span>&amp;&amp;q==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">nullptr</span>||q==<span class="literal">nullptr</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;val!=q-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in"><span class="keyword">return</span></span>(<span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left)&amp;&amp;<span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><p>难度简单1417收藏分享切换为英文接收动态反馈</p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / <span class="string">\</span></span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / <span class="string">\</span> / <span class="string">\</span></span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> <span class="string">\</span>   <span class="string">\</span></span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong></p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个方法都是递归做法	</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isMirror</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* nleft,TreeNode* nright)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!nleft&amp;&amp;!nright)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!nleft&amp;&amp;nright)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nleft&amp;&amp;!nright)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(nleft-&gt;val!=nright-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isMirror</span>(nleft-&gt;left,nright-&gt;right)&amp;&amp;<span class="built_in">isMirror</span>(nleft-&gt;right,nright-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个月后写的方法，但还是看了官方的解题思路</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *p,TreeNode *q)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!q&amp;&amp;!p)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!q||!p)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val==q-&gt;val&amp;&amp;<span class="built_in">check</span>(p-&gt;left,q-&gt;right)&amp;&amp;<span class="built_in">check</span>(p-&gt;right,q-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="面试题-17-12-BiNode"><a href="#面试题-17-12-BiNode" class="headerlink" title="面试题 17.12. BiNode"></a><a href="https://leetcode-cn.com/problems/binode-lcci/">面试题 17.12. BiNode</a></h4><p>难度简单77</p>
<p>二叉树数据结构<code>TreeNode</code>可用来表示单向链表（其中<code>left</code>置空，<code>right</code>为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
<p><strong>注意：</strong>本题相对原题稍作改动</p>
<p><strong>示例：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">输入： [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">0</span>]</span><br><span class="line">输出： [<span class="number">0</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>节点数量不会超过 100000。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//2021.06.23</span></span><br><span class="line"><span class="comment">//今天做这道题花了很长时间，可能也是因为今天的状态不太好，也被某些事情分心了，思路不够清晰。</span></span><br><span class="line"><span class="comment">//然后静下心来发现，还是挺简单的，所以不要畏惧难题，静下心来解决它！！！就能获得成就感</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>); <span class="comment">//定义一个节点，用来返回新树的头节点</span></span><br><span class="line">    TreeNode* tmp=ans; <span class="comment">//定义一个节点，用来遍历整棵树</span></span><br><span class="line">  	<span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBiNode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">convertBiNode</span>(root-&gt;left);</span><br><span class="line">        root-&gt;left=<span class="literal">NULL</span>;<span class="comment">//将当前节点的左孩子赋值为空</span></span><br><span class="line">        tmp-&gt;right=root;<span class="comment">//将遍历节点的右孩子赋值为当前节点（就是将节点连接起来）</span></span><br><span class="line">        tmp=root;<span class="comment">//更新遍历节点</span></span><br><span class="line">        <span class="built_in">convertBiNode</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ans-&gt;right;<span class="comment">//返回头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;c</span><br></pre></td></tr></table></figure>



<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>难度中等524收藏分享切换为英文接收动态反馈</p>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">中序遍历 inorder = <span class="string">[9,3,15,20,7]</span></span><br><span class="line">后序遍历 postorder = <span class="string">[9,15,7,20,3]</span></span><br></pre></td></tr></table></figure>

<p>返回如下的二叉树：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / <span class="string">\</span></span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  <span class="string">\</span></span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>通过次数113,927</p>
<p>提交次数158,347</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的额版本，找这个错误找了好久，后来才发现是全局变量和局部变量的混乱引起的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootValue=postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> delimiterIndex=<span class="number">0</span>;delimiterIndex&lt;inorder.<span class="built_in">size</span>();delimiterIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[delimiterIndex]==rootValue)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(),inorder.begin()+delimiterIndex)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin()+delimiterIndex+<span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(),postorder.begin()+leftInorder.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin()+leftInorder.size(),postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left=<span class="built_in">traversal</span>(leftInorder,leftPostorder);</span><br><span class="line">        root-&gt;right=<span class="built_in">traversal</span>(rightInorder,rightPostorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()==<span class="number">0</span>||postorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的答案</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder,vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> rootValue=postorder[postorder.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        TreeNode* root=<span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>()==<span class="number">1</span>)<span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span>(delimiterIndex=<span class="number">0</span>;delimiterIndex&lt;inorder.<span class="built_in">size</span>();delimiterIndex++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[delimiterIndex]==rootValue)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(),inorder.begin()+delimiterIndex)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin()+delimiterIndex+<span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(),postorder.begin()+leftInorder.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin()+leftInorder.size(),postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">        root-&gt;left=<span class="built_in">traversal</span>(leftInorder,leftPostorder);</span><br><span class="line">        root-&gt;right=<span class="built_in">traversal</span>(rightInorder,rightPostorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>()==<span class="number">0</span>||postorder.<span class="built_in">size</span>()==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><p>难度中等298</p>
<p>给定一个不含重复元素的整数数组 <code>nums</code> 。一个以此数组直接递归构建的 <strong>最大二叉树</strong> 定义如下：</p>
<ol>
<li>二叉树的根是数组 <code>nums</code> 中的最大元素。</li>
<li>左子树是通过数组中 <strong>最大值左边部分</strong> 递归构造出的最大二叉树。</li>
<li>右子树是通过数组中 <strong>最大值右边部分</strong> 递归构造出的最大二叉树。</li>
</ol>
<p>返回有给定数组 <code>nums</code> 构建的 <strong>最大二叉树</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：nums = <span class="comment">[3,2,1,6,0,5]</span></span><br><span class="line">输出：<span class="comment">[6,3,5,null,2,0,null,null,1]</span></span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- <span class="comment">[3,2,1,6,0,5]</span> 中的最大值是 6 ，左边部分是 <span class="comment">[3,2,1]</span> ，右边部分是 <span class="comment">[0,5]</span> 。</span><br><span class="line">    - <span class="comment">[3,2,1]</span> 中的最大值是 3 ，左边部分是 <span class="comment">[]</span> ，右边部分是 <span class="comment">[2,1]</span> 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - <span class="comment">[2,1]</span> 中的最大值是 2 ，左边部分是 <span class="comment">[]</span> ，右边部分是 <span class="comment">[1]</span> 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - <span class="comment">[0,5]</span> 中的最大值是 5 ，左边部分是 <span class="comment">[0]</span> ，右边部分是 <span class="comment">[]</span> 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p>通过次数48,046</p>
<p>提交次数59,319</p>
<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h4><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">len</span> = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">print</span>(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">nums</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="attr">val</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span>, <span class="attr">nums</span> = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="number">2</span> ，而 <span class="attr">nums</span> = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 或 <span class="attr">nums</span> = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">0,1,2,2</span>,<span class="number">3,0,4,2</span>], val = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span>, nums = [<span class="number">0,1,4,0</span>,<span class="number">3</span>]</span><br><span class="line">解释：函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(n^2)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span></span><br><span class="line"><span class="comment">//         int size = nums.size();</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line"><span class="comment">//             if (nums[i] == val) &#123; // 发现需要移除的元素，就将数组集体向前移动一位</span></span><br><span class="line"><span class="comment">//                 for (int j = i + 1; j &lt; size; j++) &#123;</span></span><br><span class="line"><span class="comment">//                     nums[j - 1] = nums[j];</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 i--; // 因为下表i以后的数值都向前移动了一位，所以i也向前移动一位</span></span><br><span class="line"><span class="comment">//                 size--; // 此时数组的大小-1</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return size;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123;</span></span><br><span class="line"><span class="comment">//         int n = nums.size();</span></span><br><span class="line"><span class="comment">//         int leftIndex = 0;</span></span><br><span class="line"><span class="comment">//         for(int rightIndex = 0; rightIndex &lt; n ;rightIndex++) &#123;</span></span><br><span class="line"><span class="comment">//             if(nums[rightIndex] != val) &#123;</span></span><br><span class="line"><span class="comment">//                 nums[leftIndex++] = nums[rightIndex];</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return leftIndex;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双指针法很常用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> leftIndex = <span class="number">0</span>, rightIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[rightIndex] != val) &#123;</span><br><span class="line">                nums[leftIndex++] = nums[rightIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> rightIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><p>难度中等480</p>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>], <span class="attr">k</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入：<span class="attr">root</span> = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>], <span class="attr">k</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数为 <code>n</code> 。</li>
<li><code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<p>通过次数143,327</p>
<p>提交次数192,658</p>
<p>不用建立数组的做法：</p>
<p>这道题做的过程中，思路出现了点问题，还是对return的返回理解不够深刻，忽略了返回值造成的结果差错。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">int</span> g_key;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        g_key = k;</span><br><span class="line">        <span class="built_in">kLittleNumber</span>(root, k);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kLittleNumber</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">kLittleNumber</span>(root-&gt;left, key);</span><br><span class="line">        <span class="keyword">if</span>(key == <span class="number">1</span>) &#123;</span><br><span class="line">            result = root-&gt;val;</span><br><span class="line">            <span class="comment">// return;  // 为什么这里出错呢，因为找到了 key == 1 的时候，返回上一层递归，那么key还是不变，此时就会出现错误结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        key--;</span><br><span class="line">        <span class="built_in">kLittleNumber</span>(root-&gt;right, key);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS几种常见的布局</title>
    <url>/2022/01/31/CSS%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="几种常见且基础的CSS布局"><a href="#几种常见且基础的CSS布局" class="headerlink" title="几种常见且基础的CSS布局"></a>几种常见且基础的CSS布局</h3><h4 id="一-单列布局"><a href="#一-单列布局" class="headerlink" title="一. 单列布局"></a>一. 单列布局</h4><p>常见的单列布局有两种：</p>
<ul>
<li>header,content和footer等宽的单列布局</li>
<li>header与footer等宽,content略窄的单列布局</li>
</ul>
<span id="more"></span>

<ol>
<li><p>第一种通过设置header、content、footer统一设置width：1000px;或者max-width：1000px即可实现。区别在于显示屏幕小于1000px时，前者会有滚动条出现，而后者不会（也就是说后者显示的是实际宽度）</p>
<blockquote>
<p>max-width 属性用来给元素设置最大宽度值. 定义了max-width的元素会在达到max-width值之后避免进一步按照width属性设置变大.</p>
<p>max-width 会覆盖width设置, 但 min-width设置会覆盖 max-width.</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">1960px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">1960px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">1960px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: teal;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>第二种可以给中间的content设置一个固定的width，然后header、content、footer都居中显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">100px</span> auto <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="二-两列布局"><a href="#二-两列布局" class="headerlink" title="二. 两列布局"></a>二. 两列布局</h4><p>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式</p>
<ol>
<li><p>普通两列布局（单列定宽单列自适应），用浮动+margin即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">450px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>两列自适应布局：float和overflow配合可实现两列自适应效果。使用overflow属性来触发bfc，来阻止浮动造成的文字环绕效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.p</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: grey;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Flex布局：也叫弹性盒子布局，简单几行代码就可以实现各种页面的的布局。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">flex</span>: <span class="number">1</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>111111jlfdjlfjowejfoewjo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h4 id="3-三栏布局"><a href="#3-三栏布局" class="headerlink" title="3. 三栏布局"></a>3. 三栏布局</h4><blockquote>
<p>三栏布局就是两边宽度固定,中间自适应的布局.</p>
<p>改变浏览器的宽度,两边的宽度不会变,只会中间区域的宽度变长变短.</p>
</blockquote>
<p>流体布局：</p>
<p>圣杯布局：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding-left</span>: <span class="number">220px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding-right</span>: <span class="number">220px</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: lightgrey;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/* margin-left: -200px; */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            <span class="attribute">left</span>: -<span class="number">220px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: lightblue;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/* margin-left: -100%; */</span></span></span><br><span class="line"><span class="css">            <span class="comment">/* margin-left中百分比是距离最近的块容器的宽度 width */</span></span></span><br><span class="line"><span class="css">            <span class="comment">/* 而px的话就是绝对距离 */</span></span></span><br><span class="line"><span class="css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">            <span class="attribute">right</span>: -<span class="number">220px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background</span>: lightgreen;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>CSS笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript: prototype、__proto__、[[prototype]]的区别</title>
    <url>/2022/02/03/JavaScript:%20prototype%E3%80%81__proto__%E3%80%81%5B%5Bprototype%5D%5D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="prototype、-proto-、-prototype-三者之间的区别"><a href="#prototype、-proto-、-prototype-三者之间的区别" class="headerlink" title="prototype、__proto__、[[prototype]]三者之间的区别"></a>prototype、__proto__、[[prototype]]三者之间的区别</h3><p>最近在网上看到<code>instanceof</code>的手写版，里面涉及到了<code>prototype</code>、<code>__proto__</code>，仔细推敲 一下代码，发现自己对<code>prototype</code>,<code>__proto__</code>的理解不够深刻导致自己对手写版的instanceof代码理解不是很透彻。</p>
<span id="more"></span>

<p>首先来看一下<code>instanceof</code>的手写代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">obj, constructor</span>) </span>&#123;</span><br><span class="line">  	<span class="comment">// 拿到obj的</span></span><br><span class="line">    <span class="keyword">let</span> implicitPrototype = obj?.__proto__;</span><br><span class="line">    <span class="keyword">const</span> displayPrototype = <span class="title">constructor</span>.<span class="title">prototype</span>;</span><br><span class="line">    <span class="keyword">while</span> (implicitPrototype) &#123;</span><br><span class="line">        <span class="keyword">if</span> (implicitPrototype === displayPrototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        implicitPrototype = implicitPrototype.__proto__;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果不是很清楚<code>prototype</code>,<code>__proto__</code>的话，很难正确理解上述代码。所以我们先要搞清楚它们的区别。</p>
<p><strong>1. 概念区分</strong></p>
<p>其实说<code>__proto__</code>并不准确，确切的说是对象的<code>[[prototype]]</code>属性，只不过在主流的浏览器中，都用<code>__proto__</code>来代表<code>[[prototype]]</code>属性，因为<code>[[prototype]]</code>只是一个标准，而针对这个标准，不同的浏览器有不同的实现方式。在ES5中用<code>Object.getPrototypeOf</code>函数获得一个对象的<code>[[prototype]]</code>。ES6中，使用<code>Object.setPrototypeOf</code>可以直接修改一个对象的<code>[[prototype]]</code>。</p>
<p>而<code>prototype</code>属性是只有函数才特有的属性，当你创建一个函数时，js会自动为这个函数加上<code>prototype</code>属性，值是一个空对象。所以，函数在js中是非常特殊的，是所谓的一等公民。</p>
<p><strong>2.必须明确</strong></p>
<p><code>__proto__</code>是隐式原型</p>
<p><code>prototype</code>是显式原型</p>
<p>显式原型 ：每一个函数在创建之后都会拥有一个名为<code>prototype</code>的属性，这个属性指向函数的原型对象。</p>
<p>隐式原型：JavaScript中任意对象都有一个内置属性<code>[[prototype]]</code>，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过<code>__proto__</code>来访问。</p>
<p>注意: <code>Object.prototype</code> 这个对象是个例外，它的<code>__proto__</code>值为<code>null</code></p>
<p><strong>二者的关系：</strong></p>
<p><strong>隐式原型指向创建这个对象的函数(constructor)的prototype</strong></p>
<p><strong>3.他们的作用</strong></p>
<p>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着<code>__proto__</code>依次查找。</p>
<p>显式原型的作用：用来实现基于原型的继承与属性的共享</p>
<p>所以现在我们可以分析一下<code>instanceof</code>代码了。一般来说，<code>instanceof</code>内部实现机制和隐式原型、显式原型有直接的关系。<code>instanceof</code>的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。</p>
<p>所以在我们的手写代码中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设 obj instanceof constructor</span></span><br><span class="line"><span class="comment">//通过判断</span></span><br><span class="line"> obj.__proto__.__proto__ ..... === <span class="title">constructor</span>.<span class="title">prototype</span></span><br><span class="line">//最终返回<span class="title">true</span> <span class="title">or</span> <span class="title">false</span></span><br></pre></td></tr></table></figure>

<p>也就是一直沿着obj的<code>__proto__</code>一直寻找下去，知道等于<code>constructor.prototype</code>或者<code>null</code>为止。</p>
<p>这就是instanceof的原理</p>
<p>4.进一步的探究</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面两行代码的结果都为true，这就有点奇怪了</p>
<p>接下来我们来探究一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>所以原型链的尽头（root）是<code>Object.prototype</code>。<strong>所有对象均从<code>Object.prototype</code>继承属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype === <span class="built_in">Function</span>.__proto__); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>所以<code>Function.prototype</code>和<code>Function.__proto__</code>为<strong>同一对象</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype === <span class="built_in">Array</span>.__proto__); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype === <span class="built_in">String</span>.__proto__); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype === <span class="built_in">Object</span>.__proto__); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype === <span class="built_in">Number</span>.__proto__); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype === <span class="built_in">Boolean</span>.__proto__); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>这意味着： <strong><code>Object</code>/<code>Array</code>/<code>String</code>等等构造函数本质上和<code>Function</code>一样，均继承于<code>Function.prototype</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>最后<code>Function.prototype</code>直接继承<code>Object.prototype</code></p>
<p><strong>总结</strong>：<strong>先有<code>Object.prototype</code>（原型链顶端），<code>Function.prototype</code>继承<code>Object.prototype</code>而产生，最后，<code>Function</code>和<code>Object</code>和其它构造函数继承<code>Function.prototype</code>而产生。</strong></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote03:JSX本质及源码解析</title>
    <url>/2022/01/17/ReactNote03:%20JSX%E6%9C%AC%E8%B4%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="JSX的本质"><a href="#JSX的本质" class="headerlink" title="JSX的本质"></a>JSX的本质</h3><p>实际上，jsx仅仅只是React.createElement(component, props, …children)函数的语法糖。所有的jsx语法都会被转换为React.createElement语法的调用。</p>
<span id="more"></span>

<p>先来看一下几行jsx代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>nihao<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>you are the best<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么它们转换成js代码会是什么样的呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">React.createElement(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, React.createElement(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;nihao&quot;</span>),</span><br><span class="line">                        React.createElement(<span class="string">&quot;h2&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;you are the best&quot;</span>),</span><br><span class="line">                        React.createElement(<span class="string">&quot;ul&quot;</span>, <span class="literal">null</span>,</span><br><span class="line">                            React.createElement(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;1&quot;</span>),</span><br><span class="line">                            React.createElement(<span class="string">&quot;li&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;2&quot;</span>)))</span><br></pre></td></tr></table></figure>

<p>好家伙，直接一个嵌套地狱，要是代码再多一点的话能把人看哭。还是jsx香</p>
<blockquote>
<p> 查看React.createElement的源码</p>
<p>源码位置：packages/react/src/ReactElement.js</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Create and return a new ReactElement of the given type.</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#createelement</span><br><span class="line"> */</span><br><span class="line">export function createElement(type, config, children) &#123;</span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  // Reserved names are extracted</span><br><span class="line">  const props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  let key = null;</span><br><span class="line">  let ref = null;</span><br><span class="line">  let self = null;</span><br><span class="line">  let source = null;</span><br><span class="line"></span><br><span class="line">  if (config != null) &#123;</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line"></span><br><span class="line">      if (__DEV__) &#123;</span><br><span class="line">        warnIfStringRefCannotBeAutoConverted(config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      key = &#x27;&#x27; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === undefined ? null : config.__self;</span><br><span class="line">    source = config.__source === undefined ? null : config.__source;</span><br><span class="line">    // Remaining properties are added to a new props object</span><br><span class="line">    for (propName in config) &#123;</span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Children can be more than one argument, and those are transferred onto</span><br><span class="line">  // the newly allocated props object.</span><br><span class="line">  const childrenLength = arguments.length - 2;</span><br><span class="line">  if (childrenLength === 1) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    const childArray = Array(childrenLength);</span><br><span class="line">    for (let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      if (Object.freeze) &#123;</span><br><span class="line">        Object.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Resolve default props</span><br><span class="line">  if (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    const defaultProps = type.defaultProps;</span><br><span class="line">    for (propName in defaultProps) &#123;</span><br><span class="line">      if (props[propName] === undefined) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (key || ref) &#123;</span><br><span class="line">      const displayName =</span><br><span class="line">        typeof type === &#x27;function&#x27;</span><br><span class="line">          ? type.displayName || type.name || &#x27;Unknown&#x27;</span><br><span class="line">          : type;</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">      if (ref) &#123;</span><br><span class="line">        defineRefPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>createElement的三个参数：</p>
<ul>
<li><ol>
<li>type</li>
</ol>
<ul>
<li>是当前React的类型，如果是标签元素，则用字符串表示，例如“div”。如果是组件元素，则直接用组件名称</li>
</ul>
</li>
<li><ol start="2">
<li>config</li>
</ol>
<ul>
<li>所有jsx中的属性都在config中以对象的键值对存储</li>
</ul>
</li>
<li><ol start="3">
<li>存放标签中的内容，以数组的方式存储</li>
</ol>
<ul>
<li> 为什么是以数组的形式存储呢？</li>
<li>因为jsx里面可以会传入很多的同级标签，createElement并不是只能传入三个参数。为什么可以传入多个参数呢？这就要回到源码里面一探究竟了，毕竟源码之下，了无秘密。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Object</span>.freeze) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是上面createElement源码的一部分，也就是说children是一个数组，里面存储着第三个参数及以后的所有参数。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote01:React的特点和优点</title>
    <url>/2022/01/12/ReactNote01:%20React%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E7%82%B9/</url>
    <content><![CDATA[<p>React作为国内最流行的前端框架之一，肯定有它的好用先进之处，作为技术geek，那肯定要学穿它🤔</p>
<span id="more"></span>

<h3 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h3><ol>
<li>声明式编程<ul>
<li>允许我们只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界面;</li>
</ul>
</li>
<li>组件化开发<ul>
<li>能把一个大问题分解成一个小问题一个个实现，便于开发和维护。</li>
</ul>
</li>
<li>多平台适配<ul>
<li>React不仅能开发网页应用，React Native也能开发Android和iOS应用。</li>
</ul>
</li>
</ol>
<blockquote>
<p>除此之外，学习React还能掌握先进的技术和思想。并且React的思想被许多框架借鉴，比如Google的Flutter框架就借鉴了React的思想，老美有意思的一点就是他借鉴React的思想，直接官网摆明了说出来。</p>
</blockquote>
<h3 id="React开发依赖"><a href="#React开发依赖" class="headerlink" title="React开发依赖"></a><strong>React开发依赖</strong></h3><p>开发React必须依赖三个库:</p>
<ul>
<li>react:包含react所必须的核心代码</li>
<li>react-dom:react渲染在不同平台所需要的核心代码</li>
<li>babel:将jsx转换成React代码的工具<ul>
<li>babel可以将es6语法转换为es5语法，并且可以将jsx语法转换为js语法。帮助我们更好的进行开发。</li>
</ul>
</li>
</ul>
<blockquote>
<p> react包中包含了react和react-native所共同拥有的核心代码。</p>
</blockquote>
<p>react-dom针对web和native所完成的事情不同:</p>
<ul>
<li>web端:react-dom会讲jsx最终渲染成真实的DOM，显示在浏览器中</li>
<li>native端:react-dom会讲jsx最终渲染成原生的控件(比如Android中的Button，iOS中的UIButton)</li>
</ul>
<h3 id="React的优点"><a href="#React的优点" class="headerlink" title="React的优点"></a>React的优点</h3><p>为什么需要React呢，我们来看一个案例，要求点击按钮，网页上的文字内容会发生改变。</p>
<p>以下是原生实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>change text<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这里是命令式编程，就是给计算机一步步指令去完成一件事</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 1.定义数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> message = <span class="string">&quot;Hello, World!&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 2.将数据显示在h2元素中</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> titleEl = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;title&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">        titleEl.innerHTML = message;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 3.点击按钮，页面数据发生改变</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> btnEl = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;btn&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">        btnEl.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            message = <span class="string">&quot;Hello, React!&quot;</span>;</span></span><br><span class="line"><span class="javascript">            titleEl.innerHTML = message;</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再来看看React实现，是不是感觉代码有点多，还比原生的复杂了。这里是因为我们调用了render函数，并且还没用到React的声明式编程和组件化开发的特点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> message = <span class="string">&quot;Hello,World!&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">btnClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            message = <span class="string">&quot;Hello,React!&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(message);</span></span><br><span class="line"><span class="javascript">            render();</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            ReactDOM.render(</span></span><br><span class="line"><span class="javascript">                <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">                    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;btnClick&#125;</span>&gt;</span>change text<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span></span><br><span class="line"><span class="javascript">            );</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        render();</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- babel转换代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面再来看利用了React特点写的代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">super</span>();</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.state = &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">message</span>: <span class="string">&quot;Hello,World&quot;</span>,</span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            render = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> (</span></span><br><span class="line"><span class="javascript">                    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">                        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">                        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.btnClick&#125;</span>&gt;</span>change text<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">                )</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">            btnClick = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// this.state.message = &quot;Hello,React&quot;;</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(this.state);</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.setState(&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="attr">message</span>: <span class="string">&quot;Hello,React&quot;</span></span></span><br><span class="line"><span class="javascript">                &#125;)</span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>));</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- babel转换代码 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看起来确实优雅了不少。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote04:组件通信方式</title>
    <url>/2022/01/31/ReactNote04:%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="组件间的通信方式"><a href="#组件间的通信方式" class="headerlink" title="组件间的通信方式"></a>组件间的通信方式</h3><h4 id="1-父组件传递信息给子组件"><a href="#1-父组件传递信息给子组件" class="headerlink" title="1. 父组件传递信息给子组件"></a>1. 父组件传递信息给子组件</h4><blockquote>
<p>先看React官网的一句话：当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
</blockquote>
<span id="more"></span>

<p>以下例子说明了父组件传递信息给子组件的方式是：在父组件的子组件中写形参的时候，React会将子组件接受到的属性转换为props对象传递给组件，所以渲染子组件的时候就可以使用props里面的数据了。函数组件同理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;</span><br><span class="line">class Son extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        // 为什么这里可以通过this.props取得父组件里面传来的值呢？</span><br><span class="line">        const &#123; name, age, height &#125; = this.props;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h2&gt;&#123;name + &quot; &quot; + age + &quot; &quot; + height&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Son name=&quot;beiyep&quot; age=&quot;18&quot; height=&quot;1.88&quot;&gt;&lt;/Son&gt;</span><br><span class="line">                &lt;Son name=&quot;hala&quot; age=&quot;188&quot; height=&quot;1.88&quot;&gt;&lt;/Son&gt;</span><br><span class="line">                &lt;Son name=&quot;indexjs&quot; age=&quot;11118&quot; height=&quot;1.8228&quot;&gt;&lt;/Son&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-组件传递信息时的数据验证"><a href="#2-组件传递信息时的数据验证" class="headerlink" title="2. 组件传递信息时的数据验证"></a>2. 组件传递信息时的数据验证</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import PropTypes from &quot;prop-types&quot;;</span><br><span class="line"></span><br><span class="line">function Son(props) &#123;</span><br><span class="line">    const &#123; name, age, height, names &#125; = props;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h2&gt;&#123;name + &quot; &quot; + age + &quot; &quot; + height&#125;&lt;/h2&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    names.map((item, index) =&gt; &#123;</span><br><span class="line">                        return &lt;li&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired,</span><br><span class="line">    age: PropTypes.number,</span><br><span class="line">    height: PropTypes.number,</span><br><span class="line">    names: PropTypes.array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 默认属性</span><br><span class="line">Son.defaultProps = &#123;</span><br><span class="line">    name: &quot;hcb&quot;,</span><br><span class="line">    age: 11,</span><br><span class="line">    height: 178,</span><br><span class="line">    names: [&quot;hcb&quot;, &quot;bbxk&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Son name=&quot;beiyep333&quot; age=&quot;18&quot; height=&quot;1.88&quot; names=&#123;[&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]&#125;&gt;&lt;/Son&gt;</span><br><span class="line">                &lt;Son name=&quot;hala333&quot; age=&quot;188&quot; height=&quot;1.88&quot; names=&#123;[&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;]&#125;&gt;&lt;/Son&gt;</span><br><span class="line">                &lt;Son name=&quot;indexjs函数&quot; age=&quot;11118&quot; height=&quot;1.8228&quot;&gt;&lt;/Son&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript:call和apply的ES6和ES5实现</title>
    <url>/2022/02/07/JavaScript:%20call%E5%92%8Capply%E7%9A%84ES5%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h3 id="JavaScript-call和apply的ES6和ES5实现"><a href="#JavaScript-call和apply的ES6和ES5实现" class="headerlink" title="JavaScript:call和apply的ES6和ES5实现"></a>JavaScript:call和apply的ES6和ES5实现</h3><h4 id="首先来看一下call和apply的定义和作用"><a href="#首先来看一下call和apply的定义和作用" class="headerlink" title="首先来看一下call和apply的定义和作用"></a>首先来看一下call和apply的定义和作用</h4><blockquote>
<p>**<code>call()</code> **方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p>
</blockquote>
<p>总的来说，call和apply的区别就是参数的不同。</p>
<span id="more"></span>

<h4 id="call的实现"><a href="#call的实现" class="headerlink" title="call的实现"></a>call的实现</h4><p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>需要注意的两点是：</p>
<ul>
<li><p>call 改变了 this 的指向，指向到 foo</p>
</li>
<li><p>bar 函数执行了</p>
</li>
</ul>
<h5 id="call实现的第一步："><a href="#call实现的第一步：" class="headerlink" title="call实现的第一步："></a>call实现的第一步：</h5><p>当调用 call 的时候，可以把 foo 对象改造成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">foo.bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>但是这样会给foo对象多加了一个属性，不过可以使用之后可以删除。</p>
<p>所以这个可以拆分成三步：</p>
<ul>
<li><p>将函数设为对象的属性</p>
</li>
<li><p>执行该函数</p>
</li>
<li><p>删除该函数</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一步</span></span><br><span class="line">foo.fn = bar</span><br><span class="line"><span class="comment">// 第二步</span></span><br><span class="line">foo.fn()</span><br><span class="line"><span class="comment">// 第三步</span></span><br><span class="line"><span class="keyword">delete</span> foo.fn</span><br></pre></td></tr></table></figure>

<p>所以call的v1可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callES6v1</span></span><br><span class="line">Function.prototype.myCall = function(context) &#123;</span><br><span class="line">    <span class="comment">// 首先要获取调用call的函数，用this可以获取</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    context.fn();</span><br><span class="line">    delete context.fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是要注意的几个问题：</p>
<p><strong>1.this 参数可以传 null，当为 null 的时候，视为指向 window</strong></p>
<p><strong>2.函数是可以有返回值的！</strong></p>
<p><strong>3.call可以传入多个参数</strong></p>
<p><strong>4.给对象添加的属性名不能冲突</strong></p>
<p><strong>5.调用call的必须是函数</strong></p>
<p>这些都是小问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callES6v2</span></span><br><span class="line">Function.prototype.myCall = function(context, ...args) &#123;</span><br><span class="line">  	<span class="keyword">if</span>(typeof <span class="keyword">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// this 参数可以传 null，当为 null 的时候，视为指向 window</span></span><br><span class="line">    context = context || window;</span><br><span class="line">  	<span class="comment">// 给对象添加的属性名不能冲突</span></span><br><span class="line">    <span class="keyword">const</span> fn = Symbol();</span><br><span class="line">    context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  	<span class="comment">// call可以传入多个参数</span></span><br><span class="line">    let result = context[fn](...args);</span><br><span class="line">    delete context[fn];</span><br><span class="line">  	<span class="comment">// 函数是可以有返回值的</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上就是call的es6实现，下面手写es5实现。es5实现逻辑和es6一样，前面都分析好了，就是语法的问题而已。</p>
<p>需要理解的语法：</p>
<ul>
<li><code>eval()</code> 函数会将传入的字符串当做 JavaScript 代码进行执行。可以理解为HTML5中的script标签。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// callES5</span></span><br><span class="line"><span class="comment">// 模拟symbol的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySymbol</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> unique_proper = <span class="string">&#x27;hcb&#x27;</span> + <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(unique_proper)) &#123;</span><br><span class="line">        unique_proper += <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unique_proper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myCallES5 = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    fn = mySymbol(context);</span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 如果只有一个参数的话，那么直接返回对象执行绑定函数的结果。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> context[fn]();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">        args.push(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fnStr = <span class="string">&#x27;context[fn](&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        fnStr += i == args.length - <span class="number">1</span> ? args[i] : args[i] + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fnStr += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(fnStr);</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同理，apply的es6实现和es5实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApplyES6v2 = <span class="function"><span class="keyword">function</span> (<span class="params">context, args</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result = context[fn](...args);</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="comment">// 这里为什么要return呢，因为可能绑定的函数会返回一个对象</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySymbol</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> unique_proper = <span class="string">&#x27;hcb&#x27;</span> + <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(unique_proper)) &#123;</span><br><span class="line">        unique_proper += <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unique_proper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> fn = mySymbol(context);</span><br><span class="line">    context[fn] = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> context[fn]();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fnStr = <span class="string">&#x27;context[fn](&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">        fnStr += i == args.length - <span class="number">1</span> ? args[i] : args[i] + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fnStr += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="built_in">eval</span>(fnStr);</span><br><span class="line">    <span class="keyword">delete</span> context[fn];</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript:探索bind和new之间的关系</title>
    <url>/2022/02/07/JavaScript:%20%E6%8E%A2%E7%B4%A2bind%E5%92%8Cnew%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="JavaScript-探索bind和new之间的关系"><a href="#JavaScript-探索bind和new之间的关系" class="headerlink" title="JavaScript:探索bind和new之间的关系"></a>JavaScript:探索bind和new之间的关系</h3><p>首先了解一下bind的定义</p>
<blockquote>
<p><strong><code>bind()</code></strong> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
</blockquote>
<p>也就是说bind和apply和call不一样，bind是返回一个函数，并且可以传入参数。来看一看bind的例子</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回了一个函数</span></span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo); </span><br><span class="line">bindFoo(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>bind返回的是一个函数，并且返回的函数可以继续传入参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.bind(foo, <span class="string">&#x27;daisy&#x27;</span>);</span><br><span class="line">bindFoo(<span class="string">&#x27;18&#x27;</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// daisy</span></span><br><span class="line"><span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>所以要对参数进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 获取bind2函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个时候的arguments是指bind返回的函数传入的参数，这个arguments和上面的不是同一个</span></span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里bind的基本功能差不多完成了，但是bind还有一个特点，那就是和new配合使用的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。下面这个例子就可以说明。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">function <span class="title">bar</span><span class="params">(name, age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.habit = <span class="string">&#x27;shopping&#x27;</span>;</span><br><span class="line">    console.log(<span class="keyword">this</span>.value);</span><br><span class="line">    console.log(name);</span><br><span class="line">    console.log(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bindFoo = bar.myBind(foo, <span class="string">&#x27;hcb&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> bindFoo(<span class="string">&#x27;18&#x27;</span>); <span class="comment">// this值已经失效了</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// hcb</span></span><br><span class="line"><span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>所以我们要通过修改返回的函数的原型来实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span></span><br><span class="line">        <span class="comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span></span><br><span class="line">      	<span class="comment">// 这里有同学就问了，这里怎么判定this是属于构造函数还是普通函数的呢？</span></span><br><span class="line">      	<span class="comment">// 因为bind返回的是一个函数的定义，在new中这个函数被调用，所以这里的this是到调用的时候才确定的</span></span><br><span class="line">      	<span class="comment">// </span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fBound ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，因为js中对象是引用传递</span></span><br><span class="line">    fBound.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 只有函数才能调用bind，所以要加这个判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fNOP.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>来看一下new的手写实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew4</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;fn must be a function&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = fn.prototype;</span><br><span class="line">    <span class="comment">// 如果fn返回值是一个对象的话，那么就返回这个对象里面的东西</span></span><br><span class="line">    <span class="comment">// 如果不是的话，那么就返回构造出来的对象</span></span><br><span class="line">    <span class="comment">// console.log(obj);</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">// 这里的fn可以看作bind里面return出来的fBound，所以到这里fBound的this就被改变了</span></span><br><span class="line">    <span class="keyword">let</span> res = fn.apply(obj, args); <span class="comment">// obj变成fn这个函数的this</span></span><br><span class="line">    <span class="comment">// console.log(obj);</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? res : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
