<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS几种常见的布局</title>
    <url>/2022/01/31/CSS%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="几种常见且基础的CSS布局"><a href="#几种常见且基础的CSS布局" class="headerlink" title="几种常见且基础的CSS布局"></a>几种常见且基础的CSS布局</h3><h4 id="一-单列布局"><a href="#一-单列布局" class="headerlink" title="一. 单列布局"></a>一. 单列布局</h4><p>常见的单列布局有两种：</p>
<ul>
<li>header,content和footer等宽的单列布局</li>
<li>header与footer等宽,content略窄的单列布局</li>
</ul>
<span id="more"></span>

<ol>
<li><p>第一种通过设置header、content、footer统一设置width：1000px;或者max-width：1000px即可实现。区别在于显示屏幕小于1000px时，前者会有滚动条出现，而后者不会（也就是说后者显示的是实际宽度）</p>
<blockquote>
<p>max-width 属性用来给元素设置最大宽度值. 定义了max-width的元素会在达到max-width值之后避免进一步按照width属性设置变大.</p>
<p>max-width 会覆盖width设置, 但 min-width设置会覆盖 max-width.</p>
</blockquote>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.header</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 1960px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.content</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 1960px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.footer</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 1960px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> teal<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
<li><p>第二种可以给中间的content设置一个固定的width，然后header、content、footer都居中显示。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.header</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.content</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 100px auto 100px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 1000px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.footer</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>header<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>footer<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
</ol>
<h4 id="二-两列布局"><a href="#二-两列布局" class="headerlink" title="二. 两列布局"></a>二. 两列布局</h4><p>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式</p>
<ol>
<li><p>普通两列布局（单列定宽单列自适应），用浮动+margin即可</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.left</span> <span class="token punctuation">{</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 450px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.right</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
<li><p>两列自适应布局：float和overflow配合可实现两列自适应效果。使用overflow属性来触发bfc，来阻止浮动造成的文字环绕效果。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.p</span> <span class="token punctuation">{</span>
            <span class="token property">margin</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token selector">.content</span> <span class="token punctuation">{</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> grey<span class="token punctuation">;</span>
            <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token selector">.left</span> <span class="token punctuation">{</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">margin-right</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token selector">.right</span> <span class="token punctuation">{</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
<li><p>Flex布局：也叫弹性盒子布局，简单几行代码就可以实现各种页面的的布局。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.content</span> <span class="token punctuation">{</span>
            <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.right</span> <span class="token punctuation">{</span>
            <span class="token property">margin-left</span><span class="token punctuation">:</span> 30px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">flex</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.left</span> <span class="token punctuation">{</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>content<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>111111jlfdjlfjowejfoewjo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre>





<h4 id="3-三栏布局"><a href="#3-三栏布局" class="headerlink" title="3. 三栏布局"></a>3. 三栏布局</h4><blockquote>
<p>三栏布局就是两边宽度固定,中间自适应的布局.</p>
<p>改变浏览器的宽度,两边的宽度不会变,只会中间区域的宽度变长变短.</p>
</blockquote>
<p>流体布局：</p>
<p>圣杯布局：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>IE=edge<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style"><span class="token language-css">
        <span class="token selector">.container</span> <span class="token punctuation">{</span>
            <span class="token property">padding-left</span><span class="token punctuation">:</span> 220px<span class="token punctuation">;</span>
            <span class="token property">padding-right</span><span class="token punctuation">:</span> 220px<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.main</span> <span class="token punctuation">{</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 500px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> lightgrey<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.left</span> <span class="token punctuation">{</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
            <span class="token property">margin-left</span><span class="token punctuation">:</span> -100%<span class="token punctuation">;</span>
            <span class="token comment">/* margin-left: -200px; */</span>
            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
            <span class="token property">left</span><span class="token punctuation">:</span> -220px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> lightblue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token selector">.right</span> <span class="token punctuation">{</span>
            <span class="token property">float</span><span class="token punctuation">:</span> left<span class="token punctuation">;</span>
            <span class="token property">width</span><span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>
            <span class="token property">height</span><span class="token punctuation">:</span> 400px<span class="token punctuation">;</span>
            <span class="token property">margin-left</span><span class="token punctuation">:</span> -200px<span class="token punctuation">;</span>
            <span class="token comment">/* margin-left: -100%; */</span>
            <span class="token comment">/* margin-left中百分比是距离最近的块容器的宽度 width */</span>
            <span class="token comment">/* 而px的话就是绝对距离 */</span>
            <span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span>
            <span class="token property">right</span><span class="token punctuation">:</span> -220px<span class="token punctuation">;</span>
            <span class="token property">background</span><span class="token punctuation">:</span> lightgreen<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span></code></pre></li>
</ol>
]]></content>
      <categories>
        <category>CSS笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript:call和apply的ES6和ES5实现</title>
    <url>/2022/02/07/JavaScript:%20call%E5%92%8Capply%E7%9A%84ES5%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h3 id="JavaScript-call和apply的ES6和ES5实现"><a href="#JavaScript-call和apply的ES6和ES5实现" class="headerlink" title="JavaScript:call和apply的ES6和ES5实现"></a>JavaScript:call和apply的ES6和ES5实现</h3><h4 id="首先来看一下call和apply的定义和作用"><a href="#首先来看一下call和apply的定义和作用" class="headerlink" title="首先来看一下call和apply的定义和作用"></a>首先来看一下call和apply的定义和作用</h4><blockquote>
<p>**<code>call()</code> **方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p>
</blockquote>
<p>总的来说，call和apply的区别就是参数的不同。</p>
<span id="more"></span>

<h4 id="call的实现"><a href="#call的实现" class="headerlink" title="call的实现"></a>call的实现</h4><p>举个例子：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre>

<p>需要注意的两点是：</p>
<ul>
<li><p>call 改变了 this 的指向，指向到 foo</p>
</li>
<li><p>bar 函数执行了</p>
</li>
</ul>
<h5 id="call实现的第一步："><a href="#call实现的第一步：" class="headerlink" title="call实现的第一步："></a>call实现的第一步：</h5><p>当调用 call 的时候，可以把 foo 对象改造成如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token function-variable function">bar</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span></code></pre>

<p>但是这样会给foo对象多加了一个属性，不过可以使用之后可以删除。</p>
<p>所以这个可以拆分成三步：</p>
<ul>
<li><p>将函数设为对象的属性</p>
</li>
<li><p>执行该函数</p>
</li>
<li><p>删除该函数</p>
</li>
</ul>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 第一步</span>
foo<span class="token punctuation">.</span>fn <span class="token operator">=</span> bar
<span class="token comment">// 第二步</span>
foo<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 第三步</span>
<span class="token keyword">delete</span> foo<span class="token punctuation">.</span>fn</code></pre>

<p>所以call的v1可以这样写：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// callES6v1</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token function">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 首先要获取调用call的函数，用this可以获取</span>
    context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    delete context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>接下来就是要注意的几个问题：</p>
<p><strong>1.this 参数可以传 null，当为 null 的时候，视为指向 window</strong></p>
<p><strong>2.函数是可以有返回值的！</strong></p>
<p><strong>3.call可以传入多个参数</strong></p>
<p><strong>4.给对象添加的属性名不能冲突</strong></p>
<p><strong>5.调用call的必须是函数</strong></p>
<p>这些都是小问题：</p>
<pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// callES6v2</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>myCall <span class="token operator">=</span> <span class="token function">function</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">if</span><span class="token punctuation">(</span>typeof <span class="token keyword">this</span> <span class="token operator">!=</span><span class="token operator">=</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  	<span class="token comment">// this 参数可以传 null，当为 null 的时候，视为指向 window</span>
    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
  	<span class="token comment">// 给对象添加的属性名不能冲突</span>
    <span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  	<span class="token comment">// call可以传入多个参数</span>
    let result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    delete context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
  	<span class="token comment">// 函数是可以有返回值的</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>以上就是call的es6实现，下面手写es5实现。es5实现逻辑和es6一样，前面都分析好了，就是语法的问题而已。</p>
<p>需要理解的语法：</p>
<ul>
<li><code>eval()</code> 函数会将传入的字符串当做 JavaScript 代码进行执行。可以理解为HTML5中的script标签。</li>
</ul>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// callES5</span>
<span class="token comment">// 模拟symbol的函数</span>
<span class="token keyword">function</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> unique_proper <span class="token operator">=</span> <span class="token string">'hcb'</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>unique_proper<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unique_proper <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unique_proper<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCallES5</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
    fn <span class="token operator">=</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  
  	<span class="token comment">// 如果只有一个参数的话，那么直接返回对象执行绑定函数的结果。</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arguments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> fnStr <span class="token operator">=</span> <span class="token string">'context[fn]('</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fnStr <span class="token operator">+=</span> i <span class="token operator">==</span> args<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">','</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    fnStr <span class="token operator">+=</span> <span class="token string">')'</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span>fnStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>同理，apply的es6实现和es5实现如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApplyES6v2</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  
    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
    fn <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> result <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn<span class="token punctuation">;</span>
    <span class="token comment">// 这里为什么要return呢，因为可能绑定的函数会返回一个对象</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// es5的写法</span>
<span class="token keyword">function</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> unique_proper <span class="token operator">=</span> <span class="token string">'hcb'</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>unique_proper<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        unique_proper <span class="token operator">+=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> unique_proper<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    context <span class="token operator">=</span> context <span class="token operator">||</span> window<span class="token punctuation">;</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token function">mySymbol</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> fnStr <span class="token operator">=</span> <span class="token string">'context[fn]('</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> args<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fnStr <span class="token operator">+=</span> i <span class="token operator">==</span> args<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">?</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span> args<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">','</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    fnStr <span class="token operator">+=</span> <span class="token string">')'</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span>fnStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript: prototype、__proto__、[[prototype]]的区别</title>
    <url>/2022/02/03/JavaScript:%20prototype%E3%80%81__proto__%E3%80%81%5B%5Bprototype%5D%5D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="prototype、-proto-、-prototype-三者之间的区别"><a href="#prototype、-proto-、-prototype-三者之间的区别" class="headerlink" title="prototype、__proto__、[[prototype]] 三者之间的区别"></a>prototype、__proto__、[[prototype]] 三者之间的区别</h3><p>最近在网上看到 <code>instanceof</code> 的手写版，里面涉及到了 <code>prototype</code>、<code>__proto__</code>，仔细推敲 一下代码，发现自己对 <code>prototype</code>, <code>__proto__ </code> 的理解不够深刻导致自己对手写版的 instanceof 代码理解不是很透彻。</p>
<span id="more"></span>

<p>首先来看一下 <code>instanceof</code> 的手写代码</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myInstanceof</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> constructor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 拿到obj的</span>
    <span class="token keyword">let</span> implicitPrototype <span class="token operator">=</span> obj<span class="token operator">?.</span>__proto__<span class="token punctuation">;</span>
    <span class="token keyword">const</span> displayPrototype <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>implicitPrototype<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>implicitPrototype <span class="token operator">===</span> displayPrototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        implicitPrototype <span class="token operator">=</span> implicitPrototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>如果不是很清楚 <code>prototype</code> , <code>__proto__</code> 的话，很难正确理解上述代码。所以我们先要搞清楚它们的区别。</p>
<p><strong>1. 概念区分</strong></p>
<p>其实说 <code>__proto__</code> 并不准确，确切的说是对象的 <code>[[prototype]]</code> 属性，只不过在主流的浏览器中，都用 <code>__proto__</code> 来代表 <code>[[prototype]]</code> 属性，因为 <code>[[prototype]] </code>只是一个标准，而针对这个标准，不同的浏览器有不同的实现方式。在ES5中用 <code>Object.getPrototypeOf</code> 函数获得一个对象的 <code>[[prototype]]</code>。ES6中，使用  <code>Object.setPrototypeOf</code> 可以直接修改一个对象的 <code>[[prototype]]</code>。</p>
<p>而 <code>prototype</code> 属性是只有函数才特有的属性，当你创建一个函数时，js会自动为这个函数加上 <code>prototype</code> 属性，值是一个空对象。所以，函数在js中是非常特殊的，是所谓的一等公民。</p>
<p><strong>2.必须明确</strong></p>
<p><code>__proto__ </code>是隐式原型</p>
<p><code>prototype</code> 是显式原型</p>
<p>显式原型 ：每一个函数在创建之后都会拥有一个名为 <code>prototype</code> 的属性，这个属性指向函数的原型对象。</p>
<p>隐式原型：JavaScript中任意对象都有一个内置属性 <code>[[prototype]]</code>，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过 <code>__proto__</code> 来访问。</p>
<p>注意:  <code>Object.prototype</code> 这个对象是个例外，它的 <code>__proto__</code> 值为 <code>null</code></p>
<p><strong>二者的关系：</strong></p>
<p><strong>隐式原型指向创建这个对象的函数(constructor)的 prototype</strong></p>
<p><strong>3.他们的作用</strong></p>
<p>隐式原型的作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问 obj 这个对象中的x属性时，如果在 obj 中找不到，那么就会沿着 <code>__proto__</code> 依次查找。</p>
<p>显式原型的作用：用来实现基于原型的继承与属性的共享</p>
<p>所以现在我们可以分析一下 <code>instanceof </code>代码了。一般来说，<code>instanceof </code>内部实现机制和隐式原型、显式原型有直接的关系。<code>instanceof </code>的左值一般是一个对象，右值一般是一个构造函数，用来判断左值是否是右值的实例。</p>
<p>所以在我们的手写代码中：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//设 obj instanceof constructor</span>
<span class="token comment">//通过判断</span>
 obj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">...</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">===</span> constructor<span class="token punctuation">.</span>prototype
<span class="token comment">//最终返回true or false</span></code></pre>

<p>也就是一直沿着obj的 <code>__proto__ </code> 一直寻找下去，知道等于 <code>constructor.prototype</code> 或者 <code>null</code> 为止。</p>
<p>这就是instanceof的原理</p>
<p>4.进一步的探究</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>

<p>上面两行代码的结果都为 true，这就有点奇怪了</p>
<h6 id="接下来我们来探究一下："><a href="#接下来我们来探究一下：" class="headerlink" title="接下来我们来探究一下："></a>接下来我们来探究一下：</h6><pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//null</span></code></pre>

<p>所以原型链的尽头（root）是 <code>Object.prototype</code>。<strong>所有对象均从 <code>Object.prototype</code> 继承属性。</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Function<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Function<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>

<p>所以 <code>Function.prototype</code>  和 <code>Function.__proto__</code> 为<strong>同一对象</strong>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Array<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> String<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Object<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Number<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token operator">===</span> Boolean<span class="token punctuation">.</span>__proto__<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>

<p>这意味着： <strong><code>Object</code>/<code>Array</code>/<code>String</code> 等等构造函数本质上和 <code>Function</code> 一样，均继承于 <code>Function.prototype</code>。</strong></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>

<p>最后 <code>Function.prototype</code> 直接继承 <code>Object.prototype</code></p>
<p><strong>总结</strong>：<strong>先有 <code>Object.prototype</code>（原型链顶端）， <code>Function.prototype</code> 继承 <code>Object.prototype</code> 而产生，最后，<code>Function</code> 和 <code>Object</code> 和其它构造函数继承 <code>Function.prototype</code> 而产生。</strong></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript：探索bind和new之间的关系</title>
    <url>/2022/02/07/JavaScript:%20%E6%8E%A2%E7%B4%A2bind%E5%92%8Cnew%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="JavaScript-手写-bind-和探索-bind-与-new-之间的关系"><a href="#JavaScript-手写-bind-和探索-bind-与-new-之间的关系" class="headerlink" title="JavaScript: 手写 bind 和探索 bind 与 new 之间的关系"></a>JavaScript: 手写 bind 和探索 bind 与 new 之间的关系</h3><p>首先了解一下 <code>bind</code> 的定义</p>
<blockquote>
<p><strong><code>bind()</code></strong> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
</blockquote>
<p>也就是说 <code>bind</code> 和 <code>apply</code> 、<code>call</code> 不一样，<code>bind</code> 是返回一个待执行函数，并且可以传入参数。来看一看 <code>bind</code> 的例子</p>
<span id="more"></span>

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 返回了一个函数</span>
<span class="token keyword">var</span> bindFoo <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token comment">// bindFoo() 相当于 bar.bind(foo)();</span></code></pre>

<p>所以 <code>bind</code> 返回的是一个函数（这也是为什么 <code>new</code> 可以改变 <code>bind</code>  后函数的 <code>this</code> 指向的原因）并且返回的函数可以继续传入参数。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bindFoo <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'daisy'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bindFoo</span><span class="token punctuation">(</span><span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1</span>
<span class="token comment">// daisy</span>
<span class="token comment">// 18</span></code></pre>

<p>所以要对参数进行处理。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 第二版</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取myBind第二个参数到最后一个参数</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这个时候的arguments是指bind返回的函数传入的参数，这个arguments和上面的不是同一个</span>
        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>



<p>到这里 <code>bind</code> 的基本功能差不多完成了，但是 <code>bind</code> 还有一个特点，那就是和 <code>new</code> 配合使用的时候，<code>bind </code> 时指定的  <code>this</code>  值会失效，但传入的参数依然生效。下面这个例子就可以说明。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>habit <span class="token operator">=</span> <span class="token string">'game'</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bindFoo <span class="token operator">=</span> bar<span class="token punctuation">.</span><span class="token function">myBind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token string">'hcb'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bindFoo</span><span class="token punctuation">(</span><span class="token string">'18'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里bind绑定的this值已经失效了</span>
<span class="token comment">// undefined</span>
<span class="token comment">// hcb</span>
<span class="token comment">// 18</span></code></pre>

<p>所以我们要通过修改返回的函数的原型来实现</p>
<p>特别要注意下面的代码执行完只是返回 <code>fBound</code> ，函数里面的语句还未执行，所以这就是为什么这里能判断 <code>fBound</code> 里面的 <code>this</code> 到底指向普通函数还是构造函数</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值</span>
        <span class="token comment">// 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context</span>
      	<span class="token comment">// 这里有同学就问了，这里怎么判定this是属于构造函数还是普通函数的呢？</span>
      	<span class="token comment">// 因为bind返回的是一个函数的定义，在new中这个函数被调用，所以这里的this是到调用的时候才确定的</span>
      	<span class="token comment">// </span>
        <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fBound</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值，因为js中对象是引用传递</span>
    fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token keyword">return</span> fBound<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。为什么也会直接修改呢？因为这里是引用类型，这个时候，我们可以通过一个空函数来进行中转。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  	<span class="token comment">// 只有函数才能调用bind，所以要加这个判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">"function"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Function.prototype.bind - what is trying to be bound is not callable"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">fNOP</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> <span class="token function-variable function">fBound</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> bindArgs <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">fNOP</span> <span class="token operator">?</span> <span class="token keyword">this</span> <span class="token operator">:</span> context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>bindArgs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    fNOP<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    fBound<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">fNOP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> fBound<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>来看一下 <code>new</code> 的手写实现：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myNew4</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> fn <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token string">'fn must be a function'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token comment">// 如果fn返回值是一个对象的话，那么就返回这个对象里面的东西</span>
    <span class="token comment">// 如果不是的话，那么就返回构造出来的对象</span>
    <span class="token comment">// console.log(obj);</span>
  	
  	<span class="token comment">// 这里的fn可以看作bind里面return出来的fBound，所以到这里fBound的this就被改变了</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj变成fn这个函数的this</span>
    <span class="token comment">// console.log(obj);</span>
    <span class="token keyword">return</span> res <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> res <span class="token operator">:</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote01：React的特点和优点</title>
    <url>/2022/01/12/ReactNote01:%20React%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E7%82%B9/</url>
    <content><![CDATA[<p>React作为国内最流行的前端框架之一，肯定有它的好用先进之处，作为技术geek，那肯定要学穿它🤔</p>
<span id="more"></span>

<h3 id="React的特点"><a href="#React的特点" class="headerlink" title="React的特点"></a>React的特点</h3><ol>
<li>声明式编程<ul>
<li>允许我们只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界面;</li>
</ul>
</li>
<li>组件化开发<ul>
<li>能把一个大问题分解成一个小问题一个个实现，便于开发和维护。</li>
</ul>
</li>
<li>多平台适配<ul>
<li>React不仅能开发网页应用，React Native也能开发Android和iOS应用。</li>
</ul>
</li>
</ol>
<blockquote>
<p>除此之外，学习React还能掌握先进的技术和思想。并且React的思想被许多框架借鉴，比如Google的Flutter框架就借鉴了React的思想，老美有意思的一点就是他借鉴React的思想，直接官网摆明了说出来。</p>
</blockquote>
<h3 id="React开发依赖"><a href="#React开发依赖" class="headerlink" title="React开发依赖"></a><strong>React开发依赖</strong></h3><p>开发React必须依赖三个库:</p>
<ul>
<li>react:包含react所必须的核心代码</li>
<li>react-dom:react渲染在不同平台所需要的核心代码</li>
<li>babel:将jsx转换成React代码的工具<ul>
<li>babel可以将es6语法转换为es5语法，并且可以将jsx语法转换为js语法。帮助我们更好的进行开发。</li>
</ul>
</li>
</ul>
<blockquote>
<p> react包中包含了react和react-native所共同拥有的核心代码。</p>
</blockquote>
<p>react-dom针对web和native所完成的事情不同:</p>
<ul>
<li>web端:react-dom会讲jsx最终渲染成真实的DOM，显示在浏览器中</li>
<li>native端:react-dom会讲jsx最终渲染成原生的控件(比如Android中的Button，iOS中的UIButton)</li>
</ul>
<h3 id="React的优点"><a href="#React的优点" class="headerlink" title="React的优点"></a>React的优点</h3><p>为什么需要React呢，我们来看一个案例，要求点击按钮，网页上的文字内容会发生改变。</p>
<p>以下是原生实现。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>change text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">

        <span class="token comment">// 这里是命令式编程，就是给计算机一步步指令去完成一件事</span>

        <span class="token comment">// 1.定义数据</span>
        <span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token string">"Hello, World!"</span><span class="token punctuation">;</span>

        <span class="token comment">// 2.将数据显示在h2元素中</span>
        <span class="token keyword">let</span> titleEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"title"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        titleEl<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> message<span class="token punctuation">;</span>

        <span class="token comment">// 3.点击按钮，页面数据发生改变</span>
        <span class="token keyword">let</span> btnEl <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByClassName</span><span class="token punctuation">(</span><span class="token string">"btn"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        btnEl<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">"click"</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            message <span class="token operator">=</span> <span class="token string">"Hello, React!"</span><span class="token punctuation">;</span>
            titleEl<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> message<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>再来看看React实现，是不是感觉代码有点多，还比原生的复杂了。这里是因为我们调用了render函数，并且还没用到React的声明式编程和组件化开发的特点。</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/babel<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">

        <span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token string">"Hello,World!"</span><span class="token punctuation">;</span>

        <span class="token keyword">function</span> <span class="token function">btnClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            message <span class="token operator">=</span> <span class="token string">"Hello,React!"</span><span class="token punctuation">;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">function</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
                <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>btnClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>change text<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">,</span>
                document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>


    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react@16/umd/react.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react-dom@16/umd/react-dom.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- babel转换代码 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/babel-standalone@6/babel.min.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>下面再来看利用了React特点写的代码</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/babel<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
        <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
            <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
                    message<span class="token operator">:</span> <span class="token string">"Hello,World"</span><span class="token punctuation">,</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>

            <span class="token function-variable function">render</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span>
                    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                        <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
                        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>btnClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>change text<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token function-variable function">btnClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token comment">// this.state.message = "Hello,React";</span>
                <span class="token comment">// console.log(this.state);</span>

                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                    message<span class="token operator">:</span> <span class="token string">"Hello,React"</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"app"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react@16/umd/react.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/react-dom@16/umd/react-dom.development.js<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- babel转换代码 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://unpkg.com/babel-standalone@6/babel.min.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>看起来确实优雅了不少。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript：JavaScript数组探究</title>
    <url>/2022/01/08/JavaScript%E6%95%B0%E7%BB%84%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="JavaScript数组探究"><a href="#JavaScript数组探究" class="headerlink" title="JavaScript数组探究"></a>JavaScript数组探究</h1><p>数组作为最基础的数据结构，我们不仅要熟练掌握它，还要了解它的许多特性</p>
<p>js的数组很灵活，和其他语言的数组不一样，js的数组可以存储不同类型的值</p>
<span id="more"></span>

<h3 id="创建一维数组的两种方法"><a href="#创建一维数组的两种方法" class="headerlink" title="创建一维数组的两种方法"></a>创建一维数组的两种方法</h3><p>1.数组字面量法</p>
<p>需要注意的是：使用数组字面量法创建数组并不会调用Array构造函数</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>

<p>2.使用Array的构造函数，new一个数组</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 指定数组长度</span>
<span class="token keyword">let</span> arr3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 指定长度，且填充1</span>
<span class="token keyword">let</span> arr4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// new操作符可以省略，一个长度为二的数组</span>
<span class="token keyword">let</span> arr6 <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"arr6:"</span><span class="token punctuation">,</span> arr6<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 当参数只有一个数字的时候，就是创建一个长度为传入参数的数组</span>
<span class="token keyword">let</span> arr7 <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"arr7:"</span><span class="token punctuation">,</span> arr7<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 遍历数组</span>
arr4<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 还可以用map来遍历数组</span>
<span class="token comment">// map 方法在调用形式上与 forEach 无异，</span>
<span class="token comment">// 区别在于 map 方法会根据你传入的函数逻辑对数组中每个元素进行处理、进而返回一个全新的数组。</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"map遍历"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> arr5 <span class="token operator">=</span> arr4<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> item <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>·</code></pre>



<h3 id="二维数组的创建"><a href="#二维数组的创建" class="headerlink" title="二维数组的创建"></a>二维数组的创建</h3><p>一维数组可以使用数组字面量和使用Array的构造函数创建</p>
<p>那么二维数组呢？</p>
<p>下面来看一下这样初始化对不对</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 现在我们来改变一下二维数组里面的值</span>
arr1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里发现里面的值全都变成了35，这是为什么呢</span></code></pre>

<p>这里是因为 fill 的工作机制导致的。 当给 fill 传递一个入参时，如果这个入参的类型是引用类型，那么 fill 在填充坑位时填充的其实就是入参的引用。所以fill里面的数组是同一个引用、指向的是同一块内存空间，它们本质上是同一个数组所以应该用for循环来初始化一个二维数组</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<h3 id="数组的一些方法"><a href="#数组的一些方法" class="headerlink" title="数组的一些方法"></a>数组的一些方法</h3><h4 id="pop-push-shift-unshift-方法"><a href="#pop-push-shift-unshift-方法" class="headerlink" title="pop/push, shift/unshift 方法"></a>pop/push, shift/unshift 方法</h4><ul>
<li><p><code>push</code> 在末端添加一个元素</p>
</li>
<li><p><code>pop</code> 从末端取出一个元素</p>
</li>
<li><p><code>unshift</code> 在队列首端添加一个元素，整个队列往后移一位</p>
</li>
<li><p><code>shift</code> 取出队列首端的一个元素，整个队列往前移一位</p>
</li>
</ul>
<p>这里会有一个性能问题，那就是<code>push</code>和 <code>pop</code>的性能会比<code>shift</code>和<code>unshift</code>高，因为<code>shift</code>和<code>unshift</code>会移动整个数组，这样很浪费时间。</p>
<h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p>数组的遍历方式有三种</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"beiyep"</span><span class="token punctuation">,</span> <span class="token string">"kobe"</span><span class="token punctuation">,</span> <span class="token string">"james"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 用数组的长度遍历</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用for of遍历</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 用for in遍历</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>需要说明的是，for in返回的是数组的下标值，并且要注意：</p>
<ol>
<li><p><code>for..in</code> 循环会遍历 <strong>所有属性</strong>，不仅仅是这些数字属性。</p>
<p>在浏览器和其它环境中有一种称为“类数组”的对象，它们 <strong>看似是数组</strong>。也就是说，它们有 <code>length</code> 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。<code>for..in</code> 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。</p>
<p>来看下面的🌰：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myfun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'myfun'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>    
<span class="token keyword">var</span> arr2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> arr2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span></code></pre>

<p>运行结果如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy8x3wx4ndj30z80903yk.jpg"></p>
<p>上面的例子很好的反映了for…in…循环的缺点，原本只想循环取出该数组的数据，但是由于之前给数组添加了原型函数，导致循环的结果多了一个函数</p>
</li>
<li><p><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。</p>
</li>
</ol>
<h4 id="数组中的搜索"><a href="#数组中的搜索" class="headerlink" title="数组中的搜索"></a>数组中的搜索</h4><ol>
<li>严格相等</li>
</ol>
<p>js提供了indexOf/lastIndexOf 和 includes三种严格相等的搜索方法。其中</p>
<ul>
<li><code>arr.indexOf(item, from)</code> 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</li>
<li><code>arr.lastIndexOf(item, from)</code> —— 和上面相同，只是从右向左搜索。</li>
<li><code>arr.includes(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>，如果没找到，则返回 <code>false</code></li>
</ul>
<p>请注意，这些方法使用的是严格相等 <code>===</code> 比较。所以如果我们搜索 <code>false</code>，会精确到的确是 <code>false</code> 而不是数字 <code>0</code>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 从索引2开始搜索1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span>

<span class="token comment">// 从索引3开始搜索13</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>

<span class="token comment">// 从零开始搜索true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span></code></pre>



<p>如果我们想检查是否包含某个元素，并且不想知道确切的索引，那么 <code>arr.includes</code> 是首选。</p>
<p>此外，<code>includes</code> 的一个非常小的差别是它能正确处理<code>NaN</code>，而不像 <code>indexOf/lastIndexOf</code></p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">NaN</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr1<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>



<ol start="2">
<li>断言函数搜索</li>
</ol>
<p>arr.find和arr.findIndex是js提供的断言函数搜索，每个索引都会调用这个函数。</p>
<p>arr.find的语法如下：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果返回 true，则返回 item 并停止迭代</span>
  <span class="token comment">// 对于假值（false）的情况，则返回 undefined</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>arr.findIndex 方法（与 <code>arr.find</code> 方法）基本上是一样的，但它返回找到元素的索引，而不是元素本身。并且在未找到任何内容时返回 <code>-1</code>。</p>
<h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h4><p>由于数组是基于对象的，不构成单独的语言类型，所以 typeof 不能帮助从数组中区分出普通对象：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span></code></pre>

<p>为了解决这个问题，Array.isArray应运而生，如果 <code>value</code> 是一个数组，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>



<h4 id="数组中方法的补充说明"><a href="#数组中方法的补充说明" class="headerlink" title="数组中方法的补充说明"></a>数组中方法的补充说明</h4><p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p>
<p>比如：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">arr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> thisArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> thisArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> thisArg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
<span class="token comment">// thisArg 是可选的最后一个参数</span></code></pre>

<p>举个🌰：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> army <span class="token operator">=</span> <span class="token punctuation">{</span>
    minAge<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>
    maxAge<span class="token operator">:</span> <span class="token number">27</span><span class="token punctuation">,</span>
    <span class="token function">canJoin</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> user<span class="token punctuation">.</span>age <span class="token operator">&gt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>minAge <span class="token operator">&amp;&amp;</span> user<span class="token punctuation">.</span>age <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>maxAge<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token keyword">let</span> users <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 找到 army.canJoin 返回 true 的 user</span>
	<span class="token keyword">let</span> soldiers <span class="token operator">=</span> users<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>army<span class="token punctuation">.</span>canJoin<span class="token punctuation">,</span> army<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// let soldiers = users.filter(army.canJoin); // 错误</span>
  
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>soldiers<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>soldiers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>soldiers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 23</span></code></pre>

<p>如果在上面的示例中我们使用了 <code>users.filter(army.canJoin)</code>，那么 <code>army.canJoin</code> 将被作为独立函数调用，并且这时 <code>this=undefined</code>，从而会导致即时错误。所以我们这里一般都用剪头函数。</p>
<h3 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h3><p>数组是一种特殊的对象，比如数组访问元素的方式是arr[0]和对象obj[key]很相似，其中arr是对象，数字用作键。数组和类相似，也是引用类型。但是数组又拓展了对象，因为数组可以处理有序的数据集合。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote02：了解JSX语法</title>
    <url>/2022/01/12/ReactNote02:%E4%BA%86%E8%A7%A3JSX%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="欲要学好React，JSX语法须先行"><a href="#欲要学好React，JSX语法须先行" class="headerlink" title="欲要学好React，JSX语法须先行"></a>欲要学好React，JSX语法须先行</h3><h3 id="JSX-简介"><a href="#JSX-简介" class="headerlink" title="JSX 简介"></a>JSX 简介</h3><p>先来看这样的一段代码：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;</code></pre>

<p>是不是感觉有点怪怪的，因为它既不是字符串，也不是HTML，它就是 JSX，是一个 JavaScript 的语法扩展。React官方建议在 React 中配合使用 JSX，因为JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。</p>
<span id="more"></span>

<p><strong>在JSX中插入javascript的方式</strong></p>
<p>在 JSX 语法中，你可以在大括号内放置任何有效的 <strong>JavaScript 表达式</strong>。（什么是表达式？）</p>
<pre class="language-react" data-language="react"><code class="language-react">const name = 'james kobe';
const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;

ReactDOM.render(
  element,
  document.getElementById('root')
);</code></pre>

<p>为了便于阅读，我们可以将JSX语法拆分成多行，并将内容包裹在小括号中，这样可以避免陷入自动插入分号的陷阱。</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/div&gt;
);</code></pre>



<p><strong>JSX也是一个表达式</strong></p>
<p>在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。</p>
<p>也就是说，你可以在 <code>if</code> 语句和 <code>for</code> 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：</p>
<pre class="language-react" data-language="react"><code class="language-react">function getGreeting(user) {
  if (user) {
    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;
  }
  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;
}</code></pre>



<p><strong>JSX的特定属性</strong></p>
<p>你可以通过使用引号，来将属性值指定为字符串字面量：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;;</code></pre>

<p>也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code></pre>

<p>在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。</p>
<p><strong>需要注意的是：</strong></p>
<ul>
<li><p>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p>
</li>
<li><p>例如，JSX 里的 <code>class</code> 变成了 <code>className</code>，而 <code>tabindex</code> 则变为 <code>tabIndex</code>。</p>
</li>
<li><p>JSX的顶层<strong>只能有一个根元素</strong>，所以我们很多时候会在外层包裹一个div原生(或者使用后面我们学习的Fragment);</p>
</li>
<li><p>JSX中的标签可以是单标签，也可以是双标签。注意:如果是单标签，必须以<code>/&gt;</code>结尾;     </p>
</li>
</ul>
<p><strong>使用 JSX 指定子元素</strong></p>
<p>假如一个标签里面没有内容，也就是说这个标签是一个单标签的话，你可以使用 <code>/&gt;</code> 来闭合标签，就像 XML 语法一样：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = &lt;img src={user.avatarUrl} /&gt;;</code></pre>

<p>JSX 标签里能够包含很多子元素:</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/div&gt;
);</code></pre>



<p><strong>JSX 表示对象</strong></p>
<p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p>
<p>以下两种示例代码完全等效：</p>
<pre class="language-react" data-language="react"><code class="language-react">const element = (
  &lt;h1 className="greeting"&gt;
    Hello, world!
  &lt;/h1&gt;
);

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);</code></pre>



<h4 id="疑问：（什么是表达式？表达式和语句又有什么区别呢？）"><a href="#疑问：（什么是表达式？表达式和语句又有什么区别呢？）" class="headerlink" title="疑问：（什么是表达式？表达式和语句又有什么区别呢？）"></a>疑问：（什么是表达式？表达式和语句又有什么区别呢？）</h4><p>语句指的是执行单元，通常以行为单位，表达式指的是可用于计算的式子，即可能产生一个值的式子。语句可以包含有表达式，表达式也可以单独形成一个语句。</p>
<p><strong>表达式会产生一个值，如赋值表达式：a=1。在控制台输出1。</strong></p>
<p><strong>表达式可以参与运算</strong>，如：</p>
<p>var c = 1==2 ? 3 : 4;</p>
<p>1==2 是一个表达式，1==2 ? 3 : 4这也是一个表达式，表达式是由运算符构成并运算产生结果的语法结构。</p>
<p>我们通常用”;”来分隔语句，组成程序，而本身就是语句的语法结构如：</p>
<p>if(){}else{} for(){} 等。</p>
<p>表达式一般由操作符和操作数组成，而我们把表达式按照语法结构组成语句，然后组成程序，表达式跟语句有重合的部分。</p>
<p>因此可以理解为表达式通常是语句的一部分或者本身就能起到一个语句的作用，而语句代表一段可执行的程序的最小单元。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote03：JSX本质及源码解析</title>
    <url>/2022/01/17/ReactNote03:%20JSX%E6%9C%AC%E8%B4%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h3 id="JSX-的本质"><a href="#JSX-的本质" class="headerlink" title="JSX 的本质"></a>JSX 的本质</h3><p>实际上，jsx 仅仅只是 React.createElement(component, props, …children) 函数的语法糖。所有的 jsx 语法都会被转换为 React.createElement 语法的调用。</p>
<span id="more"></span>

<p>先来看一下几行 jsx 代码：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>nihao<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">&gt;</span></span>you are the best<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">&gt;</span></span>2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>那么它们转换成 js 代码会是什么样的呢？</p>
<pre class="language-js" data-language="js"><code class="language-js">React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"nihao"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"h2"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"you are the best"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                        React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"ul"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                            React<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"li"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>好家伙，直接一个嵌套地狱，要是代码再多一点的话能把人看哭。还是 jsx 香</p>
<blockquote>
<p> 查看 React.createElement 的源码</p>
<p>源码位置：packages/react/src/ReactElement.js</p>
</blockquote>
<pre class="language-react" data-language="react"><code class="language-react">/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
export function createElement(type, config, children) {
  let propName;

  // Reserved names are extracted
  const props = {};

  let key = null;
  let ref = null;
  let self = null;
  let source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      if (__DEV__) {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (
        hasOwnProperty.call(config, propName) &amp;&amp;
        !RESERVED_PROPS.hasOwnProperty(propName)
      ) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  const childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength &gt; 1) {
    const childArray = Array(childrenLength);
    for (let i = 0; i &lt; childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (__DEV__) {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type &amp;&amp; type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (__DEV__) {
    if (key || ref) {
      const displayName =
        typeof type === 'function'
          ? type.displayName || type.name || 'Unknown'
          : type;
      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }
      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
}
</code></pre>

<p>createElement的三个参数：</p>
<ul>
<li><ol>
<li>type</li>
</ol>
<ul>
<li>是当前 React 的类型，如果是标签元素，则用字符串表示，例如 “div”。如果是组件元素，则直接用组件名称</li>
</ul>
</li>
<li><ol start="2">
<li>config</li>
</ol>
<ul>
<li>所有 jsx 中的属性都在 config 中以对象的键值对存储</li>
</ul>
</li>
<li><ol start="3">
<li>存放标签中的内容，以数组的方式存储</li>
</ol>
<ul>
<li> 为什么是以数组的形式存储呢？</li>
<li>因为 jsx 里面可以会传入很多的同级标签，createElement 并不是只能传入三个参数。为什么可以传入多个参数呢？这就要回到源码里面一探究竟了，毕竟源码之下，了无秘密。</li>
</ul>
</li>
</ul>
<pre class="language-js" data-language="js"><code class="language-js"><span class="token keyword">const</span> childrenLength <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>childrenLength <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    props<span class="token punctuation">.</span>children <span class="token operator">=</span> children<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childrenLength <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> childArray <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>childrenLength<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> childrenLength<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      childArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>__DEV__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span>freeze<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>childArray<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    props<span class="token punctuation">.</span>children <span class="token operator">=</span> childArray<span class="token punctuation">;</span>
  <span class="token punctuation">}</span></code></pre>

<p>这里就是上面 createElement 源码的一部分，也就是说 children 是一个数组，里面存储着第三个参数及以后的所有参数。</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote04：组件通信方式</title>
    <url>/2022/01/31/ReactNote04:%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="组件间的通信方式"><a href="#组件间的通信方式" class="headerlink" title="组件间的通信方式"></a>组件间的通信方式</h3><h4 id="1-父组件传递信息给子组件"><a href="#1-父组件传递信息给子组件" class="headerlink" title="1. 父组件传递信息给子组件"></a>1. 父组件传递信息给子组件</h4><blockquote>
<p>先看React官网的一句话：当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。</p>
</blockquote>
<span id="more"></span>

<p>以下例子说明了父组件传递信息给子组件的方式是：在父组件的子组件中写形参的时候，React会将子组件接受到的属性转换为props对象传递给组件，所以渲染子组件的时候就可以使用props里面的数据了。函数组件同理。</p>
<pre class="language-react" data-language="react"><code class="language-react">import React, { Component } from 'react'
class Son extends Component {
    constructor(props) {
        super(props);
        this.state = {
        }
    }
    render() {
        // 为什么这里可以通过this.props取得父组件里面传来的值呢？
        const { name, age, height } = this.props;
        return (
            &lt;div&gt;
                &lt;h2&gt;{name + " " + age + " " + height}&lt;/h2&gt;
            &lt;/div&gt;
        )
    }
}

export default class App extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;Son name="beiyep" age="18" height="1.88"&gt;&lt;/Son&gt;
                &lt;Son name="hala" age="188" height="1.88"&gt;&lt;/Son&gt;
                &lt;Son name="indexjs" age="11118" height="1.8228"&gt;&lt;/Son&gt;
            &lt;/div&gt;
        )
    }
}</code></pre>



<h4 id="2-组件传递信息时的数据验证"><a href="#2-组件传递信息时的数据验证" class="headerlink" title="2. 组件传递信息时的数据验证"></a>2. 组件传递信息时的数据验证</h4><pre class="language-react" data-language="react"><code class="language-react">import React, { Component } from 'react';
import PropTypes from "prop-types";

function Son(props) {
    const { name, age, height, names } = props;
    return (
        &lt;div&gt;
            &lt;h2&gt;{name + " " + age + " " + height}&lt;/h2&gt;
            &lt;ul&gt;
                {
                    names.map((item, index) =&gt; {
                        return &lt;li&gt;{item}&lt;/li&gt;
                    })
                }
            &lt;/ul&gt;
        &lt;/div&gt;
    )
}

Son.propTypes = {
    name: PropTypes.string.isRequired,
    age: PropTypes.number,
    height: PropTypes.number,
    names: PropTypes.array
}

// 默认属性
Son.defaultProps = {
    name: "hcb",
    age: 11,
    height: 178,
    names: ["hcb", "bbxk"]
}



export default class App extends Component {
    render() {
        return (
            &lt;div&gt;
                &lt;Son name="beiyep333" age="18" height="1.88" names={["aaa", "bbb", "ccc"]}&gt;&lt;/Son&gt;
                &lt;Son name="hala333" age="188" height="1.88" names={["aaa", "bbb", "ccc"]}&gt;&lt;/Son&gt;
                &lt;Son name="indexjs函数" age="11118" height="1.8228"&gt;&lt;/Son&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre>



]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNote05：深入源码探究memo、PureComponent</title>
    <url>/2022/02/08/ReactNote05-%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%A9%B6memo%E3%80%81PureComponent/</url>
    <content><![CDATA[<h3 id="深入源码探究memo、PureComponent"><a href="#深入源码探究memo、PureComponent" class="headerlink" title="深入源码探究memo、PureComponent"></a>深入源码探究memo、PureComponent</h3><h4 id="窥探PureComponent"><a href="#窥探PureComponent" class="headerlink" title="窥探PureComponent"></a>窥探PureComponent</h4><p>今天学到了PureComponent，它可以起到在Component里面添加SCU的效果，虽然类组件以后会很少用，但是它的底层原理还是要了解一下，也能了解一下React不断进步背后的思想，PureComponent在React里面是怎么实现的呢，肘，跟我进源码（版本是16.3.1）。</p>
<p>这里安利一下vscode的Bookmarks插件，看源码是非常方便。</p>
<span id="more"></span>

<blockquote>
<p>以下源码均为节选</p>
</blockquote>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 路径</span>
<span class="token comment">// packages/react-reconciler/src/ReactFiberClassComponent.js</span>

<span class="token keyword">function</span> <span class="token function">checkShouldComponentUpdate</span><span class="token punctuation">(</span>
  <span class="token parameter">workInProgress<span class="token punctuation">,</span>
  ctor<span class="token punctuation">,</span>
  oldProps<span class="token punctuation">,</span>
  newProps<span class="token punctuation">,</span>
  oldState<span class="token punctuation">,</span>
  newState<span class="token punctuation">,</span>
  nextContext<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> instance <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>stateNode<span class="token punctuation">;</span>
    
  <span class="token comment">// 判断是否使用了shouldComponentUpdate</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> instance<span class="token punctuation">.</span>shouldComponentUpdate <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用了shouldComponentUpdate的话，那么就比较State和props的数据</span>
    <span class="token comment">// 如果变化就返回true，不变化的话就返回false</span>
    <span class="token keyword">const</span> shouldUpdate <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span>
      newProps<span class="token punctuation">,</span>
      newState<span class="token punctuation">,</span>
      nextContext<span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> shouldUpdate<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 判断是否使用了PureReactComponent</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ctor<span class="token punctuation">.</span>prototype <span class="token operator">&amp;&amp;</span> ctor<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>isPureReactComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token comment">// 浅层比较，注意有取反操作</span>
      <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldProps<span class="token punctuation">,</span> newProps<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">shallowEqual</span><span class="token punctuation">(</span>oldState<span class="token punctuation">,</span> newState<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    
  <span class="token comment">// 默认返回的是true，也就是更新</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<p>这里就弄清楚了判断组件的更新的逻辑，下面我们再看一下shallowEqual这个函数，按住commond进去，</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> shallowEqual <span class="token keyword">from</span> <span class="token string">'shared/shallowEqual'</span><span class="token punctuation">;</span></code></pre>

<p>去<code>share</code>文件夹里面找<code>shallowEqual</code>这个文件</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">shallowEqual</span><span class="token punctuation">(</span><span class="token parameter">objA<span class="token operator">:</span> mixed<span class="token punctuation">,</span> objB<span class="token operator">:</span> mixed</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
  <span class="token comment">// 同一个对象返回ture，到了checkShouldComponentUpdate那里就是false，因为进行取反操作了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 不是对象或者为空就强制刷新</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>
    <span class="token keyword">typeof</span> objA <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span>
    objA <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span>
    <span class="token keyword">typeof</span> objB <span class="token operator">!==</span> <span class="token string">'object'</span> <span class="token operator">||</span>
    objB <span class="token operator">===</span> <span class="token keyword">null</span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	
  
  <span class="token keyword">const</span> keysA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objA<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> keysB <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>objB<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
  <span class="token comment">// 如果两个对象的key的长度不一样的话，那么数据肯定发生了变化</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>keysA<span class="token punctuation">.</span>length <span class="token operator">!==</span> keysB<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
	
  <span class="token comment">// 如果A中和B中的key值不一样，那就更新</span>
  <span class="token comment">// Test for A's keys different from B.</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> keysA<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      <span class="token operator">!</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>objB<span class="token punctuation">,</span> keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token operator">!</span><span class="token function">is</span><span class="token punctuation">(</span>objA<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> objB<span class="token punctuation">[</span>keysA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>



<h4 id="窥探memo"><a href="#窥探memo" class="headerlink" title="窥探memo"></a>窥探memo</h4><p>既然memo和PureComponent作用类似，那么其原理应该也是和PureComponent思想类似</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// packages/react/src/memo.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span><span class="token constant">REACT_MEMO_TYPE</span><span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'shared/ReactSymbols'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> isValidElementType <span class="token keyword">from</span> <span class="token string">'shared/isValidElementType'</span><span class="token punctuation">;</span>

<span class="token comment">// 这里是可以传入两个参数的，如果没有传入第二个参数呢？</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> memo<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span><span class="token punctuation">(</span>
  type<span class="token operator">:</span> React$ElementType<span class="token punctuation">,</span>
  compare<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">oldProps<span class="token operator">:</span> Props<span class="token punctuation">,</span> newProps<span class="token operator">:</span> Props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> boolean<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token operator">:</span> <span class="token constant">REACT_MEMO_TYPE</span><span class="token punctuation">,</span>
    type<span class="token punctuation">,</span>
    compare<span class="token operator">:</span> compare <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token operator">:</span> compare<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>那么源码已经用<code>compare = compare !== null ? compare : shallowEqual;</code>帮助我们做了判断，意思就是如果我们传入了自己编写的compare函数，那么就用这个函数，否则它帮我们调用shallowEqual函数。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">updateMemoComponent</span><span class="token punctuation">(</span>
  <span class="token parameter">current<span class="token operator">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  workInProgress<span class="token operator">:</span> Fiber<span class="token punctuation">,</span>
  Component<span class="token operator">:</span> any<span class="token punctuation">,</span>
  nextProps<span class="token operator">:</span> any<span class="token punctuation">,</span>
  updateExpirationTime<span class="token punctuation">,</span>
  renderExpirationTime<span class="token operator">:</span> ExpirationTime<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> Fiber <span class="token punctuation">{</span>
  
  <span class="token keyword">let</span> currentChild <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>current<span class="token punctuation">.</span>child<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> Fiber<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// This is always exactly one child</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>updateExpirationTime <span class="token operator">&lt;</span> renderExpirationTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevProps <span class="token operator">=</span> currentChild<span class="token punctuation">.</span>memoizedProps<span class="token punctuation">;</span>
    <span class="token keyword">let</span> compare <span class="token operator">=</span> Component<span class="token punctuation">.</span>compare<span class="token punctuation">;</span>
    compare <span class="token operator">=</span> compare <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> compare <span class="token operator">:</span> shallowEqual<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>ref <span class="token operator">===</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>
        current<span class="token punctuation">,</span>
        workInProgress<span class="token punctuation">,</span>
        renderExpirationTime<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo：为next主题添加评论系统</title>
    <url>/2022/02/11/hexo-%E4%B8%BAnext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="为hexo的next主题添加评论系统，就能在评论区和网友激情对线了-doge"><a href="#为hexo的next主题添加评论系统，就能在评论区和网友激情对线了-doge" class="headerlink" title="为hexo的next主题添加评论系统，就能在评论区和网友激情对线了[doge]"></a>为hexo的next主题添加评论系统，就能在评论区和网友激情对线了[doge]</h3><p>早就想为自己的博客添加一个评论系统了，能在评论区发表自己的所思所得，还能和网友激情对线，想想都刺激。</p>
<p>还要清楚的是，Valine 评论系统在 Next 主题高版本 (7.+) 以上已没有支持，且 Valine 已经很久没有更新维护了。不过，有大佬在 Valine 的基础之上开发了 <a href="https://waline.js.org/">Waline</a> 。还有Gitment最新版next也不支持了。</p>
<p>这次，我们添加的是能够快速上手安装，配置更加人性化且带后端的 <a href="https://waline.js.org/">Waline</a> 评论系统</p>
<span id="more"></span>

<h4 id="1-配置数据库"><a href="#1-配置数据库" class="headerlink" title="1.配置数据库"></a>1.配置数据库</h4><p>我们需要注册一个 <a href="https://console.leancloud.app/register">Leancloud 国际版 </a>的账号，注意，一定要是 <strong>国际版</strong>，国内版需要绑定备案的域名，比较麻烦。具体可以在注册时的左上角看到：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9fwq8jjqj32p90u0wi2.jpg" style="zoom: 15%;">

<p>注册完成后，登录，然后我们找到<code>创建应用</code><br>在这里填写你的应用名称,名称可以自己定义，然后，下面选择<code>开发版</code> 点击<code>创建</code>。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9gaaylmmj31310u0tb4.jpg" style="zoom:25%;">

<p>然后点击设置，进入应用凭证页面，取得我们 <code>AppKey</code> 、<code>App id</code> 、以及 <code>MasterKey</code> ：</p>
<p>数据库配置完毕，接下来安装服务端。</p>
<h4 id="2-安装服务端"><a href="#2-安装服务端" class="headerlink" title="2.安装服务端"></a>2.安装服务端</h4><p><code>Waline</code> 支持多种服务端，这里我们使用第一种方式，即在 <code>Vercl</code> 上安装服务端。</p>
<p><a href="https://vercel.com/import/project?template=https://github.com/walinejs/waline/tree/main/example"><img src="https://vercel.com/button" alt="Vercel"></a></p>
<p>点击上方按钮，跳转至 Vercel 进行 Server 端部署。</p>
<p>如果你未登录的话，Vercel 会让你注册或登录，请使用 GitHub 账户进行快捷登录。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9gidu3i3j310c0u0mz2.jpg" style="zoom:25%;">

<p><code>GIT POST</code>那里绑定你的<code>github</code>账号，第二栏输入一个你喜欢的 Vercel 项目名称并点击 <code>Create</code> 继续，等待一小会时间</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9go73rbij314z0u0q5i.jpg" style="zoom:25%;">

<p>创建成功还会有烟花，嗯，不错</p>
<img src="/Users/onlybei/Library/Application Support/typora-user-images/image-20220211123356740.png" alt="image-20220211123356740" style="zoom:10%;">

<p>点击 <code>Go to Dashboard</code>，点击顶部的 <code>Settings</code> - <code>Environment Variables</code> 进入环境变量配置页，并配置三个环境变量<code>LEAN_ID</code>, <code>LEAN_KEY</code> 和 <code>LEAN_MASTER_KEY</code> 。它们的值分别对应上一步在 LeanCloud 中获得的 <code>APP ID</code>, <code>APP KEY</code>, <code>Master Key</code>。</p>
<img src="/Users/onlybei/Library/Application Support/typora-user-images/image-20220211124013867.png" alt="image-20220211124013867" style="zoom:20%;">

<blockquote>
<p>提示</p>
<p>如果你使用 LeanCloud 国内版，请额外配置 <code>LEAN_SERVER</code> 环境变量，值为你绑定好的域名。</p>
</blockquote>
<p>环境变量配置完成之后点击顶部的 <code>Deployments</code> 点击顶部最新的一次部署右侧的 <code>Redeploy</code> 按钮进行重新部署。该步骤是为了让刚才设置的环境变量生效。</p>
<p>此时会跳转到 <code>Overview</code> 界面开始部署，等待片刻后 <code>STATUS</code> 会变成 <code>Ready</code>。此时请点击 <code>Visit</code> ，即可跳转到部署好的网站地址，此地址即为你的服务端地址。</p>
<h4 id="3-在Hexo-Next主题中配置"><a href="#3-在Hexo-Next主题中配置" class="headerlink" title="3. 在Hexo Next主题中配置"></a>3. 在Hexo Next主题中配置</h4><p>由于 Next 主题中并不自带 <code>Waline</code> 的评论配置，我们需要安装官方提供的插件。在 <code>Hexo</code> 根目录执行：</p>
<pre class="language-none"><code class="language-none">npm install @waline/hexo-next</code></pre>

<p>找到 Next 的主题配置文件，在最后加上，记得修改servarURL</p>
<pre class="language-none"><code class="language-none"># Waline
# For more information: https://waline.js.org, https://github.com/walinejs/waline
waline:
  enable: true #是否开启
  serverURL: waline-server-pearl.vercel.app # Waline #服务端地址，我们这里就是上面部署的 Vercel 地址
  placeholder: 请文明评论呀 # #评论框的默认文字
  avatar: mm # 头像风格
  meta: [nick, mail, link] # 自定义评论框上面的三个输入框的内容
  pageSize: 10 # 评论数量多少时显示分页
  lang: zh-cn # 语言, 可选值: en, zh-cn
  # Warning: 不要同时启用 `waline.visitor` 以及 `leancloud_visitors`.
  visitor: false # 文章阅读统计
  comment_count: true # 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示
  requiredFields: [] # 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]
  libUrl: # Set custom library cdn url</code></pre>

<p>重新部署 <code>Hexo</code> ，就可以看到结果了。</p>
<h4 id="4-登录管理端"><a href="#4-登录管理端" class="headerlink" title="4. 登录管理端"></a>4. 登录管理端</h4><p>由于 <code>Waline</code> 有服务端，支持评论管理。我们需要注册一个账号作为管理员。</p>
<p>找到评论框，点击 <code>登录</code> 按钮，会弹出一个窗口，找到用户注册，默认第一个注册的用户为管理员，所以部署好一定要记得及时注册。注册好了之后，登录之后即可进入评论管理的后台，可以对评论进行管理。</p>
<h4 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h4><h5 id="5-1-自定义头像"><a href="#5-1-自定义头像" class="headerlink" title="5.1 自定义头像"></a>5.1 自定义头像</h5><p>参考：<a href="https://waline.js.org/guide/client/avatar.html">头像配置 | Waline</a></p>
<blockquote>
<p> 注意：官方头像配置教程已过时，需要在服务端进行设置</p>
<p>已过时</p>
<p>建议配合最新版本的服务端，通过服务端的 <code>AVATAR_PROXY</code> 配置。</p>
</blockquote>
<p>在服务器设置中添加<code>AVATAR_PROXY</code>和<code>GRAVATAR_STR</code>设置，记得value要添加上默认的值，然后注册 <a href="https://www.libravatar.org/">Libravatar</a>账号，可以上传自己的喜欢的头像。</p>
<h5 id="5-2-参考"><a href="#5-2-参考" class="headerlink" title="5.2 参考"></a>5.2 参考</h5><p><a href="https://waline.js.org/guide/get-started.html">快速入门 ｜ Waline</a></p>
<p><a href="https://waline.js.org/reference/server.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">服务器配置 | Waline</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo：使用matery主题对博客进行美化</title>
    <url>/2022/02/16/hexo-%E4%BD%BF%E7%94%A8matery%E4%B8%BB%E9%A2%98%E5%AF%B9%E5%8D%9A%E5%AE%A2%E8%BF%9B%E8%A1%8C%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h1 id="使用-matery-主题搭建很好看的博客页面"><a href="#使用-matery-主题搭建很好看的博客页面" class="headerlink" title="使用 matery 主题搭建很好看的博客页面"></a>使用 <code>matery</code> 主题搭建很好看的博客页面</h1><p>因为最近看到一位腾讯大佬 <a href="https://yangchaoyi.vip/">一百个Chocolate</a> 的个人博客，使用的也是 <code>matery</code> 主题，而且用了 <a href="https://mazhuang.org/wiki/chinese-copywriting-guidelines/">中文文案排版指北 (简体中文版)</a>  对博客文章进行排版，第一眼感觉非常惊艳，这样的博客看起来很舒服，所以自己也想向大佬看齐。</p>
<p>一下如无特别说明，以下配置文件都是 <code>matery</code> 主题下的 <code>_config.yml</code> </p>
<span id="more"></span>

<h2 id="下载（最好下载master分支最新稳定版的代码）"><a href="#下载（最好下载master分支最新稳定版的代码）" class="headerlink" title="下载（最好下载master分支最新稳定版的代码）"></a>下载（最好下载master分支最新稳定版的代码）</h2><p>本主题<strong>推荐你使用 Hexo 5.0.0 及以上的版本</strong>。如果，你已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了，建议你将 Hexo 升级到最新稳定的版本。</p>
<p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。（用这种方式下载的文件夹名字是 <code>hexo-theme-matery-master</code>，需要改成 <code>hexo-theme-matery</code> 再复制到 Hexo 的 <code>themes</code> 文件夹中）</p>
<p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>git clone</code> 命令来下载:</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p>
<h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul>
<li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li>
<li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li>
<li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li>
</ul>
<h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "categories"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: categories
date: 2018-09-30 17:25:30
type: "categories"
layout: "categories"
---</code></pre>



<h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "tags"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: tags
date: 2018-09-30 18:23:38
type: "tags"
layout: "tags"
---</code></pre>



<h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "about"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: about
date: 2018-09-30 17:25:30
type: "about"
layout: "about"
---</code></pre>



<h3 id="新建留言板-contact-页（可选的）"><a href="#新建留言板-contact-页（可选的）" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h3><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "contact"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: contact
date: 2018-09-30 17:25:30
type: "contact"
layout: "contact"
---</code></pre>

<blockquote>
<p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p>
</blockquote>
<h3 id="新建友情链接-friends-页（可选的）"><a href="#新建友情链接-friends-页（可选的）" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">hexo new page "friends"</code></pre>

<p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">---
title: friends
date: 2018-12-12 21:25:30
type: "friends"
layout: "friends"
---</code></pre>

<p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p>
<pre class="language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>
    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>
    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>
    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>
    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>
    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>
    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>
    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>
    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>
    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>
    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>
    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre>



<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p>
<p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>{</code> 和 <code>}</code> 的转义字符。</p>
<p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">highlight</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">auto_detect</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span>
  <span class="token key atrule">wrap</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">hljs</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">prismjs</span><span class="token punctuation">:</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">preprocess</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">line_number</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">tab_replace</span><span class="token punctuation">:</span> <span class="token string">''</span></code></pre>

<p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p>
<h3 id="中文链接转拼音（建议安装，否则底部的文章链接很乱）"><a href="#中文链接转拼音（建议安装，否则底部的文章链接很乱）" class="headerlink" title="中文链接转拼音（建议安装，否则底部的文章链接很乱）"></a>中文链接转拼音（建议安装，否则底部的文章链接很乱）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p>
<p>安装命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">npm i hexo-permalink-pinyin --save</code></pre>

<p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">permalink_pinyin</span><span class="token punctuation">:</span>

  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">separator</span><span class="token punctuation">:</span> <span class="token string">'-'</span> <span class="token comment"># default: '-'</span>
</code></pre>

<p>之后再将 Hexo 根目录下的 <code>_config.yml</code> 文件下的 url 改为自己的站点首地址</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># URL</span>
<span class="token comment">## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'</span>
<span class="token key atrule">url</span><span class="token punctuation">:</span> https<span class="token punctuation">:</span>//danonlylane.github.io <span class="token comment"># default: http://example.com</span>
<span class="token key atrule">permalink</span><span class="token punctuation">:</span> <span class="token punctuation">:</span>year/<span class="token punctuation">:</span>month/<span class="token punctuation">:</span>day/<span class="token punctuation">:</span>title/
<span class="token key atrule">permalink_defaults</span><span class="token punctuation">:</span>
<span class="token key atrule">pretty_urls</span><span class="token punctuation">:</span>
  <span class="token key atrule">trailing_index</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># Set to false to remove trailing 'index.html' from permalinks</span>
  <span class="token key atrule">trailing_html</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># Set to false to remove trailing '.html' from permalinks</span></code></pre>

<blockquote>
<p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p>
</blockquote>
<h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p>
<p>安装命令如下：</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">npm i --save hexo-wordcount</code></pre>

<p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">postInfo</span><span class="token punctuation">:</span>
  <span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
  <span class="token key atrule">update</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
  <span class="token key atrule">wordCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置文章字数统计为 true.</span>
  <span class="token key atrule">totalCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 设置站点文章总字数统计为 true.</span>
  <span class="token key atrule">min2read</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读时长.</span>
  <span class="token key atrule">readCount</span><span class="token punctuation">:</span> <span class="token boolean important">false</span> <span class="token comment"># 阅读次数.</span></code></pre>



<h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p>
<pre class="language-none"><code class="language-none">npm install hexo-filter-github-emojis --save</code></pre>

<p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p>
<pre class="language-none"><code class="language-none">githubEmojis:
  enable: true
  className: github-emoji
  inject: true
  styles:
  customEmojis:</code></pre>

<p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo：next主题美化进阶设置</title>
    <url>/2022/01/11/hexo%E4%B9%8Bnext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    <content><![CDATA[<h2 id="hexo进阶教程"><a href="#hexo进阶教程" class="headerlink" title="hexo进阶教程"></a>hexo进阶教程</h2><p>[toc]</p>
<h3 id="Hexo博客-绑定个人域名"><a href="#Hexo博客-绑定个人域名" class="headerlink" title="Hexo博客-绑定个人域名"></a>Hexo博客-绑定个人域名</h3><ol>
<li><p>首先得有一个域名，在腾讯云阿里云购买都可以。</p>
</li>
<li><p>设置域名解析</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy926kk6t7j32l60ba76f.jpg" style="zoom: 25%;">

<span id="more"></span>

<ol start="3">
<li><p>设置CNAME</p>
</li>
<li><p>在 hexo 项目下的<code>source</code> 文件夹下面创建 CNAME 文件（没有后缀名的），Mac用户可以</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy9285o2ncj308e01ut8j.jpg" style="zoom:50%;">



<p>在里面写上购买的域名。</p>
</li>
<li><p>在 github 上面，打开 <a href="http://username.github.io/">username.github.io</a> 项目的（Settings）设置，然后在 <code>GitHub Pages</code>的 <code>Custom domain</code>设置里填上购买的域名。比如：</p>
</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy922se47aj31v60f0myl.jpg" style="zoom:23%;">



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy923cjs5hj313g0ag0tp.jpg" style="zoom:37%;">

<p>点击save就可以了。</p>
<h3 id="在每篇文章末尾统一添加“本文结束”标记"><a href="#在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="在每篇文章末尾统一添加“本文结束”标记"></a>在每篇文章末尾统一添加“本文结束”标记</h3><p><strong>实现效果图</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy90vctmacj30za03kgli.jpg"></p>
<p><strong>具体实现方法</strong></p>
<p>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.njk</code> 文件,并添加以下内容：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token operator">%</span> <span class="token keyword">if</span> not is_index <span class="token operator">%</span><span class="token punctuation">}</span>
        <span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token string">"text-align:center;color: #ccc;font-size:14px;"</span><span class="token operator">&gt;</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span> 本文结束 <span class="token operator">&lt;</span>i <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"fas fa-book-reader"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>i<span class="token operator">&gt;</span> 感谢阅读 <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span><span class="token operator">%</span> endif <span class="token operator">%</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span></code></pre>

<p>接着打开<code>\themes\next\layout\_macro\post.njk</code>文件，在<code>post-body</code> 之后， <code>post-footer</code> 之前添加如下圈住的代码：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
  {% if not is_index %}
  {% include 'passage-end-tag.njk' %}
  {% endif %}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span></code></pre>

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy90wy5kuhj31ip0u0wiw.jpg" style="zoom:33%;">

<p>然后打开主题配置文件（<code>_config.yml</code>),在末尾添加：</p>
<pre class="language-none"><code class="language-none"># 文章末尾添加“本文结束”标记
passage_end_tag:
  enabled: true</code></pre>

<p>完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。</p>
<h3 id="代码复制和设置Mac风格"><a href="#代码复制和设置Mac风格" class="headerlink" title="代码复制和设置Mac风格"></a>代码复制和设置Mac风格</h3><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">copy_button</span><span class="token punctuation">:</span> <span class="token comment"># 复制代码按钮</span>
  <span class="token key atrule">enable</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#原始false</span>
  <span class="token key atrule">show_result</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment">#原始true</span>
  <span class="token comment"># Available values: default | flat | mac</span>
  <span class="token key atrule">style</span><span class="token punctuation">:</span> mac <span class="token comment">#代码更换mac风格</span></code></pre>



<h3 id="添加本站运行时间和底部信息排列优化"><a href="#添加本站运行时间和底部信息排列优化" class="headerlink" title="添加本站运行时间和底部信息排列优化"></a>添加本站运行时间和底部信息排列优化</h3><p>打开<code>themes/next/layout/_partials/footer.njk</code>文件，在末尾加入如下代码：</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token comment">&lt;!-- 网站运行时间的设置 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>timeDate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入天数...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>times<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入时分秒...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
    <span class="token keyword">var</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">createtime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> grt<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token string">"01/01/2022 00:00:00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此处修改你的建站时间或者网站上线时间</span>
        now<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        days <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> grt <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">24</span><span class="token punctuation">;</span> dnum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>days<span class="token punctuation">)</span><span class="token punctuation">;</span>
        hours <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> grt <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">/</span> <span class="token number">60</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> dnum<span class="token punctuation">)</span><span class="token punctuation">;</span> hnum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>hours<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>hnum<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>hnum <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token operator">+</span> hnum<span class="token punctuation">;</span><span class="token punctuation">}</span> minutes <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> grt <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">/</span><span class="token number">60</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> dnum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> hnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mnum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>minutes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>mnum<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>mnum <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token operator">+</span> mnum<span class="token punctuation">;</span><span class="token punctuation">}</span>
        seconds <span class="token operator">=</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> grt <span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">24</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> dnum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> hnum<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> mnum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        snum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>snum<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>snum <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token operator">+</span> snum<span class="token punctuation">;</span><span class="token punctuation">}</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"timeDate"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">"本站已运行 "</span><span class="token operator">+</span>dnum<span class="token operator">+</span><span class="token string">" 天 "</span><span class="token punctuation">;</span>
        document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"times"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> hnum <span class="token operator">+</span> <span class="token string">" 小时 "</span> <span class="token operator">+</span> mnum <span class="token operator">+</span> <span class="token string">" 分 "</span> <span class="token operator">+</span> snum <span class="token operator">+</span> <span class="token string">" 秒"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token string">"createtime()"</span><span class="token punctuation">,</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>要是觉得时间有两行不好看的花，也可以将</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>timeDate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入天数...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>times<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入时分秒...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span></code></pre>

<p>改成以下代码</p>
<pre class="language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>timeDate<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入天数...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>times<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>载入时分秒...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span></code></pre>



<p>将访问人数和字数统计合并在同一行，用一个span标签包裹起来,在<code>themes/next/layout/_partials/footer.njk</code>这个文件中，找到<code>class="wordcount"</code>，将其标签从div改成span。<code>class="busuanzi-count"</code>这个div也同样改成span，然后再用一个span将它们两个包裹起来。</p>
<p><strong><font color="red">这里博主有个不明白的地方，span本来就是行内元素，假设有两个span为a和b，怎么两个span就变成了两行，然后将a和b这两个span用一个span包裹起来，它们就可以在同一行上了，如果有知道的大佬可以告知本菜鸡一些，不胜感激！</font></strong></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始搭建hexo博客</title>
    <url>/2022/01/05/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="用Hexo-快速搭建属于自己的博客"><a href="#用Hexo-快速搭建属于自己的博客" class="headerlink" title="用Hexo 快速搭建属于自己的博客"></a>用Hexo 快速搭建属于自己的博客</h1><h3 id="环境准备（安装方法自行查阅网上资料）"><a href="#环境准备（安装方法自行查阅网上资料）" class="headerlink" title="环境准备（安装方法自行查阅网上资料）"></a>环境准备（安装方法自行查阅网上资料）</h3><ul>
<li>git</li>
<li>node</li>
<li>npm</li>
</ul>
<p>命令行里验证是否安装成功</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ git --version
git version 2.30.1 (Apple Git-130)

$ node --version
v16.4.2

$ npm -v
7.18.1</code></pre>

<span id="more"></span>

<h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p>如果第一次用git工具，记得配置一下SSH key，为部署本地博客到 Github 做准备。</p>
<p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">git config --global user.name "GitHub用户名"
git config --global user.email "注册GitHub邮箱地址"</code></pre>

<p>生成密钥SSK key</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">ssh-keygen -t rsa -C '上面的邮箱地址'</code></pre>

<p>输入上面的命令之后，按下三次回车，即可生成ssh key。<code>.ssh</code>目录下有两个文件，<code>id_rsa</code>和<code>id_rsa.pub</code>，这两个就是ssh key的密钥对，<code>id_rsa</code>是私钥，<code>id_rsa.pub</code>是公钥</p>
<p>cat获取你的ssh</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">cat ~/.ssh/id_rsa.pub</code></pre>

<p>复制输出内容</p>
<p>登录github，settings -&gt; SSH and GPG keys -&gt; New SSH key</p>
<p>Title随便写</p>
<p>Key填写刚才复制的内容，确认完成。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>执行命令</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ npm install -g hexo-cli	# -g 代表着全局安装</code></pre>

<p>完成后建立自己的个人博客</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ hexo init blogName
$ cd blogName
$ npm install</code></pre>

<h3 id="创建你的第一篇博文"><a href="#创建你的第一篇博文" class="headerlink" title="创建你的第一篇博文"></a>创建你的第一篇博文</h3><p>新建一篇博文：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ hexo new 'blogName'</code></pre>

<p>在 <code>/source/_posts</code>文件夹下找到你的博文，使用typora（推荐）打开并编辑。</p>
<p>保存后运行：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ hexo generate # 生成静态文件，可简写为 hexo g
$ hexo server # 启动服务器。默认情况下，访问网址为：http://localhost:4000/。可以简写为 hexo s</code></pre>

<p>此时已经可以在<code>public</code>文件夹下看到完整的静态文件。<br>在浏览器中输入<code>http://localhost:4000/</code>就可以看到预览效果了。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">// 如果写的文章太长的话，想要在Home页显示文章的前一小部分的话，可以在想要显示部分的后面加上&lt;!--more--&gt;，就可以实现文章折叠。</code></pre>

<p>以上是本地部署，下面讲博客部署到Github page上</p>
<h2 id="部署到Github-page"><a href="#部署到Github-page" class="headerlink" title="部署到Github page"></a>部署到Github page</h2><p>登录github，新建仓库，仓库名为<code>username.github.io</code>，<strong>注意：<code>username</code>应该是你github的用户名</strong></p>
<p>本地和github都完成之后，现在需要把这两者连接在一起</p>
<ol>
<li><p>修改被指</p>
<p>在项目根目录下的<code>_config.yml</code>修改配置参数（如果这里命令行显示连接不了GitHub，那就用仓库的ssh链接代替https链接，因为GitHub现在增强了安全性，用户名和密码登录不能保证安全性）</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"># Deployment
## Docs: https://hexo.io/docs/one-command-deployment
deploy:
  type: git
  repo:
    github: https://github.com/你的用户名/你的用户名.github.io.git
  branch: master</code></pre></li>
<li><p>安装部署插件</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">npm install hexo-deployer-git --save</code></pre></li>
<li><p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</p>
</li>
<li><p>部署上线</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">hexo g -d</code></pre></li>
</ol>
<p>用浏览器输入，https://你的用户名.github.io，就可以看到你的博客了。</p>
<h2 id="配置主题及语言"><a href="#配置主题及语言" class="headerlink" title="配置主题及语言"></a>配置主题及语言</h2><p>个人用的是<a href="https://theme-next.js.org/">NexT主题</a></p>
<p>进入项目根目录，下载NexT主题</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">$ git clone https://github.com/next-theme/hexo-theme-next themes/next</code></pre>

<p>修改<strong>项目根目录</strong>下的<code>_config.yml</code>的配置</p>
<p>注意：<code>_config.yml</code>配置文件有两个，一个在项目根目录，一个在<code>/themes/next</code>中，大部分配置在主题里面改。</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">## Themes: https://hexo.io/themes/
theme: next</code></pre>

<p>修改语言：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># Site</span>
<span class="token key atrule">title</span><span class="token punctuation">:</span> 博客的名字
<span class="token key atrule">subtitle</span><span class="token punctuation">:</span> <span class="token string">''</span>
<span class="token key atrule">description</span><span class="token punctuation">:</span> <span class="token string">''</span>
<span class="token key atrule">keywords</span><span class="token punctuation">:</span>
<span class="token key atrule">author</span><span class="token punctuation">:</span> 
<span class="token key atrule">language</span><span class="token punctuation">:</span> zh<span class="token punctuation">-</span>CN
<span class="token key atrule">timezone</span><span class="token punctuation">:</span> <span class="token string">''</span></code></pre>



<h2 id="NexT配置"><a href="#NexT配置" class="headerlink" title="NexT配置"></a>NexT配置</h2><p>以下均在<code>/blogName/themes/next/_config.yml</code>文件中修改</p>
<blockquote>
<p>修改主题的时候，可以使用hexo s现在本地预览，然后再部署上线。部署上线的效果可能有几分钟的延迟，耐心等待就好</p>
</blockquote>
<h3 id="修改NexT风格"><a href="#修改NexT风格" class="headerlink" title="修改NexT风格"></a>修改NexT风格</h3><p>NexT主题有四个风格，想要的取消注释</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"># Schemes
#scheme: Muse
scheme: Mist
#scheme: Pisces
#scheme: Gemini</code></pre>

<h3 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h3><pre class="language-shell" data-language="shell"><code class="language-shell"># Dark Mode
darkmode: true</code></pre>

<h3 id="改变网页标签icon"><a href="#改变网页标签icon" class="headerlink" title="改变网页标签icon"></a>改变网页标签icon</h3><p>把你想要用的图片放在<code>/themes/next/source/images</code>中</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">favicon:
  small: /images/图片名字
  medium: /images/图片名字</code></pre>

<h3 id="增加或删除博客页面功能"><a href="#增加或删除博客页面功能" class="headerlink" title="增加或删除博客页面功能"></a>增加或删除博客页面功能</h3><p>想用的取消注释，</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">menu:
  home: / || fa fa-home
  about: /about/ || fa fa-user
  tags: /tags/ || fa fa-tags
  categories: /categories/ || fa fa-th
  archives: /archives/ || fa fa-archive
  #schedule: /schedule/ || fa fa-calendar
  #sitemap: /sitemap.xml || fa fa-sitemap
  #commonweal: /404/ || fa fa-heartbeat</code></pre>

<h4 id="添加标签页面"><a href="#添加标签页面" class="headerlink" title="添加标签页面"></a>添加标签页面</h4><p>在项目根目录</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">hexo new page tags
cd ./source/tags</code></pre>

<p>打开<code>index.md</code>文件，增加一个<code>type</code>字段</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">---
title: tags
type: "tags"
comments: false
date: 2022-01-04 13:29:07
---</code></pre>

<h4 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h4><p>在项目根目录</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">hexo new page categories
cd ./source/categories</code></pre>

<p>打开<code>index.md</code>文件，增加一个<code>type</code>字段</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">---
title: categories
type: "categories"
date: 2022-01-04 13:55:58
---</code></pre>

<h4 id="添加about页面"><a href="#添加about页面" class="headerlink" title="添加about页面"></a>添加about页面</h4><p>在项目根目录</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">hexo new page about
cd ./source/about</code></pre>

<p>打开<code>index.md</code>文件，可以在里面写自己的个人介绍。</p>
<h3 id="调整侧边栏位置"><a href="#调整侧边栏位置" class="headerlink" title="调整侧边栏位置"></a>调整侧边栏位置</h3><pre class="language-shell" data-language="shell"><code class="language-shell">sidebar:
  # Sidebar Position.
  #position: left
  position: right</code></pre>

<h3 id="添加侧边栏头像图片"><a href="#添加侧边栏头像图片" class="headerlink" title="添加侧边栏头像图片"></a>添加侧边栏头像图片</h3><pre class="language-sh" data-language="sh"><code class="language-sh"># Sidebar Avatar
avatar:
  # 把要展示的图片放在images中
  url: /images/avatar.jpg
  # If true, the avatar will be displayed in circle.
  rounded: false
  # If true, the avatar will be rotated with the cursor.
  rotated: false</code></pre>

<h3 id="启用不蒜子统计"><a href="#启用不蒜子统计" class="headerlink" title="启用不蒜子统计"></a>启用不蒜子统计</h3><p>不蒜子是用于统计文章的阅读次数</p>
<pre class="language-sh" data-language="sh"><code class="language-sh">busuanzi_count:
  enable: true
  total_visitors: true
  total_visitors_icon: fa fa-user
  total_views: true
  total_views_icon: fa fa-eye
  post_views: true
  post_views_icon: fa fa-eye</code></pre>

<h3 id="添加网页加载进度条"><a href="#添加网页加载进度条" class="headerlink" title="添加网页加载进度条"></a>添加网页加载进度条</h3><pre class="language-sh" data-language="sh"><code class="language-sh">cd themes/next
git clone https://github.com/theme-next/theme-next-pace source/lib/pace</code></pre>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">pace:
  enable: true
  theme: minimal</code></pre>

<h3 id="添加页面顶部阅读进度条"><a href="#添加页面顶部阅读进度条" class="headerlink" title="添加页面顶部阅读进度条"></a>添加页面顶部阅读进度条</h3><pre class="language-shell" data-language="shell"><code class="language-shell">cd themes/next
git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress</code></pre>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">reading_progress:
  enable: true
  position: top               # 进度条的位置：top | bottom
  color: "#37c6c0"            # 进度条的颜色
  height: 3px                 # 进度条的大小</code></pre>

<h3 id="显示侧栏底部阅读进度百分比"><a href="#显示侧栏底部阅读进度百分比" class="headerlink" title="显示侧栏底部阅读进度百分比"></a>显示侧栏底部阅读进度百分比</h3><p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">back2top:
  enable: true
  sidebar: false
  scrollpercent: true</code></pre>

<h3 id="字数与阅读时长统计插件"><a href="#字数与阅读时长统计插件" class="headerlink" title="字数与阅读时长统计插件"></a>字数与阅读时长统计插件</h3><pre class="language-shell" data-language="shell"><code class="language-shell">cd 项目根目录
npm install eslint --save
npm install hexo-symbols-count-time --save</code></pre>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">symbols_count_time:
  time: true                   # 文章阅读时长
  symbols: true                # 文章字数统计
  total_time: true             # 站点总阅读时长
  total_symbols: true          # 站点总字数统计
  exclude_codeblock: true      # 排除代码字数统计</code></pre>



<h3 id="添加search栏"><a href="#添加search栏" class="headerlink" title="添加search栏"></a>添加search栏</h3><pre class="language-shell" data-language="shell"><code class="language-shell">cd 项目根目录
npm install hexo-generator-searchdb --save</code></pre>

<p>修改配置文件 <code>themes/next/_config.yml</code></p>
<pre class="language-shell" data-language="shell"><code class="language-shell">local_search:
  enable: true

// 在local_search:下面添加，注意search和local_search是在同一缩进上
search:
  path: search.xml
  field: post
  format: html
  limit: 10000</code></pre>



<h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><ul>
<li><p><code>hexo init [folder]</code></p>
<ul>
<li>Hexo 默认在目前的文件夹建立网站。</li>
<li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li>
<li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li>
</ul>
</li>
<li><pre><code>hexo new '文章标题'
</code></pre>
<ul>
<li>新建文件，写的时候自己用typora打开写。可简写为<code>hexo n '文章标题'</code></li>
</ul>
</li>
<li><p><code>hexo clean</code></p>
<ul>
<li>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</li>
<li>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</li>
</ul>
</li>
<li><p><code>hexo generate</code></p>
<ul>
<li>生成静态文件，可简写为<code>hexo g</code></li>
</ul>
</li>
<li><p><code>hexo server</code></p>
<ul>
<li>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。可以简写为 hexo s</li>
</ul>
</li>
<li><p><code>hexo deploy</code></p>
<ul>
<li>部署网站，可简写为<code>hexo d</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>手写 Promise/A+ 规范</title>
    <url>/2022/03/20/%E6%89%8B%E5%86%99-Promise-A-%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h3 id="手写-Promise-A-规范"><a href="#手写-Promise-A-规范" class="headerlink" title="手写 Promise/A+ 规范"></a>手写 Promise/A+ 规范</h3><p>所谓 <code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>想要写出 Promise/A+ 规范的 promsie，首先要熟读 Promise/A+ 的<a href="https://promisesaplus.com/">英文规范文档</a>，建议先看几遍英文文档，了解一下规则。还有这篇中文文档翻译的也很到位 <a href="https://zhuanlan.zhihu.com/p/143204897">中文规范文档</a></p>
<span id="more"></span>

<p>状态：</p>
<p>Promise存在三个状态（state）pending、fulfilled、rejected</p>
<p>pending（等待态）为初始态，并可以转化为 fulfilled（成功态）和 rejected（失败态），一旦确定就不可以改变</p>
<p>如果 executor 函数报错，则直接执行 reject(reason);</p>
<p>then 方法：</p>
<p>promise的 <code>then</code> 方法接收两个可选参数，表示该 <code>promise</code> 状态改变时的回调</p>
<p><code>then</code>方法返回一个<code>promise</code>，<code>then</code> 方法可以被同一个 promise 调用多次</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">promise2 <span class="token operator">=</span> promise1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span>onRejected<span class="token punctuation">)</span></code></pre>



<p>resolvePromise 方法：</p>
<p>这个方法是用来处理 then 方法中的 <code>onFulfilled</code> 和 <code>onRejected</code> 这两个参数，当这两个参数是函数的时候，处理它们的返回值</p>
<p>下面就根据日常对 promise 的使用规则出发去写一下 Promise/A+ 规范吧。</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">PENDING</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>


        <span class="token comment">// 同一个 promsie 实例可能会被多次调用</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token keyword">let</span> <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
              
                <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">let</span> <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>

                <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 解决 onFufilled，onRejected 没有传值的问题</span>
        onFulfilled <span class="token operator">=</span> <span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function-variable function">onFulfilled</span> <span class="token operator">:</span> <span class="token parameter">v</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">;</span>
        <span class="token comment">// 因为错误的值要让后面访问到，所以这里也要抛出错误，不然会在之后 then 的 resolve 中捕获</span>
        onRejected <span class="token operator">=</span> <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function-variable function">onRejected</span> <span class="token operator">:</span> <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> err <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment">// 每次调用 then 都返回一个新的 promise</span>
        <span class="token keyword">let</span> promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//Promise/A+ 2.2.4 --- setTimeout</span>
                <span class="token comment">// 在执行上下文栈中只包含平台代码之前，onFulfilled或onRejected一定不能被调用 [3.1]</span>
                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// x可能是一个proimise</span>
                        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                            <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>

                <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{</span>
                            <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment">// Promise/A+ 2.2.7. then必须返回一个promise [3.3]</span>
        <span class="token keyword">return</span> promise2<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">resolvePromise</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'err'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Promise/A+ 2.3.3.3.3 只能调用一次</span>
    <span class="token keyword">let</span> called<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，防止 Object.defineProperty 中设置的 get 只能访问一次的情况  Promise/A+ 2.3.3.3</span>
                <span class="token function">then</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>
                    <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 根据 promise 的状态决定是成功还是失败</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
                        called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token comment">// 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1</span>

                        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> value<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token punctuation">,</span>
                    <span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                        <span class="token comment">// 只要失败就失败 Promise/A+ 2.3.3.3.2</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
                        called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                        <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// Promise/A+ 2.3.3.2</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
            called <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>

<p>Promise 写完之后可以通过 promises-aplus-tests 这个包对我们写的代码进行测试，看是否符合 A+ 规范。不过测试前还得加一段代码：</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// promise.js</span>
<span class="token comment">// 这里是上面写的 Promise 全部代码</span>
Promise<span class="token punctuation">.</span>defer <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function-variable function">deferred</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dfd <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    dfd<span class="token punctuation">.</span>promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        dfd<span class="token punctuation">.</span>resolve <span class="token operator">=</span> resolve<span class="token punctuation">;</span>
        dfd<span class="token punctuation">.</span>reject <span class="token operator">=</span> reject<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> dfd<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Promise<span class="token punctuation">;</span></code></pre>

<p>全局安装：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">npm i promises-aplus-tests -g</code></pre>

<p>终端下执行验证命令：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">promises-aplus-tests promise.js</code></pre>



<p>结语：刚开始接触 promise 的时候，觉得这东西好抽象，但是用了段时间之后，感觉确实好用。作为一名有追求的程序员，怎么能不挑战一下 promise/A+ 呢！不能被它的规范很多吓到，其实它的规范也是我们平时使用的规则，从这个点出发去写，就不那么枯燥了嘿嘿</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>断点看源码系列：探究React-router内部工作流程</title>
    <url>/2022/03/03/%E6%96%AD%E7%82%B9%E7%9C%8B%E6%BA%90%E7%A0%81%EF%BC%9A%E6%8E%A2%E7%A9%B6react-router%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="从实际出发搞清楚react-router内部原理"><a href="#从实际出发搞清楚react-router内部原理" class="headerlink" title="从实际出发搞清楚react-router内部原理"></a>从实际出发搞清楚react-router内部原理</h3><p>[toc]</p>
<p>前言：最近在看 <code>react-router</code> 的工作原理网上看了一圈文章，发现很多都是介绍了 <code>history</code> 库的原理和 <code>react-router</code> 里面的 <code>BrowserRouter</code> 组件、<code>Router</code> 组件等等，看了原理是大概知道了，但是它的内部是怎么样的一个工作流程还是一脸懵逼，又在找了一圈资料，看完还是觉得具体流程理不太清。想到平时在 js 代码的调试中可以打断点观察各个变量的情况以及程序的流程，<code>react</code> 程序那应该也可以这样调试。</p>
<p>随后写了一个小 demo 测试一下：</p>
<span id="more"></span>

<h4 id="准备文件："><a href="#准备文件：" class="headerlink" title="准备文件："></a>准备文件：</h4><p><code>App.js</code> 文件</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> PureComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Link<span class="token punctuation">,</span> Switch<span class="token punctuation">,</span> Route<span class="token punctuation">,</span> withRouter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span>

<span class="token comment">// 为了看 history 的源码而引入</span>
<span class="token keyword">import</span> history <span class="token keyword">from</span> <span class="token string">'history'</span>

<span class="token keyword">import</span> Home <span class="token keyword">from</span> <span class="token string">'./pages/home'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> Profile <span class="token keyword">from</span> <span class="token string">'./pages/profile'</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">PureComponent</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>Link className<span class="token operator">=</span><span class="token string">'mylink'</span> to<span class="token operator">=</span><span class="token string">"/"</span><span class="token operator">&gt;</span>首页<span class="token operator">&lt;</span><span class="token operator">/</span>Link<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>Link className<span class="token operator">=</span><span class="token string">'mylink'</span> to<span class="token operator">=</span><span class="token string">"/profile"</span><span class="token operator">&gt;</span>我的<span class="token operator">&lt;</span><span class="token operator">/</span>Link<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">jumpToProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>测试<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>

                <span class="token operator">&lt;</span>Switch<span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>Route exact path<span class="token operator">=</span><span class="token string">"/"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Home<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
                    <span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">"/profile"</span> component<span class="token operator">=</span><span class="token punctuation">{</span>Profile<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span><span class="token operator">/</span>Switch<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">jumpToProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"/profile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withRouter</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p><code>index.js</code> 文件</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> ReactDOM <span class="token keyword">from</span> <span class="token string">'react-dom'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App'</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span>
  BrowserRouter<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-router-dom'</span><span class="token punctuation">;</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>BrowserRouter<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>BrowserRouter<span class="token operator">&gt;</span>
  <span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'root'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p><code>profile.js</code> 组件， Home 一样</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> PureComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Profile</span> <span class="token keyword">extends</span> <span class="token class-name">PureComponent</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h2<span class="token operator">&gt;</span>Profile<span class="token operator">&lt;</span><span class="token operator">/</span>h2<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<p>到这里就可以开始了我们的流程探究了，在 <code>App.js</code> 文件的 <code>jumpToProduct</code> 里面的一行代码打上断点。</p>
<p>打断点的具体方式是：将 demo 跑起来 -&gt; 打开浏览器的控制台 -&gt; source -&gt; 具体文件 -&gt; 打上断点</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">jumpToProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"/profile"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>如图：</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzwst9j6j4j225y0n844l.jpg"></p>
<p>点击 <code>button</code> 按钮，进行单步调试。然后程序就跳到 <code>node_modules/history/cjs/history.js</code> 的 <code>push</code> 函数里面了。</p>
<p>这是为什么呢？因为 <code>Link</code> 组件里面判断了是用什么方法改变路径的。这里我们模拟的是 <code>push</code> 方法</p>
<h4 id="1-Link-里面的判断代码片段（以下源码均为节选）"><a href="#1-Link-里面的判断代码片段（以下源码均为节选）" class="headerlink" title="1. Link 里面的判断代码片段（以下源码均为节选）"></a>1. Link 里面的判断代码片段（以下源码均为节选）</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 1. Link 里面的判断代码片段</span>
<span class="token keyword">var</span> props <span class="token operator">=</span> <span class="token function">_extends</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> rest<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      href<span class="token operator">:</span> href<span class="token punctuation">,</span>
      <span class="token function-variable function">navigate</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">navigate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> location <span class="token operator">=</span> <span class="token function">resolveToLocation</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> context<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> isDuplicateNavigation <span class="token operator">=</span> history<span class="token punctuation">.</span><span class="token function">createPath</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>location<span class="token punctuation">)</span> <span class="token operator">===</span> history<span class="token punctuation">.</span><span class="token function">createPath</span><span class="token punctuation">(</span><span class="token function">normalizeToLocation</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">var</span> method <span class="token operator">=</span> replace <span class="token operator">||</span> isDuplicateNavigation <span class="token operator">?</span> history$<span class="token number">1.</span>replace <span class="token operator">:</span> history$<span class="token number">1.</span>push<span class="token punctuation">;</span>
        <span class="token function">method</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// React 15 compat</span></code></pre>

<h4 id="2-这里调用的是-history-下的-push-方法"><a href="#2-这里调用的是-history-下的-push-方法" class="headerlink" title="2. 这里调用的是 history 下的 push 方法"></a>2. 这里调用的是 <code>history</code> 下的 <code>push</code> 方法</h4><p><code>push</code> 方法里面创建一个新的 <code>location</code> 对象，然后通过 <code>globalHistory</code> 方法改变浏览器当前路由,最后通过<code>setState</code> 方法通知 <code>React-Router</code> 更新（这里会跳到 <code>ReactRefreshEntry.js</code> 这个文件），并传递当前的 <code>location</code> 对象</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">path<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> action <span class="token operator">=</span> <span class="token string">'PUSH'</span><span class="token punctuation">;</span>
  	<span class="token comment">/* 2. 创建location对象 */</span>
    <span class="token keyword">var</span> location <span class="token operator">=</span> <span class="token function">createLocation</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> state<span class="token punctuation">,</span> <span class="token function">createKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> history<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">/* 3. 确定是否能进行路由转换 */</span>
    transitionManager<span class="token punctuation">.</span><span class="token function">confirmTransitionTo</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> action<span class="token punctuation">,</span> getUserConfirmation<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">ok</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ok<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> href <span class="token operator">=</span> <span class="token function">createHref</span><span class="token punctuation">(</span>location<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">var</span> key <span class="token operator">=</span> location<span class="token punctuation">.</span>key<span class="token punctuation">,</span>
          state <span class="token operator">=</span> location<span class="token punctuation">.</span>state<span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>canUseHistory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 改变 url */</span>
        globalHistory<span class="token punctuation">.</span><span class="token function">pushState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
          key<span class="token operator">:</span> key<span class="token punctuation">,</span>
          state<span class="token operator">:</span> state
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> href<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>forceRefresh<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>href <span class="token operator">=</span> href<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment">/* 改变 react-router location对象, 创建更新环境 */</span>
          <span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
            action<span class="token operator">:</span> action<span class="token punctuation">,</span>
            location<span class="token operator">:</span> location
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>



<h4 id="3-history-下的-createTransitionManager-函数"><a href="#3-history-下的-createTransitionManager-函数" class="headerlink" title="3. history 下的 createTransitionManager 函数"></a>3. <code>history</code> 下的 <code>createTransitionManager</code> 函数</h4><p>作用是监听判断是否能进行路由转换 </p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/* 3. 确定是否能进行路由转换 */</span>
<span class="token keyword">function</span> <span class="token function">createTransitionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> prompt <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  
  <span class="token keyword">function</span> <span class="token function">confirmTransitionTo</span><span class="token punctuation">(</span><span class="token parameter">location<span class="token punctuation">,</span> action<span class="token punctuation">,</span> getUserConfirmation<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prompt <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">typeof</span> prompt <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">prompt</span><span class="token punctuation">(</span>location<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token operator">:</span> prompt<span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> getUserConfirmation <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">getUserConfirmation</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// Return false from a transition hook to cancel the transition.</span>
        <span class="token function">callback</span><span class="token punctuation">(</span>result <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">var</span> listeners <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token keyword">function</span> <span class="token function">appendListener</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> isActive <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token keyword">function</span> <span class="token function">listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isActive<span class="token punctuation">)</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    listeners<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      isActive <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      listeners <span class="token operator">=</span> listeners<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> item <span class="token operator">!==</span> listener<span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">notifyListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    listeners<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">listener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">listener</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token number">0</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>



<h4 id="4-history-中-createBrowserHistory-props-函数的-setState"><a href="#4-history-中-createBrowserHistory-props-函数的-setState" class="headerlink" title="4. history  中 createBrowserHistory(props) 函数的 setState"></a>4. <code>history</code>  中 <code>createBrowserHistory(props)</code> 函数的 <code>setState</code></h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token comment">/* 通知listener更新，这里通知到 react-router了 */</span>
<span class="token keyword">const</span> <span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">nextState</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 合并信息 */</span>
    Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>history<span class="token punctuation">,</span> nextState<span class="token punctuation">)</span>
    history<span class="token punctuation">.</span>length <span class="token operator">=</span> globalHistory<span class="token punctuation">.</span>length
    <span class="token comment">/* 通知每一个listens路由已经发生变化 */</span>
    transitionManager<span class="token punctuation">.</span><span class="token function">notifyListeners</span><span class="token punctuation">(</span>
      history<span class="token punctuation">.</span>location<span class="token punctuation">,</span>
      history<span class="token punctuation">.</span>action
    <span class="token punctuation">)</span>
  <span class="token punctuation">}</span></code></pre>



<h4 id="5-路由匹配"><a href="#5-路由匹配" class="headerlink" title="5. 路由匹配"></a>5. 路由匹配</h4><pre class="language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token comment">/* 5. 监听并进行路由匹配 */</span>
<span class="token keyword">class</span> <span class="token class-name">Router</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">computeRootMatch</span><span class="token punctuation">(</span><span class="token parameter">pathname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> url<span class="token operator">:</span> <span class="token string">"/"</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> isExact<span class="token operator">:</span> pathname <span class="token operator">===</span> <span class="token string">"/"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>
      location<span class="token operator">:</span> props<span class="token punctuation">.</span>history<span class="token punctuation">.</span>location
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>_isMounted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingLocation <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>props<span class="token punctuation">.</span>staticContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>unlisten <span class="token operator">=</span> props<span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token parameter">location</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> location <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">this</span><span class="token punctuation">.</span>_pendingLocation <span class="token operator">=</span> location<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>路由转换的大致流程就是：</p>
<ol>
<li>模拟点击 <code>Link</code></li>
<li>调用 <code>history.push</code> 方法，通过 <code>history.pushState</code> 来改变当前 <code>url</code></li>
<li>接下来触发 <code>history</code> 下面的 <code>setState</code> 方法，产生新的 location 对象，</li>
<li>然后通知 <code>Router</code> 组件更新 <code>location</code></li>
<li>路由匹配组件中监听更新的消息，找出符合的组件，最后进行页面更新。</li>
</ol>
<p><strong>纸上得来终觉浅,绝知此事要躬行</strong></p>
<p>还得再多加油 多多 coding 多多看源码</p>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p><a href="https://juejin.cn/post/6886290490640039943#heading-13">「源码解析 」这一次彻底弄懂react-router路由原理</a></p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React React源码</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构：二叉树</title>
    <url>/2022/01/05/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="力扣刷题之二叉树总结"><a href="#力扣刷题之二叉树总结" class="headerlink" title="力扣刷题之二叉树总结"></a>力扣刷题之二叉树总结</h2><h4 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><p>难度简单727</p>
<p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
<span id="more"></span>

<p><strong>示例:</strong></p>
<pre class="language-none"><code class="language-none">输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]</code></pre>

<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<p><strong>图示：画出了几个关键的步骤</strong></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxlruvnf4gj30p72abn3n.jpg" style="zoom:67%;">

<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">postorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> st <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">let</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">||</span> st<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cur <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> cur<span class="token punctuation">.</span>right <span class="token operator">==</span> prev<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>
            cur <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>





<h4 id="剑指-Offer-55-I-二叉树的深度"><a href="#剑指-Offer-55-I-二叉树的深度" class="headerlink" title="剑指 Offer 55 - I. 二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></h4><p>难度：简单</p>
<p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">  3
 / \
9  20
  /  \
 15   7</code></pre>

<p>返回它的最大深度 3 。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>节点总数 &lt;= 10000</code></li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grr9clch10j310e08mwf5.jpg" style="zoom:50%;">



<pre class="language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */


//解法一：这个耗时有点长
//递归做法
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int max_depth=0;
        if(root==nullptr)return 0;
        if(root-&gt;right==nullptr&amp;&amp;root-&gt;left==nullptr)return 1;
        if(root-&gt;left!=nullptr)
        {
            max_depth=max(maxDepth(root-&gt;left),max_depth);
        }
        if(root-&gt;right!=nullptr)
        {
            max_depth=max(maxDepth(root-&gt;right),max_depth);
        }
        return max_depth+1;

    }
};

//解法二：耗时短
//递归做法
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==NULL)return 0;
        int nleft=maxDepth(root-&gt;left);
        int nright=maxDepth(root-&gt;right);
        if(nleft&gt;nright)
        {
            return nleft+1;
        }
        else
        return nright+1;
    }
};</code></pre>



<h4 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h4><p>难度简单525</p>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：root = [3,9,20,null,null,15,7]
输出：2</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="language-none"><code class="language-none">输入：root = [2,null,3,null,4,null,5,null,6]
输出：5</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */


class Solution {
public:
    int minDepth(TreeNode* root) {
        int min_depth=INT_MAX;
        if(root==nullptr)return 0;
        if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)
        {
            return 1;
        }
        if(root-&gt;left!=nullptr)
        {
            min_depth=min(minDepth(root-&gt;left),min_depth);
        }
        if(root-&gt;right!=nullptr)
        {
            min_depth=min(minDepth(root-&gt;right),min_depth);
        }
        return min_depth+1;

    }
};</code></pre>



<h4 id="112-路径总和：！非常重要的一道题，字节跳动常考"><a href="#112-路径总和：！非常重要的一道题，字节跳动常考" class="headerlink" title="112. 路径总和：！非常重要的一道题，字节跳动常考"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a>：！非常重要的一道题，字节跳动常考</h4><p>难度简单604收藏分享切换为英文接收动态反馈</p>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：root = [1,2,3], targetSum = 5
输出：false</code></pre>

<p><strong>示例 3：</strong></p>
<pre class="language-none"><code class="language-none">输入：root = [1,2], targetSum = 0
输出：false</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==nullptr)return false;
        if(root-&gt;left==nullptr&amp;&amp;root-&gt;right==nullptr)
        {
            return targetSum==root-&gt;val;
        }
        return hasPathSum(root-&gt;left,targetSum-root-&gt;val)||hasPathSum(root-&gt;right, targetSum-root-&gt;val);
    }
};</code></pre>

<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><p>难度简单891收藏分享切换为英文接收动态反馈</p>
<p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<pre class="language-none"><code class="language-none">     4
   /   \
  2     7
 / \   / \
1   3 6   9</code></pre>

<p>输出：</p>
<pre class="language-none"><code class="language-none">     4
   /   \
  7     2
 / \   / \
9   6 3   1</code></pre>



<pre class="language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root)return 0;
        TreeNode* temp=invertTree(root-&gt;left);
        root-&gt;left=invertTree(root-&gt;right);
        root-&gt;right=temp;
        return root;
    }
};

// 自己写的版本，代码还是不够简洁，对递归的理解还不能做到清晰
// class Solution {
// public:
//     TreeNode* invertTree(TreeNode* root) {
//         if(!root)return 0;
//         invertTree(root-&gt;left);
//         invertTree(root-&gt;right);
//         TreeNode* temp;
//         temp=root-&gt;left;
//         root-&gt;left=root-&gt;right;
//         root-&gt;right=temp;
//         return root;

//     }
// };</code></pre>



<h4 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h4><p>难度简单639收藏分享切换为英文接收动态反馈</p>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：p = [1,2,3], q = [1,2,3]
输出：true</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：p = [1,2], q = [1,null,2]
输出：false</code></pre>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：p = [1,2,1], q = [1,1,2]
输出：false</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li>两棵树上的节点数目都在范围 <code>[0, 100]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

 /* v1 没有考虑到遍历二叉树的时候，左右子树空和非空的情况在数组中是一样的。
class Solution {
public:
    vector&lt;int&gt; treep;
    vector&lt;int&gt; treeq;
    void orderp(TreeNode* p)
    {
        if(!p)return;
        orderp(p-&gt;left);
        treep.push_back(p-&gt;val);
        orderp(p-&gt;right);
    }
    void orderq(TreeNode* q)
    {
        if(!q)return;
        orderq(q-&gt;left);
        treeq.push_back(q-&gt;val);
        orderq(q-&gt;right);
    }
    bool isSameTree(TreeNode* p, TreeNode* q) {
        int lenp=treep.size(),lenq=treeq.size(),n=0;
        if(lenp!=lenq)return false;
        else if(n&lt;lenq){
        for(int i=0;i&lt;lenq;i++)
        {
            n++;
            if(treeq[i]!=treep[i])
            return false;
        }
        }
        return true; 
    }

};
*/

class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p==nullptr&amp;&amp;q==nullptr)return true;
        else if(p==nullptr||q==nullptr)return false;
        else if(p-&gt;val!=q-&gt;val)return false;
        else return(isSameTree(p-&gt;left, q-&gt;left)&amp;&amp;isSameTree(p-&gt;right, q-&gt;right));
    }

};</code></pre>



<h4 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h4><p>难度简单1417收藏分享切换为英文接收动态反馈</p>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>
<pre class="language-none"><code class="language-none">    1
   / \
  2   2
 / \ / \
3  4 4  3</code></pre>

<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>
<pre class="language-none"><code class="language-none">  1
 / \
2   2
 \   \
 3    3</code></pre>

<p><strong>进阶：</strong></p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

//下面两个方法都是递归做法	
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
    if(!root)return true;
    return isMirror(root-&gt;left, root-&gt;right);
    }
    bool isMirror(TreeNode* nleft,TreeNode* nright)
    {
        if(!nleft&amp;&amp;!nright)return true;
        if(!nleft&amp;&amp;nright)return false;
        if(nleft&amp;&amp;!nright)return false;
        if(nleft-&gt;val!=nright-&gt;val)return false;
        return isMirror(nleft-&gt;left,nright-&gt;right)&amp;&amp;isMirror(nleft-&gt;right,nright-&gt;left);
    }
};

//一个月后写的方法，但还是看了官方的解题思路
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
       return check(root, root);
    

    }
    bool check(TreeNode *p,TreeNode *q)
        {
            if(!q&amp;&amp;!p)return true;
            if(!q||!p)return false;
            return p-&gt;val==q-&gt;val&amp;&amp;check(p-&gt;left,q-&gt;right)&amp;&amp;check(p-&gt;right,q-&gt;left);
        }
};</code></pre>



<h4 id="面试题-17-12-BiNode"><a href="#面试题-17-12-BiNode" class="headerlink" title="面试题 17.12. BiNode"></a><a href="https://leetcode-cn.com/problems/binode-lcci/">面试题 17.12. BiNode</a></h4><p>难度简单77</p>
<p>二叉树数据结构<code>TreeNode</code>可用来表示单向链表（其中<code>left</code>置空，<code>right</code>为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
<p><strong>注意：</strong>本题相对原题稍作改动</p>
<p><strong>示例：</strong></p>
<pre class="language-none"><code class="language-none">输入： [4,2,5,1,3,null,6,0]
输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li>节点数量不会超过 100000。</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
//2021.06.23
//今天做这道题花了很长时间，可能也是因为今天的状态不太好，也被某些事情分心了，思路不够清晰。
//然后静下心来发现，还是挺简单的，所以不要畏惧难题，静下心来解决它！！！就能获得成就感
class Solution {
public:
    TreeNode* ans=new TreeNode(0); //定义一个节点，用来返回新树的头节点
    TreeNode* tmp=ans; //定义一个节点，用来遍历整棵树
  	//中序遍历
    TreeNode* convertBiNode(TreeNode* root) {
        if(!root)return 0;
        convertBiNode(root-&gt;left);
        root-&gt;left=NULL;//将当前节点的左孩子赋值为空
        tmp-&gt;right=root;//将遍历节点的右孩子赋值为当前节点（就是将节点连接起来）
        tmp=root;//更新遍历节点
        convertBiNode(root-&gt;right);
        return ans-&gt;right;//返回头节点
    }
};c</code></pre>



<h4 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h4><p>难度中等524收藏分享切换为英文接收动态反馈</p>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<pre class="language-none"><code class="language-none">中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]</code></pre>

<p>返回如下的二叉树：</p>
<pre class="language-none"><code class="language-none">  3
 / \
9  20
  /  \
 15   7</code></pre>

<p>通过次数113,927</p>
<p>提交次数158,347</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

//错误的额版本，找这个错误找了好久，后来才发现是全局变量和局部变量的混乱引起的
class Solution {
public:

    TreeNode* traversal(vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder)
    {
        if(postorder.size()==0)return nullptr;
        int rootValue=postorder[postorder.size()-1];
        TreeNode* root=new TreeNode(rootValue);

        if(postorder.size()==1)return root;

        int delimiterIndex;
        for(int delimiterIndex=0;delimiterIndex&lt;inorder.size();delimiterIndex++)
        {
            if(inorder[delimiterIndex]==rootValue)break;
        }

        vector&lt;int&gt; leftInorder(inorder.begin(),inorder.begin()+delimiterIndex);
        vector&lt;int&gt; rightInorder(inorder.begin()+delimiterIndex+1,inorder.end());

        postorder.resize(postorder.size()-1);

        vector&lt;int&gt; leftPostorder(postorder.begin(),postorder.begin()+leftInorder.size());
        vector&lt;int&gt; rightPostorder(postorder.begin()+leftInorder.size(),postorder.end());

        root-&gt;left=traversal(leftInorder,leftPostorder);
        root-&gt;right=traversal(rightInorder,rightPostorder);
        return root;
    }
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        if(inorder.size()==0||postorder.size()==0)return nullptr;
        return traversal(inorder,postorder);
    }
};


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

//正确的答案
class Solution {
public:

    TreeNode* traversal(vector&lt;int&gt;&amp; inorder,vector&lt;int&gt;&amp; postorder)
    {
        if(postorder.size()==0)return nullptr;
        int rootValue=postorder[postorder.size()-1];
        TreeNode* root=new TreeNode(rootValue);

        if(postorder.size()==1)return root;

        int delimiterIndex;
        for(delimiterIndex=0;delimiterIndex&lt;inorder.size();delimiterIndex++)
        {
            if(inorder[delimiterIndex]==rootValue)break;
        }

        vector&lt;int&gt; leftInorder(inorder.begin(),inorder.begin()+delimiterIndex);
        vector&lt;int&gt; rightInorder(inorder.begin()+delimiterIndex+1,inorder.end());

        postorder.resize(postorder.size()-1);

        vector&lt;int&gt; leftPostorder(postorder.begin(),postorder.begin()+leftInorder.size());
        vector&lt;int&gt; rightPostorder(postorder.begin()+leftInorder.size(),postorder.end());

        root-&gt;left=traversal(leftInorder,leftPostorder);
        root-&gt;right=traversal(rightInorder,rightPostorder);
        return root;
    }
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        if(inorder.size()==0||postorder.size()==0)return nullptr;
        return traversal(inorder,postorder);
    }
};</code></pre>



<h4 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树</a></h4><p>难度中等298</p>
<p>给定一个不含重复元素的整数数组 <code>nums</code> 。一个以此数组直接递归构建的 <strong>最大二叉树</strong> 定义如下：</p>
<ol>
<li>二叉树的根是数组 <code>nums</code> 中的最大元素。</li>
<li>左子树是通过数组中 <strong>最大值左边部分</strong> 递归构造出的最大二叉树。</li>
<li>右子树是通过数组中 <strong>最大值右边部分</strong> 递归构造出的最大二叉树。</li>
</ol>
<p>返回有给定数组 <code>nums</code> 构建的 <strong>最大二叉树</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：nums = [3,2,1]
输出：[3,null,2,null,1]</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<p>通过次数48,046</p>
<p>提交次数59,319</p>
<h4 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h4><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<pre class="language-none"><code class="language-none">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}</code></pre>

<p><strong>示例 1：</strong></p>
<pre class="language-none"><code class="language-none">输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</code></pre>

<p><strong>示例 2：</strong></p>
<pre class="language-none"><code class="language-none">输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
// class Solution {
// public:
//     int removeElement(vector&lt;int&gt;&amp; nums, int val) {
//         int size = nums.size();
//         for (int i = 0; i &lt; size; i++) {
//             if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
//                 for (int j = i + 1; j &lt; size; j++) {
//                     nums[j - 1] = nums[j];
//                 }
//                 i--; // 因为下表i以后的数值都向前移动了一位，所以i也向前移动一位
//                 size--; // 此时数组的大小-1
//             }
//         }
//         return size;

//     }
// };

// class Solution {
// public:
//     int removeElement(vector&lt;int&gt;&amp; nums, int val) {
//         int n = nums.size();
//         int leftIndex = 0;
//         for(int rightIndex = 0; rightIndex &lt; n ;rightIndex++) {
//             if(nums[rightIndex] != val) {
//                 nums[leftIndex++] = nums[rightIndex];
//             }
//         }
//         return leftIndex;
//     }
// };

// 双指针法很常用
class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int n = nums.size();
        int leftIndex = 0, rightIndex = 0;
        for(int i = 0; i &lt; n ;i++) {
            if(nums[rightIndex] != val) {
                nums[leftIndex++] = nums[rightIndex++];
            }
            else rightIndex++;
        }
        return leftIndex;
    }
};</code></pre>





<h4 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h4><p>难度中等480</p>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：root = [3,1,4,null,2], k = 1
输出：1</code></pre>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p>
<pre class="language-none"><code class="language-none">输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3</code></pre>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数为 <code>n</code> 。</li>
<li><code>1 &lt;= k &lt;= n &lt;= 104</code></li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
<p>通过次数143,327</p>
<p>提交次数192,658</p>
<p>不用建立数组的做法：</p>
<p>这道题做的过程中，思路出现了点问题，还是对return的返回理解不够深刻，忽略了返回值造成的结果差错。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class Solution {
public:
    int result;
    int g_key;
    int kthSmallest(TreeNode* root, int k) {
        g_key = k;
        kLittleNumber(root, k);
        return result;
    }

    void kLittleNumber(TreeNode* root, int&amp; key) {
        if(root == nullptr) return;
        kLittleNumber(root-&gt;left, key);
        if(key == 1) {
            result = root-&gt;val;
            // return;  // 为什么这里出错呢，因为找到了 key == 1 的时候，返回上一层递归，那么key还是不变，此时就会出现错误结果
        }
        key--;
        kLittleNumber(root-&gt;right, key);
        
    }
};</code></pre>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器操作记录</title>
    <url>/2022/02/01/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="阿里云服务器默认不开启-root-远程登录"><a href="#阿里云服务器默认不开启-root-远程登录" class="headerlink" title="阿里云服务器默认不开启 root 远程登录"></a>阿里云服务器默认不开启 root 远程登录</h3><p>需要先进行 VNC 远程连接登录，再进行实例登录。</p>
<p>可以在Mac的命令行进行登录</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">ssh root@你的公网地址
password 你的密码</code></pre>

<span id="more"></span>

<h3 id="阿里云-centos-安装-nginx"><a href="#阿里云-centos-安装-nginx" class="headerlink" title="阿里云 centos 安装 nginx"></a>阿里云 centos 安装 nginx</h3><pre class="language-none"><code class="language-none">yum install nginx</code></pre>

<p>就一条命令就行，yum 会自动帮我们安装 nginx 所需要的依赖的</p>
<p>如果出现错误，那么就是 etc/yum.repos.d/CentOS-AppStream.repo 里面的镜像源出现了错误。</p>
<p>2022.02.16（出现了镜像源改变，所以我们需要改配置文件里面的路径）</p>
<p>将这个文件夹下的所有</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">baseurl=http://mirrors.cloud.aliyuncs.com/$contentdir/$releasever/AppStream/$basearch/os/</code></pre>

<p>改成：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">baseurl=https://mirrors.aliyun.com/$contentdir/$releasever-stream/AppStream/$basearch/os/</code></pre>

<p>比如：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell"># CentOS-AppStream.repo
#
# The mirror system uses the connecting IP address of the client and the
# update status of each mirror to pick mirrors that are updated to and
# geographically close to the client.  You should use this for CentOS updates
# unless you are manually picking other mirrors.
#
# If the mirrorlist= does not work for you, as a fall back you can try the
# remarked out baseurl= line instead.
#
#

[AppStream]
name=CentOS-$releasever - AppStream
#baseurl=http://mirrors.cloud.aliyuncs.com/$contentdir/$releasever/AppStream/$basearch/os/
#改为下面这个
baseurl=http://mirrors.aliyuncs.com/$contentdir/$releasever-stream/AppStream/$basearch/os/
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</code></pre>

<p>安装成功，配置端口之后重启服务即可</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马程序员C++提高编程笔记</title>
    <url>/2022/01/03/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C-%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="黑马程序员C-提高编程笔记"><a href="#黑马程序员C-提高编程笔记" class="headerlink" title="黑马程序员C++提高编程笔记"></a>黑马程序员C++提高编程笔记</h1><p>[toc]</p>
<h2 id="1-STL"><a href="#1-STL" class="headerlink" title="1. STL"></a>1. STL</h2><h3 id="1-1-STL"><a href="#1-1-STL" class="headerlink" title="1.1 STL"></a>1.1 STL</h3><ul>
<li>标准模版库（Standard Templete Library）</li>
</ul>
<span id="more"></span>

<h3 id="1-2-STL基本概念："><a href="#1-2-STL基本概念：" class="headerlink" title="1.2 STL基本概念："></a>1.2 STL基本概念：</h3><ul>
<li><p>STL六大组件：</p>
<ul>
<li>容器：各种数据结构、如vector、list、map、set、deque</li>
<li>算法：各种常见的算法、比如sort、find、copy、for_each</li>
<li>迭代器：扮演了容器和算法之间的粘合剂</li>
<li>仿函数：行为类似函数、可以作为 算法的某种策略</li>
<li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</li>
<li>空间配置器：负责空间的配置与管理</li>
</ul>
</li>
<li><p>容器就是用来存放数据的</p>
</li>
<li><p>STL容器就是将一些运用最广泛的数据结构实现出来</p>
</li>
<li><p>常用的数据结构：数组、链表、二叉树、栈、队列、集合、映射表</p>
</li>
<li><p>这些容器分为序列式容器和关联式容器</p>
<ul>
<li>序列式容器强调值的排序，里面每个值都有固定的位置</li>
<li>关联式容器：二叉树结构、各元素之间没有严格的物理上的顺序关系</li>
</ul>
</li>
</ul>
<h3 id="1-2-容器算法"><a href="#1-2-容器算法" class="headerlink" title="1.2 容器算法"></a>1.2 容器算法</h3><ul>
<li>算法<ul>
<li>算法就是用有限的步骤，解决数学或者逻辑上的问题</li>
<li>算法分为质变算法和非质变算法<ul>
<li>质变算法是指运算过程中会更改区间内的元素，例如拷贝、删除、替换</li>
<li>非质变算法是指运算过程中不会更改区间内的元素。例如查找、计数、遍历、寻找极值等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-迭代器"><a href="#1-3-迭代器" class="headerlink" title="1.3 迭代器"></a>1.3 迭代器</h3><ul>
<li>迭代器就是容器和算法之间的粘合剂<ul>
<li>提供一种方法，使之能够依序访问容器内的各个元素，而不暴露容器的内部表示方式</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  迭代器初识
//
//  Created by OnlyBei on 2021/9/24.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void myPrint(int val) {
    cout &lt;&lt; val &lt;&lt; endl;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    vector&lt;int&gt; v;
    v.push_back(10);
    v.push_back(20);
    v.push_back(30);
    v.push_back(40);
    
    vector&lt;int&gt;::iterator pBegin = v.begin();
    vector&lt;int&gt;::iterator pEnd = v.end();
    
    // 第一种遍历方式
    while(pBegin != pEnd) {
        cout &lt;&lt; *pBegin &lt;&lt; endl;
        pBegin++;
    }
    
    // 第二种
    for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; endl;
    }
    
    for_each(v.begin(), v.end(), myPrint);
    
}
</code></pre>



<h3 id="1-4-vector存放自定义数组"><a href="#1-4-vector存放自定义数组" class="headerlink" title="1.4 vector存放自定义数组"></a>1.4 vector存放自定义数组</h3><pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  vector中存放自定义数据类型
//
//  Created by OnlyBei on 2021/9/24.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

class Person {
public:
    Person(string name, int age) {
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    }
public:
    string m_Name;
    int m_Age;
};

void test01() {
    vector&lt;Person&gt; v;
    
    Person p1("aaa", 10);
    Person p2("bbb", 20);
    Person p3("ccc", 30);
    Person p4("ddd", 40);
    
    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    
    for(vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) {
//        cout &lt;&lt; "姓名：" &lt;&lt; it-&gt;m_Name &lt;&lt; "年龄：" &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
        cout &lt;&lt; "姓名：" &lt;&lt; (*it).m_Name &lt;&lt; "年龄：" &lt;&lt; (*it).m_Age &lt;&lt; endl;

    }

}

void test02() {
    vector&lt;Person*&gt; v;
    
    Person p1("aaa", 10);
    Person p2("bbb", 20);
    Person p3("ccc", 30);
    Person p4("ddd", 40);
    
    v.push_back(&amp;p1); // 取地址
    v.push_back(&amp;p2);
    v.push_back(&amp;p3);
    v.push_back(&amp;p4);
    
    for(vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) {
      // 双重指针
//        cout &lt;&lt; "2姓名：" &lt;&lt; (*(*it)).m_Name &lt;&lt; "年龄：" &lt;&lt; (*(*it)).m_Age &lt;&lt; endl;
        cout &lt;&lt; "2姓名：" &lt;&lt; (*it)-&gt;m_Name &lt;&lt; "年龄：" &lt;&lt; (*it)-&gt;m_Age &lt;&lt; endl;

    }

}

int main(int argc, const char * argv[]) {
    // insert code here...
//    test01();
    test02();
}
</code></pre>



<h3 id="1-5-vector的嵌套结构"><a href="#1-5-vector的嵌套结构" class="headerlink" title="1.5 vector的嵌套结构"></a>1.5 vector的嵌套结构</h3><pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  vector中的嵌套数据类型
//
//  Created by OnlyBei on 2021/9/24.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void test() {
    vector&lt;vector&lt;int&gt; &gt; v;
    
    vector&lt;int&gt; v1;
    vector&lt;int&gt; v2;
    vector&lt;int&gt; v3;
    vector&lt;int&gt; v4;
    
    for(int i = 0; i &lt; 4; i++) {
        v1.push_back(i);
        v2.push_back(i + 4);
        v3.push_back(i + 8);
        v4.push_back(i + 12);
    }
    
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);
    v.push_back(v4);
    
    for(vector&lt;vector&lt;int&gt; &gt;::iterator it = v.begin(); it != v.end(); it++) {
        for(vector&lt;int&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) {
            cout &lt;&lt; *vit &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }

}

int main(int argc, const char * argv[]) {
    // insert code here...
    test();
}
</code></pre>



<h2 id="2-String容器"><a href="#2-String容器" class="headerlink" title="2. String容器"></a>2. String容器</h2><h3 id="2-0-前置知识："><a href="#2-0-前置知识：" class="headerlink" title="2.0 前置知识："></a>2.0 前置知识：</h3><ul>
<li><p>在C语言中:</p>
<ul>
<li>char是定义一个字符，存储一个字符，占一个字节。</li>
<li>string是定义一个字符串，存储的是一段如“abcd”的数据，而且最后还有一个结束符’\0’。</li>
</ul>
</li>
<li><p>在C++中:</p>
<ul>
<li><p>string有两种，要区别理解；</p>
</li>
<li><p>第一种是字符串char[ ]，例如’a’是char, “a”是char string，这两者都是普通的字符和字符串，和C语言中没什么不同值得注意的是后者包含两个字符，末尾有一个隐身的’\0’。</p>
</li>
<li><p>第二种是封装好的字符串类，如string str = “a” 是C++ 封装好的string。</p>
</li>
<li><p>C++中的char string和string不是一回事。当用到了”string”这个关键词，就不是普通的字符串，而是用到了封装后的类。</p>
</li>
<li><p>在C++中，char仍然是一个primitive type(原始类型)，而string已经经过封装，成为了一个class(类)用到它时，我们需要 #include<string>，它是C++ Standard Library (C++标准库)的一部分。</string></p>
</li>
</ul>
</li>
<li><p>c中的char* 定义字符串，不能改变字符串内的字符的内容，但却可以把另外一个字符串赋给它。</p>
</li>
</ul>
<h3 id="2-1-String的基本概念"><a href="#2-1-String的基本概念" class="headerlink" title="2.1 String的基本概念"></a>2.1 String的基本概念</h3><ul>
<li>string是C++风格的字符串，而string本质是一个类</li>
<li>string和char *的区别<ul>
<li>char *是一个指针</li>
<li>string是一个类，类内部封装了char * ，管理这个字符串，是一个char * 的容器</li>
</ul>
</li>
<li>特点：<ul>
<li>string内部封装了很多成员方法</li>
<li>例如：find查找、insert插入、delete删除、replace替换、copy拷贝</li>
<li>string管理char*的内存，不用担心复制越界和取值越界等，由类内部负责</li>
</ul>
</li>
</ul>
<h3 id="2-2-String的构造函数"><a href="#2-2-String的构造函数" class="headerlink" title="2.2 String的构造函数"></a>2.2 String的构造函数</h3><ul>
<li>string();     //创建一个空的字符串，例如string str</li>
<li>string(const char* s);   // 使用字符串s初始化</li>
<li>string(const string&amp; str); // 使用一个string对象初始化另一个string对象</li>
<li>string(int n, char c); // 使用n个字符c初始化</li>
</ul>
<h3 id="2-3-Sring的赋值操作"><a href="#2-3-Sring的赋值操作" class="headerlink" title="2.3 Sring的赋值操作"></a>2.3 Sring的赋值操作</h3><ul>
<li>string&amp; operator = (const char* s);        //char*类型字符串，赋值给当前字符串</li>
<li>string&amp; operator = (const  string &amp;s);    //把字符串s赋值给当前字符串</li>
<li>string&amp; operator = (char c);                     //把字符赋值给当前字符串</li>
<li>string&amp; assign(const char* s);                //把字符串s赋值给当前字符串 </li>
<li>string&amp; assign(const char* s, int n);      //把字符串s的前n位赋值给当前字符串 </li>
<li>string&amp; assign(const stringr &amp;s);           //把字符串s赋值给当前字符串 </li>
<li>string&amp; assign(int n, char c);                   //用n个字符赋值给当前字符串</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  String的赋值操作
//
//  Created by OnlyBei on 2021/9/24.
//

#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void test() {
    string s1;
    s1 = "hello,world";
    cout &lt;&lt; "s1 = " &lt;&lt; s1 &lt;&lt; endl;
    
    string s2 = s1;
    cout &lt;&lt; "s2 = " &lt;&lt; s2 &lt;&lt; endl;
    
    string s3;
    s3 = "a";
    cout &lt;&lt; "s3 = " &lt;&lt; s3 &lt;&lt; endl;
    
    string s4;
    s4.assign("hello, c++");
    cout &lt;&lt; "s4 = " &lt;&lt; s4 &lt;&lt; endl;
    
    string s5;
    s5.assign("hello, c++", 5);
    cout &lt;&lt; "s5 = " &lt;&lt; s5 &lt;&lt; endl;
    
    string s6;
    s6.assign(s5);
    cout &lt;&lt; "s6 = " &lt;&lt; s6 &lt;&lt; endl;
    
    string s7;
    s7.assign(15, 'h');
    cout &lt;&lt; "s7 = " &lt;&lt; s7 &lt;&lt; endl;
}

int main(int argc, const char * argv[]) {
    // insert code here...
    test();
}
</code></pre>



<h3 id="2-4-String字符串拼接"><a href="#2-4-String字符串拼接" class="headerlink" title="2.4 String字符串拼接"></a>2.4 String字符串拼接</h3><ul>
<li>string&amp; operator += (const char* str); // 重载+=操作符</li>
<li>string&amp; operator += (const char c); // 重载+=操作符</li>
<li>string&amp; operator += (const string&amp; str); // 重载+=操作符</li>
<li>string&amp; append(const char *s); // 把字符串s连接到当前字符串的结尾</li>
<li>string&amp; append(const char *s,int n);  // 把字符串s的前n位连接到当前字符串的结尾</li>
<li>string&amp; append(const string &amp;s); //同string&amp; operator += (const char* str)</li>
<li>string&amp; append(const string &amp;s, int pos, int n); // 字符串s从pos开始的n个字符拼接到当前字符串的尾部</li>
</ul>
<h3 id="2-5-String字符串的查找"><a href="#2-5-String字符串的查找" class="headerlink" title="2.5 String字符串的查找"></a>2.5 String字符串的查找</h3><ul>
<li>功能描述<ul>
<li>查找：查找指定字符串是否存在</li>
<li>替换：在指定的位置替换字符串</li>
</ul>
</li>
<li>函数原型：<ul>
<li>int find(const string&amp; str, int pos = 0) const; // 查找str第一次出现的位置，从pos开始查找</li>
<li>Int find(cosnt char* s, int pos = 0) const; // 查找s第一次出现的位置，从pos开始查找</li>
<li>int find(const char* s, int pos, int n) const; //从pos位置查找s的前n个字符第一次位置</li>
<li>int find(const char c, int pos = 0) const; // 查找字符c第一次出现位置</li>
<li>int rfind(const string&amp; str, int pos = npos) const; // 查找str最后一次位置，从pos开始查找</li>
<li>int find(const char* s, int pos = npos) const;  // 查找s最后一次出现位置，从pos开始查找</li>
<li>int rfind(const char* s, int pos, int n) const;   //从pos查找s的前n个字符最后一次出现位置</li>
<li>int rfind(const char s, int pos = 0) const;  //查找字符c最后一次出现位置</li>
<li>string&amp; replace(int pos, int n , const string&amp; str); //替换从pos开始n个字符位字符串str</li>
<li>string&amp; replace(int pos, int n, const char* s); //替换从pos开始的n个字符为字符串</li>
</ul>
</li>
</ul>
<h3 id="2-6-String字符串比较"><a href="#2-6-String字符串比较" class="headerlink" title="2.6 String字符串比较"></a>2.6 String字符串比较</h3><ul>
<li><p>功能描述：</p>
<ul>
<li>字符串之间的比较</li>
</ul>
</li>
<li><p>比较方式：</p>
<ul>
<li>字符串比较是按字符的ASCII码进行对比</li>
<li>=  的话返回 0</li>
<li><code>&gt;的话返回 1</code></li>
<li><code>&lt;的话返回 -1</code></li>
</ul>
</li>
<li><p>函数原型：</p>
<ul>
<li>int compare(const string &amp;s) const; //与字符串s进行比较</li>
<li>int compare(const char *s) const; //与字符串s进行比较</li>
</ul>
</li>
</ul>
<h3 id="2-7-String字符串的存取"><a href="#2-7-String字符串的存取" class="headerlink" title="2.7 String字符串的存取"></a>2.7 String字符串的存取</h3><ul>
<li>string中单个字符的存取有两种方式</li>
<li>char&amp; operator[] (int n); //通过[]方式取字符</li>
<li>Char&amp; at(int n); //通过at方式取字符</li>
</ul>
<p>修改的话直接，str[i] = “”; 或者 str.at(n) = “”;</p>
<h3 id="2-8-String插入和删除"><a href="#2-8-String插入和删除" class="headerlink" title="2.8 String插入和删除"></a>2.8 String插入和删除</h3><ul>
<li>功能描述：<ul>
<li>对string字符串进行插入和删除操作</li>
</ul>
</li>
<li>函数原型：<ul>
<li>string&amp; insert(int pos, const char* s); //插入字符串</li>
<li>string&amp; insert(int pos, const string&amp; s); //插入字符串</li>
<li>string&amp; insert(int pos, int n, char c); //在指定位置插入n个字符串c</li>
<li>string&amp; erase(int pos, int n = npos); //删除从pos开始的n个字符</li>
</ul>
</li>
</ul>
<h3 id="2-9-String字符串子串"><a href="#2-9-String字符串子串" class="headerlink" title="2.9 String字符串子串"></a>2.9 String字符串子串</h3><ul>
<li>功能描述：<ul>
<li>从字符串中获取想要的子串</li>
</ul>
</li>
<li>函数原型：<ul>
<li>string substr(int pos = 0, int n = npos) const; // 返回从pos开始由n个字符组成的字符串</li>
</ul>
</li>
</ul>
<h2 id="3-Vector容器"><a href="#3-Vector容器" class="headerlink" title="3. Vector容器"></a>3. Vector容器</h2><h3 id="3-1-Vector基本概念"><a href="#3-1-Vector基本概念" class="headerlink" title="3.1 Vector基本概念"></a>3.1 Vector基本概念</h3><ul>
<li>功能：<ul>
<li>vector数据结构和数组非常相似，也称为单端数组</li>
</ul>
</li>
<li>vector与普通数组的区别<ul>
<li>vector可以动态扩展</li>
</ul>
</li>
<li>动态扩展：<ul>
<li>并不是在原有空间之后拼接新空间，而是找更大的内存空间，然后将数据拷贝到新空间，释放原空间</li>
</ul>
</li>
<li>vector容器迭代器是支持随机访问的一个迭代器</li>
</ul>
<h3 id="3-2-Vector容量和大小"><a href="#3-2-Vector容量和大小" class="headerlink" title="3.2 Vector容量和大小"></a>3.2 Vector容量和大小</h3><ul>
<li>功能描述：<ul>
<li>对vector的容器的容量和大小进行操作</li>
</ul>
</li>
<li>函数原型<ul>
<li>empty();     //判断容器是否为空</li>
<li>capacity(); //容器的容量</li>
<li>size(); //返回容器中元素的个数</li>
<li>resize(int num); //重新指定容器的大小为num，若容器变长，则以默认值填充新位置，若变短，则末尾超出容器元素被删除</li>
<li>resize(int num, in elem);//重新指定容器的大小为num，若容器变长，则以elem值填充新位置，若变短，则末尾超出容器元素被删除</li>
</ul>
</li>
</ul>
<h3 id="3-3-Vector容器的插入和删除"><a href="#3-3-Vector容器的插入和删除" class="headerlink" title="3.3 Vector容器的插入和删除"></a>3.3 Vector容器的插入和删除</h3><ul>
<li>push_back(); //尾插法</li>
<li>pop_back(); // 删除尾部的元素</li>
<li>clear(); //删除容器中所有元素</li>
<li>front(); // 返回容器中第一个元素</li>
<li>back(); // 返回容器中最后一个元素</li>
<li>swap(); //实现两个容器进行互换操作，实现内存收缩的效果<ul>
<li>用swap可以玩很多花样</li>
<li><a href="https://blog.csdn.net/m0_37251750/article/details/100071023">一篇关于swap写的很好的博客</a></li>
</ul>
</li>
<li>reverse(int len); //容器预留len个元素长度，预留位置不初始化，元素不可访问</li>
</ul>
<h2 id="4-deque容器"><a href="#4-deque容器" class="headerlink" title="4. deque容器"></a>4. deque容器</h2><h3 id="3-1-deque容器基本概念"><a href="#3-1-deque容器基本概念" class="headerlink" title="3.1 deque容器基本概念"></a>3.1 deque容器基本概念</h3><ul>
<li>功能<ul>
<li>双端数组，可以对头端进行插入删除</li>
</ul>
</li>
<li>deque的区别<ul>
<li>vector对于头部的插入删除效率低、数据量越大、效率越低</li>
<li>deque相对而言，在头部进行数据插入删除的效率比vector高</li>
<li>vector访问元素的速度比deque快，这是由两者的内部实现有关</li>
</ul>
</li>
</ul>
<h2 id="5-List容器"><a href="#5-List容器" class="headerlink" title="5. List容器"></a>5. List容器</h2><h3 id="5-1-list基本概念"><a href="#5-1-list基本概念" class="headerlink" title="5.1 list基本概念"></a>5.1 list基本概念</h3><ul>
<li>功能<ul>
<li>将数据进行链式存储</li>
<li>链表（list）是一种物理存储非连续的物理结构，数据元素的逻辑顺序是通过指针链接实现的</li>
<li>STL中的链表是一个双向循环链表</li>
</ul>
</li>
</ul>
<h2 id="6-Set容器"><a href="#6-Set容器" class="headerlink" title="6.Set容器"></a>6.Set容器</h2><ul>
<li>set简介<ul>
<li>所有元素在插入时会自动排序</li>
</ul>
</li>
<li>本质<ul>
<li>set/multiset属于关联式容器，底层用二叉树实现</li>
</ul>
</li>
<li>set不允许用重复元素</li>
<li>multiset允许重复元素</li>
</ul>
<h2 id="7-Map容器"><a href="#7-Map容器" class="headerlink" title="7.Map容器"></a>7.Map容器</h2><ul>
<li><p>简介：</p>
<ul>
<li>map中所有元素都是pair（对组）</li>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（元素）</li>
<li>所有元素都会按照key值进行排序</li>
</ul>
</li>
<li><p>本质</p>
<ul>
<li>map/multimap属于关联式容器，底层用二叉树实现</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>可以根据key值快速找到value值</li>
</ul>
</li>
<li><p>区别：</p>
<ul>
<li>map不允许用重复元素</li>
<li>multimap允许重复元素</li>
</ul>
</li>
</ul>
<h2 id="8-谓词"><a href="#8-谓词" class="headerlink" title="8. 谓词"></a>8. 谓词</h2><h3 id="8-1-谓词概念"><a href="#8-1-谓词概念" class="headerlink" title="8.1 谓词概念"></a>8.1 谓词概念</h3><ul>
<li>概念：<ul>
<li>返回布尔类型的仿函数称为谓词</li>
<li>如果operator（）接受一个参数，那么叫做一元谓词</li>
<li>如果operator（）接受两个参数，那么叫做二元谓词</li>
</ul>
</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  谓词
//
//  Created by OnlyBei on 2021/9/25.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class getFive{
public:
    bool operator()(int val) { // 仿函数为什么这样写呢，可以看下面一段代码的源码
        return val &gt; 5;
    }
};

void test() {
    vector&lt;int&gt; v;
    for(int i = 0; i &lt; 10; i++) {
        v.push_back(i);
    }
    
    // getFive()是一个仿函数
    vector&lt;int&gt;::iterator it =  find_if(v.begin(), v.end(), getFive());
    
    if(it != v.end()) {
        cout &lt;&lt; "找到了 " &lt;&lt; *it &lt;&lt; endl;
    }else {
        cout &lt;&lt; "未找到" &lt;&lt; endl;
    }
    
}

int main(int argc, const char * argv[]) {
    // insert code here...
    test();
}
</code></pre>



<pre class="language-c++" data-language="c++"><code class="language-c++">find_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
{
    for (; __first != __last; ++__first)
        if (__pred(*__first)) // 如果这个为真，则跳出循环，放回一个迭代器
            break;
    return __first; 
}</code></pre>



<ul>
<li><p>二元谓词</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  谓词
//
//  Created by OnlyBei on 2021/9/25.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;

class FuncSort {
public:
    bool operator() (int a, int b) {
        return a &gt; b;
    }
};

void test02() {
    vector&lt;int&gt; v1;
    v1.push_back(10);
    v1.push_back(30);
    v1.push_back(80);
    v1.push_back(50);
    v1.push_back(20);
    
//    sort(v1.begin(), v1.end()); // 默认从小打大
    sort(v1.begin(), v1.end(), FuncSort());
    
    for(vector&lt;int&gt;::iterator it = v1.begin(); it != v1.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

}

int main(int argc, const char * argv[]) {
    test02();
}
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>黑马程序员C++核心编程笔记</title>
    <url>/2022/01/03/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98C-%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="黑马程序员C-核心编程笔记"><a href="#黑马程序员C-核心编程笔记" class="headerlink" title="黑马程序员C++核心编程笔记"></a>黑马程序员C++核心编程笔记</h2><p>[toc]</p>
<h2 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h2><h3 id="0-基础知识"><a href="#0-基础知识" class="headerlink" title="0.基础知识"></a>0.基础知识</h3><p>结构体：</p>
<ul>
<li>  结构体属于用户自定义的类型，允许用户存储不同的数据</li>
</ul>
<p>C语言和C++结构体的区别</p>
<span id="more"></span>

<ul>
<li>  在C语言中，可以定义结构体类型，将多个相关的变量包装成为一个整体使用。在结构体中的变量，可以是相同、部分相同，或完全不同的数据类型。在C语言中，结构体不能包含函数。在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展，C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而不是private</li>
</ul>
<h3 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1. 内存分区模型"></a>1. 内存分区模型</h3><p>c++在执行时，将内存大方向划分为4个区域</p>
<p>●    代码区：存放函数体的二进制代码，由操作系统进行管理。</p>
<ul>
<li>  代码区是共享和只读的</li>
</ul>
<p>●    全局区：存放全局变量和静态变量以及常量。</p>
<ul>
<li>  全局区还包含了常量区：字符串常量和const修饰的全局常量也存放在此</li>
<li>  该区域的数据在程序结束后由操作系统释放</li>
</ul>
<p>●    栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。局部常量也是存放在栈区的</p>
<p>●    堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p>
<p><strong>内存四区的意义：</strong></p>
<p>不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。</p>
<h4 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h4><p>在程序编译以后，生成了exe可执行程序，<strong>未执行程序前</strong>分为两个区域。</p>
<p><strong>代码区</strong>：    </p>
<p>​        存放CPU执行的机器指令</p>
<p>​        代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。</p>
<p>​        代码区是只读的，为了防止程序意外的修改它的指令，造成损失。</p>
<p><strong>全局区</strong>：</p>
<p>​        全局变量和静态变量存放于此。</p>
<p>​        全局区还包含了常量区，字符串常量和其他常量存放于此。</p>
<p>​        该区域的数据在程序结束后由操作系统释放。</p>
<p>​        （在函数中的变量都是局部变量。全局变量就是写在函数外的。）</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro09wr02j30wm09uq5a.jpg"></p>
<p><strong>总结：</strong></p>
<p>​        ●    C++在程序运行前分为全局区和代码区。</p>
<p>​        ●    代码区的特点是共享和只读</p>
<p>​        ●    全局区中存放全局变量，静态变量，常量</p>
<p>​        ●    常量区中存放const修饰的全局常量和字符串常量</p>
<h4 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h4><p>​    <strong>栈区：</strong></p>
<p>​            由编译器自动分配释放，存放函数的参数值，局部变量等。</p>
<p>​            注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

//栈区数据注意事项：不要返回局部变量的地址
//栈区的数据由编译器管理开发的释放

int *func()	//形参数据也会放在栈区
{
    int a = 10;	//局部变量：存放在栈区，栈区的数据在函数执行完后自动释放
    return &amp;a;	//返回局部变量的地址
}	

int main()
{
  	//接受func函数的返回值
    int *p = func();
    cout &lt;&lt; *p &lt;&lt; endl;	//第一次可以打印正确的数字，是因为编译器做了保留
    cout &lt;&lt; *p &lt;&lt; endl;	//没有保留
}</code></pre>

<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro6fredqj30va07aq3n.jpg"></p>
<p>​    <strong>堆区：</strong></p>
<p>​            由程序员分配释放，若程序员不释放，程序结束时由操作系统释放。</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

int *func()
{
  	//利用new关键字 将数据开辟到堆区
  	//new int(188)返回的是一个地址，所有用指针去接受地址
  	//指针本质上也是局部变量，放在栈上，指针保存的数据是放在堆区
    int *p=new int(188);	//小括号里面就是堆区开辟地址初始值。
    return p;

}
int main()
{
  	//在堆区开辟数据
    int *p=func();
    cout&lt;&lt;*p&lt;&lt;endl;
    cout&lt;&lt;*p&lt;&lt;endl;
}</code></pre>



<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro7o51hzj30j607gjrm.jpg" style="zoom:67%;">

<p>​    <strong>总结：</strong></p>
<p>​            堆区数据有程序员管理开辟和释放。</p>
<p>​            堆区数据利用new关键字进行开辟内存。            </p>
<p>​            </p>
<h4 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h4><p>​        </p>
<p>​        C++中利用new操作符在堆区开辟数据</p>
<p>​        堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符delete</p>
<p>​        语法：new 数据类型</p>
<p>​        利用new创建的数据，会返回该数据对应的类型的指针</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int *func()
{
    //在堆区创建整型数据
    //new返回的是 该创建数据类型的指针
    //int* 是接受这个地址并且解引用
    int *a = new int(18);
    return a;
}

void test01()
{
    int *p = func();
    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; *p &lt;&lt; endl;
    cout &lt;&lt; *p &lt;&lt; endl;
    delete p;
    cout &lt;&lt; *p &lt;&lt; endl;	//不知道为什么，这个在Mac上的vscode上可以输出
}

void test02()
{
    //创建一个10整型数据的数组，在堆区
    int *arr = new int[10]; //代表数组由10个元素
  
    for (int i = 0; i &lt; 10; i++)
    {
        arr[i] = i + 100;
    }
  
    for (int i = 0; i &lt; 10; i++)
    {
        cout &lt;&lt; arr[i] &lt;&lt; endl;
    }
  	//释放堆区数组
  	//如果不加[],只释放了第一个指针，后面的指针被称为野指针。
  	delete[] arr;
}

int main()
{
    test01();
  
    test02();
}
</code></pre>



<h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h3><h4 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h4><p>作用：给变量起别名 </p>
<p>语法：数据类型 &amp;别名 = 原名</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro8f0t2fj30vg0ggwip.jpg"></p>
<h4 id="2-2-引用的注意事项"><a href="#2-2-引用的注意事项" class="headerlink" title="2.2 引用的注意事项"></a>2.2 引用的注意事项</h4><p>​    ●    引用必须初始化</p>
<p>​    ●    引用在初始化后，不可以改变</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

//引用必须要初始化 如int &amp;b；是错误的
//引用一旦初始化后，局部可以更改
int main()
{
    int a = 10;
    int &amp;b = a;
    cout &lt;&lt; b &lt;&lt; endl;
    int c = 30;
    b = c;  //这是赋值操作，不是更改引用

    cout &lt;&lt; b &lt;&lt; endl;
}</code></pre>



<h4 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h4><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p>
<p>优点：可以简化指针修改实参</p>
<p>代码：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;


//  值传递
void swap01(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
}

//  地址传递
void swap02(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

//  引用传递
void swap03(int &amp;a, int &amp;b)
{
    int temp = a;
    a = b;
    b = temp;
}
int main()
{
    int a=11;
    int b=888;
    swap01(a,b);
    cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;"\tb="&lt;&lt;b&lt;&lt;endl;

    swap02(&amp;a,&amp;b);
    cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;"\tb="&lt;&lt;b&lt;&lt;endl;


    int c=777;
    int d=12222;
    swap03(c,d);
    cout&lt;&lt;"c="&lt;&lt;c&lt;&lt;"\td="&lt;&lt;d&lt;&lt;endl;
}</code></pre>

<p>运行结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqro9g1dnvj30vc06igme.jpg"></p>
<p>总结：总结：通过引用参数产生的效果同按地址传递是一样的，引用的语法更清楚简单。</p>
<h4 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h4><pre class="language-C++" data-language="C++"><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int &amp;test01()
{
    int a = 10;
    //return a;
}

int &amp;test02()
{
    static int a = 99;
    return a;
}

int main()
{

    //不能返回局部变量的引用
    int &amp;ret = test01();
		//非法操作
    cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl;
    cout &lt;&lt; "ret=" &lt;&lt; ret &lt;&lt; endl;

    //如果函数做左值，那么必须返回引用
    int &amp;ret2 = test02();

    cout &lt;&lt; "ret=" &lt;&lt; ret2 &lt;&lt; endl;
    cout &lt;&lt; "ret=" &lt;&lt; ret2 &lt;&lt; endl;

    test02() = 1000;
    cout &lt;&lt; "ret=" &lt;&lt; ret2 &lt;&lt; endl;
    cout &lt;&lt; "ret=" &lt;&lt; ret2 &lt;&lt; endl;
}</code></pre>



<h4 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h4><p>本质：<strong>引用的本质在c++内部实现是一个指针常量</strong></p>
<p>也就是指针的指向不可以更改，而指针指向的值可以改，也就符合了引用定义后就不能修改的原则</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

// 发现是引用 转换为int* const ref = &amp;a；
void func(int &amp;ref)
{
    ref=100; // ref是引用，转换为*ref = 100
}


int main()
{
    int a=11;

    //自动转换为int* const ref = &amp;a；指针常量是指针指向不可改，也说明为什么引用不可改
    int &amp;ref=a;
    ref=20; // 发现是引用 转换为*ref = 20；

    cout&lt;&lt;"a="&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;"ref="&lt;&lt;ref&lt;&lt;endl;

    func(a);
    return 0;
}</code></pre>

<p>总结：C++推荐用引用技术，是因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了。</p>
<h4 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqsehx3ealj31180sg15a.jpg"> </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqse66vlomj31ai0n0anv.jpg"></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

// 引用使用的场景，通常用来修饰形参,如果不加const，就会可能无意被修改，特别是以后代码量大的时候，
// 可能会忘记自己曾经写的这个值能不能改
void showValue(int &amp;val)
{
    val=10088;
    cout &lt;&lt; val &lt;&lt; endl;
}

void showValueTwo(const int &amp;val)
{
    // val=888; // 错误，这里就不能改了
    cout&lt;&lt;val&lt;&lt;endl;
}


int main()
{

    // 函数中利用常量引用防止误操作修改实参
    int a = 10;
    showValue(a);

    cout &lt;&lt; "a=" &lt;&lt; a &lt;&lt; endl;
}</code></pre>



<h3 id="3-函数的提高"><a href="#3-函数的提高" class="headerlink" title="3. 函数的提高"></a>3. 函数的提高</h3><h4 id="3-1-函数的默认参数"><a href="#3-1-函数的默认参数" class="headerlink" title="3.1 函数的默认参数"></a>3.1 函数的默认参数</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqsemgo09fj314y0ssqec.jpg"></p>
<h4 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h4><p>c++中函数的参数列表可以用占位参数，用来做占位，调用函数时必须填补该位置。</p>
<p>语法：返回值类型 函数名 （数据类型）{}</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqses5y3bhj30rc0dgdkh.jpg"></p>
<p>也可以这些写</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqsesmh6elj30v80k0tif.jpg" style="zoom: 50%;">



<h4 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h4><h5 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h5><p> <strong>作用：函数名可以相同，提高复用性</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqsezyq7mvj313m0tqk4p.jpg"></p>
<h5 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h5><p>● 引用作为重载条件</p>
<p>● 函数重载碰到函数默认参数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;

using namespace std;

// 函数重载的注意事项
// 1.引用作为重载的条件
//假如func(10)调用的是这个的话，那么是int &amp;a = 10； 不合法
// 10存储在全局区的常量区，而引用必须要一个合法的内存空间，要么在栈区要么在堆区。
// 所以这样引用明显不合法
void func(int &amp;a) 
{
    cout&lt;&lt;"func(int &amp;a)'s call of"&lt;&lt;endl;
}


void func(const int &amp;a) // const int &amp;a = 10;
{
    cout&lt;&lt;"func(const int &amp;a)'s call of"&lt;&lt;endl;
}

void func2(int a,int b=10)
{
    cout&lt;&lt;"func(int a,int b=10)'s call of"&lt;&lt;endl;
}


void func2(int a)
{
    cout&lt;&lt;"func(int a)'s call of"&lt;&lt;endl;
}


int main()
{
    int a=10; //调用的是a是一个变量，可读可写，所以引用的是第一个函数
    func(a);

    func(10); //

    // !func2(10); error 
    // because There are 
    // multiple instances of overloaded function "func2" 
    // that match the parameter list
    return 0;

}</code></pre>

<p>总结：</p>
<p>● 写函数重载的时候不要写默认参数，容易发生错误。</p>
<h3 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4.类和对象"></a>4.类和对象</h3><h4 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h4><h5 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h5><p>构造函数：</p>
<pre class="language-none"><code class="language-none">1. 构造函数没有返回值
2. 构造函数可以重载
3. 程序在调用对象时会自动调用构造，而且只调用一次</code></pre>

<p>析构函数：</p>
<pre class="language-none"><code class="language-none">1. 析构函数没有返回值
2. 析构函数没有参数不可以重载
3. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次</code></pre>

<h5 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h5><p>两种分类方式：</p>
<p>​    按参数分为：有参构造和无参构造</p>
<p>​    按类型分为：普通构造和拷贝构造</p>
<p>三种调用方式：</p>
<p>​    括号法 </p>
<p>​    显示法</p>
<p>​    隐式转换法</p>
<p><font color="red">example：</font></p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Person
{
private:
    /* data */
public:
    Person();
    Person(int a);
    Person(const Person &amp;a);
    ~Person();
    int age;
};

Person::Person()
{
    cout &lt;&lt; "Person's call of nonparametric constructor" &lt;&lt; endl;
}

Person::Person(int a)
{
    age = a;
    cout &lt;&lt; "Person's call of parametric constructor" &lt;&lt; endl;
}

Person::Person(const Person &amp;p) //就是把一个对象的所有值拷贝给另一个对象
{
    age = p.age;
    cout &lt;&lt; "Person's call of copy constructor" &lt;&lt; endl;
}

Person::~Person()
{
    cout &lt;&lt; "Person's call of destructor" &lt;&lt; endl;
}

// call fo
void test01()
{
    // 1.括号法
    // Person p1;     //默认构造函数调用
    // Person p2(10); // 有参构造函数
    // Person p3(p2); //拷贝构造函数

    //! 注意事项
    // 调用默认构造函数的时候，不要加（）
    // 因为下面这行代码，编译器会认为是一个函数的声明，不会认为在创建对象

    //? Person p1();
    // 比如 void test(); 这样

    // cout &lt;&lt; "p2's age:" &lt;&lt; p2.age &lt;&lt; endl;
    // cout &lt;&lt; "p3's age:" &lt;&lt; p3.age &lt;&lt; endl;

    // 2.显示法

    // Person p11;
    // Person p21 = Person(10); //有参调用
    // Person p31 = Person(p21); //拷贝构造函数

    // Person(20); // 匿名对象 // 特点：当前行执行结束后，系统会立即回收匿名对象
    // cout &lt;&lt; "aaaaa" &lt;&lt; endl;

    // 注意事项2: 

    // 不要利用拷贝构造函数初始化匿名对象
    // 编译器会认为是 Person （p3） == Person p3；

    //Person(p31); 

    // 3.隐式调用
    Person p4=10; // Person p4 = Person(10);
    Person p5=p4;

}

int main()
{
    test01();

    return 0;
}</code></pre>



<h5 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Person
{
private:
    /* data */
public:
    Person();
    Person(int a);
    Person(const Person &amp;a);
    ~Person();
    int m_age;
};

Person::Person()
{
    // 无参构造，也就是默认构造
    cout &lt;&lt; "Person's call of nonparametric constructor" &lt;&lt; endl;
}

Person::Person(int age)
{
    m_age = age;
    cout &lt;&lt; "Person's call of parametric constructor" &lt;&lt; endl;
}

Person::Person(const Person &amp;p)
{
    m_age = p.m_age;
    cout &lt;&lt; "Person's call of copy constructor" &lt;&lt; endl;
}

Person::~Person()
{
    cout &lt;&lt; "Person's call of destructor" &lt;&lt; endl;
}

// 1.使用一个以及创建完毕的对象来初始化一个新对象
void test01()
{
    
    Person p1(20);
    Person p2(p1);

    cout &lt;&lt; "p2's age is:" &lt;&lt; endl;
}

// 2.值传递的方式给函数参数传值
void doWork(Person p)
{

}

void test02()
{
    Person p; // 默认构造
    doWork(p); // 拷贝构造
}

// 3.值方式返回局部对象

Person dowork2()
{
    Person p11;
    cout&lt;&lt;(int*)&amp;p11&lt;&lt;endl;
    return p11; // 拷贝构造
}

void test03()
{
    Person p=dowork2();
    cout&lt;&lt;(int*)&amp;p&lt;&lt;endl;
}

int main()
{
    //test01();
    test03();
    return 0;
}</code></pre>



<h5 id="4-2-4-拷贝构造函数调用规则"><a href="#4-2-4-拷贝构造函数调用规则" class="headerlink" title="4.2.4 拷贝构造函数调用规则"></a>4.2.4 拷贝构造函数调用规则</h5><p>默认情况下，c++编译器至少给一个类添加3个函数</p>
<ol>
<li> 默认构造函数（无参，函数体为空）</li>
<li> 默认析构函数（无参，函数体为空）</li>
<li> 默认拷贝构造函数，对属性进行值拷贝</li>
</ol>
<p>构造函数调用规则如下:</p>
<p>● 如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造<br>● 如果用户定义拷贝构造函数, C++不会再提供其他构造函数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">class Person {
public:
	Person() {
		cout &lt;&lt; "无参构造函数!" &lt;&lt; endl;
		mAge = 0;
	}
	Person(int age) {
		cout &lt;&lt; "有参构造函数!" &lt;&lt; endl;
		mAge = age;
	}
	Person(const Person&amp; p) {
		cout &lt;&lt; "拷贝构造函数!" &lt;&lt; endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout &lt;&lt; "析构函数!" &lt;&lt; endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;
}


int main() {

	//test01();
	//test02();
	test03();

	system("pause");

	return 0;
}
</code></pre>



<h5 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h5><p>深浅拷贝是面试经典问题，也是常见的一个坑</p>
<p>浅拷贝：简单的赋值拷贝操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<h5 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt; 
using namespace std;

class Student {
public:
  Student(int a, int s, int h):m_Age(a), m_Score(s), m_Hight(h){}
private:
  int m_Age;
  int m_Score;
  int m_Hight;
}

int main() {
  Student s1;
  return 0;
}</code></pre>



<h5 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt; 
using namespace std;

class Phone {
public:
  Phone(string name) {
    m_PhoneName = name;
  }
  string m_PhoneName;
}

class Student {
public:
  Student(int a, int s, int h):m_Age(a), m_Score(s), m_Hight(h){}
  Phone m_Phone;
private:
  int m_Age;
  int m_Score;
  int m_Hight;
}

int main() {
  Student s1;
  return 0;
}</code></pre>



<h5 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h5><p>静态成员就是类中的成员变量和成员函数前面加上static，就是静态成员</p>
<ul>
<li>静态成员变量：<ul>
<li>  所有对象共享一份数据</li>
<li>  在编译阶段分配内存</li>
<li>  类内声明，类外初始化</li>
</ul>
</li>
<li>静态成员函数：<ul>
<li>  所有对象共享一个函数</li>
<li>  静态成员函数只能访问静态成员变量</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h4><h5 id="4-3-2-成员变量和成员函数分开存储"><a href="#4-3-2-成员变量和成员函数分开存储" class="headerlink" title="4.3.2 成员变量和成员函数分开存储"></a>4.3.2 成员变量和成员函数分开存储</h5><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;

// 类的大小为类的非静态成员变量
// 类的成员函数和静态成员函数不在类的存储空间中
// 此时类的大小为4
class Person {
  static int m_Score;
  int m_Age;
  void run() {
    cout &lt;&lt; "run" &lt;&lt; endl;
  }
}

// 空类的大小为1
class Person1 {
  
}

int main() {
  cout &lt;&lt; sizeof(Person()) &lt;&lt; endl;
  return 0;
}</code></pre>

<h5 id="4-3-2-this指针"><a href="#4-3-2-this指针" class="headerlink" title="4.3.2 this指针"></a>4.3.2 this指针</h5><p>通过前面一节我们知道C++中成员变量和成员函数是分开存储的</p>
<p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型对象会共用一块代码</p>
<p>那么这一块代码究竟是怎么区分那个对象调用自己的呢</p>
<p>C++通过提供特殊对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象</p>
<p>this指针是隐含每一个非静态成员函数内的一种指针</p>
<p>this指针不需要定义，直接使用即可</p>
<p>this指针的用途：</p>
<p><code>this指针的本质是指针常量，this的指向不可以改变</code></p>
<ul>
<li>  当形参和成员变量同名时，用来区分二者</li>
<li>  在类的非静态成员函数中返回对象本身，可使用return *this</li>
</ul>
<pre class="language-c++" data-language="c++"><code class="language-c++">//
//  main.cpp
//  this指针
//
//  Created by ChengBei's iMac on 2021/9/8.
//

#include &lt;iostream&gt;
using namespace std;

class Person {
public:
    Person(int age) {
        m_Age = age;
    }
    void addPersonAge(int age) {
        m_Age = m_Age + age;
    }
    
    // 返回类的本身，可以链式调用
    // 这里为什么要返回引用呢，因为要引用传递，放回这个类的本身，而不是它的拷贝
    Person&amp; addPersonAgeTwo(int age) {
        m_Age += age;
        return *this; // 为什么返回的是this呢，因为this指向的是这个对象的指针，所以*this是这个对象本身
    }
    int m_Age = 0;
};

int main(int argc, const char * argv[]) {
    
    Person p1(10);
    p1.addPersonAge(10);
    
    Person p2(20);
    p2.addPersonAgeTwo(30).addPersonAge(20);
    cout &lt;&lt; p1.m_Age &lt;&lt; endl;
    cout &lt;&lt; p2.m_Age &lt;&lt; endl;
    return 0;
}
</code></pre>

<h5 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h5><p>常函数：</p>
<ul>
<li>  成员函数前面加上const后称为常函数</li>
<li>  常函数内不可以修改成员属性</li>
<li>  成员属性内加关键字mutable后，在常函数中依然可以修改</li>
</ul>
<p>常对象：</p>
<ul>
<li>  声明对象前加const称该对象为常对象</li>
<li>  常对象只能调用常函数</li>
</ul>
<h4 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h4><h5 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h5><p>作用：实现两个自定义数据的相加</p>
<h5 id="4-5-6-继承同名成员处理方式"><a href="#4-5-6-继承同名成员处理方式" class="headerlink" title="4.5.6 继承同名成员处理方式"></a>4.5.6 继承同名成员处理方式</h5><ol>
<li>  子类对象可以直接访问到子类中同名成员</li>
<li>  子类对象加作用域可以访问到父类同名成员</li>
<li>  当子类与父类拥有同名的成员函数，子类会隐藏父类中的成员函数，这时候加作用域可以访问到父类中的成员函数</li>
</ol>
<h3 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5. 文件操作"></a>5. 文件操作</h3><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放。</p>
<p>通过文件可以将数据存储。</p>
<p>文件类型分为两种：</p>
<p>1.文本文件：文件以文本ASCII码形式存储在计算机中</p>
<p>2.二进制文件：文件以文本二进制形式存储在计算机中</p>
<p>操作文件三大类：</p>
<ol>
<li> ofstream：写操作</li>
<li> ifstream：读操作</li>
<li> fstream：读写操作</li>
</ol>
<h4 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h4><h5 id="4-7-1-多态的基本概念："><a href="#4-7-1-多态的基本概念：" class="headerlink" title="4.7.1 多态的基本概念："></a>4.7.1 多态的基本概念：</h5><p>多态分为两类：</p>
<ul>
<li>  静态多态：函数重载和运算符重载属于静态多态，复用函数名</li>
<li>  动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态的区别：</p>
<ul>
<li>  静态多态的地址早绑定  - 编译阶段确定函数地址</li>
<li>  动态多态的地址晚绑定 - 运行阶段确定函数地址（因为运行时才确定到底走哪个函数）</li>
</ul>
<h5 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h5><p>多态使用时，如果子类有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决方式：将父类中的析构函数改为虚析构或纯虚析构</p>
<p>虚析构和纯虚析构共性：</p>
<ul>
<li>  可以解决父类指针释放子类对象的问题</li>
<li>  都需要有具体的函数实现</li>
</ul>
<p>区别：</p>
<ul>
<li>  如果是纯虚析构，该类属于抽象类，无法实例化</li>
</ul>
<p>总结：</p>
<ol>
<li>  虚析构和纯虚析构就是用来解决通过父类指针释放子类对象的</li>
<li>  如果子类中没有堆区数据，可以不写虚析构或纯虚析构</li>
<li>  拥有纯虚析构的函数也属于抽象类</li>
</ol>
<h4 id="5-1-文本文件"><a href="#5-1-文本文件" class="headerlink" title="5.1 文本文件"></a>5.1 文本文件</h4><h5 id="5-1-1-写文件"><a href="#5-1-1-写文件" class="headerlink" title="5.1.1 写文件"></a>5.1.1 写文件</h5><p>写文件步骤如下：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">1.包含头文件
	#include&lt;fstream&gt;

2.创建流对象
  ofstream.ofs;

3.打开文件
  ofs.open("文件路径",打开方式)；
  
4.写数据
  ofs&lt;&lt;"写入"；
  
5.关闭文件
  ofs.close();</code></pre>



<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th align="center">打开方式</th>
<th align="center">解释:</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::in</td>
<td align="center">为读文件而打开文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::out</td>
<td align="center">为写文件而打开文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">初始位置：文件尾</td>
<td></td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">追加方式写文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">如果文件存在先删除，再创建</td>
<td></td>
</tr>
<tr>
<td align="center">iOS::binary</td>
<td align="center">二进制方式</td>
<td></td>
</tr>
</tbody></table>
<p><strong>注意：文件打开方式可以配合|使用</strong></p>
<p><strong>用二进制方式写文件 ios::binary | ios::out</strong></p>
<h5 id="5-1-2-读文件"><a href="#5-1-2-读文件" class="headerlink" title="5.1.2 读文件"></a>5.1.2 读文件</h5><p>写文件步骤如下：</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">1.包含头文件
	#include&lt;fstream&gt;

2.创建流对象
  ifstream ifs;

3.打开文件
  ofs.open("文件路径",打开方式)；
  
4.写数据
  四种方式读取
  
5.关闭文件
  ifs.close();</code></pre>



<p>文件打开方式：</p>
<table>
<thead>
<tr>
<th align="center">打开方式</th>
<th align="center">解释:</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">ios::in</td>
<td align="center">为读文件而打开文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::out</td>
<td align="center">为写文件而打开文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::ate</td>
<td align="center">初始位置：文件尾</td>
<td></td>
</tr>
<tr>
<td align="center">ios::app</td>
<td align="center">追加方式写文件</td>
<td></td>
</tr>
<tr>
<td align="center">ios::trunc</td>
<td align="center">如果文件存在先删除，再创建</td>
<td></td>
</tr>
<tr>
<td align="center">iOS::binary</td>
<td align="center">二进制方式</td>
<td></td>
</tr>
</tbody></table>
<h4 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h4><p>以二进制的方式对文件进行读写操作</p>
<p>打开方式要指定为 ios::binary</p>
<h5 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h5><p>二进制方式写文件主要利用流对象调用成员函数write</p>
<p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;fstream&gt;
#include &lt;string&gt;

using namespace std;

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

//二进制文件  写文件
void test01()
{
	//1、包含头文件

	//2、创建输出流对象
	ofstream ofs("person.txt", ios::out | ios::binary);
	
	//3、打开文件
	//ofs.open("person.txt", ios::out | ios::binary);

	Person p = {"张三"  , 18};

	//4、写文件
	ofs.write((const char *)&amp;p, sizeof(p));

	//5、关闭文件
	ofs.close();
}

int main() {

	test01();
	return 0;
}
</code></pre>

<p>总结：</p>
<ul>
<li>  文件输出流对象 可以通过write函数，以二进制方式写数据</li>
</ul>
<h5 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h5><p>二进制方式读文件主要利用流对象调用成员函数read</p>
<p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p>
<p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p>
<pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

class Person
{
public:
	char m_Name[64];
	int m_Age;
};

void test01()
{
	ifstream ifs("person.txt", ios::in | ios::binary);
	if (!ifs.is_open())
	{
		cout &lt;&lt; "文件打开失败" &lt;&lt; endl;
	}

	Person p;
	ifs.read((char *)&amp;p, sizeof(p));

	cout &lt;&lt; "姓名： " &lt;&lt; p.m_Name &lt;&lt; " 年龄： " &lt;&lt; p.m_Age &lt;&lt; endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
</code></pre>





<pre class="language-none"><code class="language-none">class Solution {
public:
    int integerBreak(int n) {
        vector&lt;int&gt; dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i &lt;= n ; i++) {
            for (int j = 1; j &lt; i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};

5
i = 3 dp[3] = </code></pre>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题切换样式问题</title>
    <url>/2022/04/03/hexo%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E6%A0%B7%E5%BC%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="hexo-主题切换样式问题及解决方法"><a href="#hexo-主题切换样式问题及解决方法" class="headerlink" title="hexo 主题切换样式问题及解决方法"></a>hexo 主题切换样式问题及解决方法</h3><p>在 hexo 不同主题直接切换的时候，上一个主题编译好的文件可能会影响到下一个主题的样式。原因就是因为使用了一个主题，这个主题的 css 样式会被引入到 public 的 css 文件夹中。</p>
<p>但是换了主题的时候，之前的主题编译的 css 还在 public 中，也就是说 hexo 只是更新了主题和重新编译了本地文件，并没有将重新编译的 public 文件更新到 github 的 page 页面上，所以造成了本地和线上的样式不一样。</p>
<span id="more"></span>

<p>可以看到，只用 hexo c、hexo g -d 的效果是这样，注意 css 文件的更新时间。无论怎么 hexo d，css 还是不更新嗷。</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0wgqofijzj21jm0u0wjk.jpg"></p>
<p>但是要将重新编译好的本地文件更新到 github 上面怎么办，可以在 github 的 hexo 仓库新建一个分支，在 hexo 根目录下的配置文件里面更改一下推送的分支，然后再改回来原来的分支，就可以了（不改回来用新的分支也可以）</p>
<p>![image-20220403132522105](/Users/onlybei/Library/Application Support/typora-user-images/image-20220403132522105.png)</p>
<p>这样操作之后，可以看到 css 文件更新了</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h0wgxzaddvj21550u0ae3.jpg"></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的js之作用域</title>
    <url>/2022/03/03/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”</p>
<ul>
<li><p>分词/词法分析（Tokening/Lexing）</p>
<p>如var a = 2;。会被分解为:var、a、=、2 、;</p>
</li>
<li><p>解析/语法分析 (Parsing)</p>
<p>这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树” (Abstract Syntax Tree，AST)</p>
</li>
<li><p>代码生成</p>
<p>将 AST 转换为可执行代码的过程称被称为代码生成</p>
</li>
</ul>
<p>感觉 HTML 的编译过程和这个有点类似。果然天下语言不分家</p>
<h3 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h3><p>名词解释：</p>
<ul>
<li> 引擎</li>
</ul>
<p>  从头到尾负责整个 JavaScript 程序的编译及执行过程。</p>
<ul>
<li><p>编译器</p>
<p>负责语法分析及代码生成</p>
</li>
<li><p>作用域（重点）</p>
<p>负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>
</li>
</ul>
<p>为了理解三者关系，举一个🌰来说明</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span></code></pre>

<ul>
<li>首先编译器会将这段代码进行词法分析，生成词法单元。然后将词法单元解析，生成 AST</li>
</ul>
<ul>
<li>编译器编译具体过程：<ul>
<li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。（var 变量提升）</li>
<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量（运行时赋值）</li>
</ul>
</li>
</ul>
<p>LHS 查询 和 RHS 查询</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取得 a 的值，这样才能将值传递给 console.log(..)；</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript">a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span></code></pre>

<p>这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为<code>= 2</code>这个赋值操作找到一个目标。</p>
<p>LHS 查询 和 RHS 查询总结：</p>
<p>LHS：赋值操作的目标是谁</p>
<p>RHS：谁是赋值操作的源头</p>
<p>对 LHS 和 RHS 进一步的理解：</p>
<p>考虑如下代码:</p>
<pre class="language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a <span class="token operator">+</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> 
		b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变 量，因为在任何相关的作用域中都无法找到它。</p>
<p>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是，ReferenceError 是非常重要的异常类型。</p>
<p>相较之下，当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，</p>
<p>全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎。（非严格模式下才会创建，严格模式禁止自动或隐式地创建全局变量。因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常）</p>
<p>知识补充：ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域是什么？</p>
<p>大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。</p>
<p>这个概念是理解词法作用域及其名称来历的基础。</p>
<p>词法作用域能不能更改？</p>
<p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的，可以使用 eval 进行更改)</p>
<p>欺骗词法，更改词法作用域（但在严格模式下，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域）</p>
<pre class="language-none"><code class="language-none">function foo(str, a) { 
	eval( str ); // 欺骗! 
	console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3</code></pre>

<p>eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代 码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实 上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽 了外部(全局)作用域中的同名变量。</p>
<p>当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到 外部的 b。因此会输出“1, 3”而不是正常情况下会输出的“1, 2”。</p>
<p>但是这种在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。因为使用了 eval 之后，编译器的优化几乎起不到作用！</p>
<p>⚠️ <strong>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</strong></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
